<!DOCTYPE html>
<!-- saved from url=(0050)file:///Users/lindseylister/Downloads/index_3.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Warfare - Ranked</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        html {
            -webkit-text-size-adjust: 100%;
            -moz-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
            touch-action: manipulation;
            width: 100%;
            position: relative;
        }

        .container {
            max-width: 1100px;
            margin: 0 auto;
        }

        .game-layout {
            display: flex;
            gap: 15px;
            align-items: flex-start;
            justify-content: center;
            flex-wrap: wrap;
        }

        h1 {
            text-align: center;
            color: #fff;
            font-size: 2.5em;
            margin: 10px 0;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 20px rgba(255, 255, 255, 0.5); }
            to { text-shadow: 0 0 30px rgba(255, 255, 255, 0.8); }
        }

        .battle-title {
            text-align: center;
            color: #ff6b6b;
            font-size: 1.5em;
            margin-bottom: 10px;
            font-weight: bold;
            text-shadow: 0 0 15px #ff6b6b;
            animation: battleGlow 1s ease-in-out infinite alternate;
        }

        @keyframes battleGlow {
            from { text-shadow: 0 0 15px #ff6b6b; }
            to { text-shadow: 0 0 25px #ff6b6b, 0 0 35px #ff3333; }
        }

        .ranked-hud {
            display: none;
            background: linear-gradient(135deg, rgba(220, 20, 60, 0.3), rgba(255, 140, 0, 0.3));
            padding: 15px;
            border-radius: 15px;
            border: 2px solid #ffd700;
            margin-bottom: 15px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .ranked-hud.active {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .ranked-stat {
            text-align: center;
            color: #fff;
        }

        .ranked-stat-label {
            font-size: 0.9em;
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .ranked-stat-value {
            font-size: 1.3em;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .rank-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            margin: 5px auto;
            border-radius: 50%;
            position: relative;
        }

        .rank-badge svg {
            width: 56px;
            height: 56px;
            filter: drop-shadow(0 0 8px var(--rank-glow, #fff));
        }

        .rank-badge-mini {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
        }

        .rank-badge-mini svg {
            width: 24px;
            height: 24px;
            filter: drop-shadow(0 0 4px var(--rank-glow, #fff));
        }

        .rp-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }

        .rp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffed4e);
            transition: width 0.3s ease;
            border-radius: 4px;
            box-shadow: 0 0 10px #ffd700;
        }

        .turn-display {
            font-size: 1.8em;
            font-weight: bold;
            text-align: center;
            color: #ffd700;
            text-shadow: 0 0 15px #ffd700, 0 0 30px #ffd700;
            padding: 15px;
            margin-bottom: 15px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.1));
            border-radius: 15px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            animation: turnGlow 2s ease-in-out infinite;
        }

        @keyframes turnGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }
            50% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.6); }
        }

        .online-lobby-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); z-index: 10000;
            display: flex; align-items: center; justify-content: center;
        }
        .online-lobby-overlay.hidden { display: none; }
        .online-lobby {
            background: linear-gradient(135deg, #1a1a3e, #2a2a5e);
            border: 2px solid #ffd700; border-radius: 20px;
            padding: 30px; text-align: center; max-width: 420px; width: 90%;
        }
        .online-lobby h2 { color: #ffd700; margin-bottom: 20px; font-size: 1.5em; }
        .online-lobby .lobby-status {
            padding: 8px 16px; border-radius: 20px; font-size: 13px;
            font-weight: bold; display: inline-block; margin-bottom: 20px;
        }
        .lobby-status.connecting { background: #533483; color: #ccc; }
        .lobby-status.connected { background: #1b5e20; color: #a5d6a7; }
        .lobby-status.disconnected { background: #b71c1c; color: #ef9a9a; }
        .online-lobby .lobby-btn {
            padding: 12px 30px; font-size: 18px; border: none;
            border-radius: 8px; cursor: pointer; margin: 8px;
            font-weight: bold; transition: transform 0.1s;
        }
        .online-lobby .lobby-btn:active { transform: scale(0.95); }
        .online-lobby .lobby-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .lobby-btn-create { background: #e94560; color: white; }
        .lobby-btn-join { background: #0f3460; color: white; }
        .lobby-btn-back { background: #555; color: white; margin-top: 15px; }
        .online-lobby input {
            padding: 12px; font-size: 20px; border-radius: 8px;
            border: 2px solid #0f3460; text-align: center; width: 140px;
            text-transform: uppercase; background: #16213e; color: #eee;
            letter-spacing: 5px;
        }
        .lobby-room-code {
            font-size: 52px; font-weight: bold; color: #e94560;
            letter-spacing: 12px; margin: 20px 0;
            text-shadow: 0 0 20px rgba(233,69,96,0.5);
        }
        .lobby-waiting { color: #aaa; font-size: 16px; animation: lobbyPulse 1.5s ease-in-out infinite; }
        @keyframes lobbyPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .online-player-badge {
            display: inline-block; background: #533483; color: #fff;
            padding: 4px 12px; border-radius: 15px; font-size: 12px;
            margin-bottom: 10px;
        }

        .score-display {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 10px;
            margin-bottom: 15px;
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.2), rgba(33, 150, 243, 0.2));
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        .score-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .score-label {
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .score-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
        }

        .board-container {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            padding: 15px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 3px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            margin-bottom: 15px;
            position: relative;
            width: 100%;
            max-width: 530px;
            margin-left: auto;
            margin-right: auto;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            width: 90vw;
            max-width: 500px;
            height: 90vw;
            max-height: 500px;
            margin: 0 auto;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.5em, 4.5vw, 2.2em);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            min-height: 40px;
        }

        .square.light {
            background: linear-gradient(135deg, #e8e8ff 0%, #d0d0ff 100%);
        }

        .square.dark {
            background: linear-gradient(135deg, #4a4a7a 0%, #35355a 100%);
        }

        .square.selected {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%) !important;
            box-shadow: inset 0 0 20px rgba(255, 215, 0, 0.8);
            animation: pulse 0.8s ease-in-out infinite;
        }

        .square.legal-move {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%) !important;
        }

        .square.legal-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            background: rgba(0, 255, 136, 0.5);
            border-radius: 50%;
        }

        .square.ability-target {
            background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%) !important;
            animation: targetPulse 0.5s ease-in-out infinite;
        }

        @keyframes targetPulse {
            0%, 100% { box-shadow: inset 0 0 20px rgba(255, 68, 68, 0.8); }
            50% { box-shadow: inset 0 0 30px rgba(255, 68, 68, 1); }
        }

        .square.in-check {
            background: linear-gradient(135deg, #ff0044 0%, #cc0033 100%) !important;
            animation: checkPulse 0.5s ease-in-out infinite;
        }

        @keyframes checkPulse {
            0%, 100% {
                box-shadow: inset 0 0 20px rgba(255, 0, 68, 0.8);
            }
            50% {
                box-shadow: inset 0 0 30px rgba(255, 0, 68, 1), 0 0 20px rgba(255, 0, 68, 0.8);
            }
        }

        .piece {
            filter: drop-shadow(0 8px 12px rgba(0, 0, 0, 0.9));
            transition: all 0.3s ease;
            position: relative;
            z-index: 10;
            font-weight: 900;
            animation: pieceFloat 3s ease-in-out infinite;
            line-height: 1;
        }

        .piece.custom-wizard {
            background: radial-gradient(circle, rgba(138, 43, 226, 0.4), transparent);
            padding: 3px;
            border-radius: 50%;
        }

        .piece.custom-grandpa {
            background: radial-gradient(circle, rgba(139, 69, 19, 0.4), transparent);
            padding: 3px;
            border-radius: 50%;
        }

        .piece.custom-tank {
            background: radial-gradient(circle, rgba(128, 128, 128, 0.4), transparent);
            padding: 3px;
            border-radius: 50%;
        }

        .piece.custom-assassin {
            background: radial-gradient(circle, rgba(220, 20, 60, 0.4), transparent);
            padding: 3px;
            border-radius: 50%;
        }

        .piece.custom-dragon {
            background: radial-gradient(circle, rgba(255, 140, 0, 0.4), transparent);
            padding: 3px;
            border-radius: 50%;
        }

        .piece.custom-lizard {
            background: radial-gradient(circle, rgba(34, 139, 34, 0.5), transparent);
            padding: 3px;
            border-radius: 50%;
            animation: lizardWiggle 0.5s ease-in-out infinite;
        }

        .piece.custom-ghost {
            background: radial-gradient(circle, rgba(200, 200, 255, 0.3), transparent);
            padding: 3px;
            border-radius: 50%;
            animation: ghostFloat 2s ease-in-out infinite;
            opacity: 0.9;
        }

        @keyframes ghostFloat {
            0%, 100% { transform: translateY(0px); opacity: 0.9; }
            50% { transform: translateY(-5px); opacity: 0.7; }
        }

        .piece.custom-saboteur {
            background: radial-gradient(circle, rgba(50, 50, 50, 0.4), transparent);
            padding: 3px;
            border-radius: 50%;
            filter: drop-shadow(0 0 5px rgba(255, 100, 0, 0.5));
        }

        .landmine-indicator {
            font-size: 1.5em;
            animation: mineFlash 1.5s ease-in-out infinite;
        }

        @keyframes mineFlash {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        @keyframes lizardWiggle {
            0%, 100% { transform: translateY(0px) rotate(-2deg); }
            50% { transform: translateY(-2px) rotate(2deg); }
        }

        @keyframes pieceFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-3px); }
        }

        .piece:hover {
            transform: scale(1.05) translateY(-2px);
            filter: drop-shadow(0 10px 15px rgba(0, 0, 0, 1));
        }

        .piece::after {
            content: attr(data-tooltip);
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 0.5em;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 10000;
            border: 1px solid #4CAF50;
            font-weight: bold;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
        }

        .piece:hover::after {
            opacity: 1;
        }

        .health-bar-container {
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 4px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 2px;
            overflow: hidden;
        }

        .health-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff0000 0%, #ffff00 50%, #00ff00 100%);
            transition: width 0.3s ease;
            border-radius: 2px;
        }

        .ability-indicator {
            position: absolute;
            top: -3px;
            left: -3px;
            font-size: 0.4em;
            z-index: 15;
            filter: drop-shadow(0 0 3px #ffd700);
            animation: abilityPulse 2s ease-in-out infinite;
        }

        @keyframes abilityPulse {
            0%, 100% { transform: scale(1) rotate(-10deg); }
            50% { transform: scale(1.15) rotate(10deg); }
        }

        .lizard-indicator {
            position: absolute;
            top: -3px;
            right: -3px;
            font-size: 0.4em;
            z-index: 15;
            filter: drop-shadow(0 0 3px #00ff00);
            animation: lizardWiggle 0.5s ease-in-out infinite;
        }

        .shield-indicator {
            position: absolute;
            bottom: 8px;
            right: -2px;
            font-size: 0.4em;
            z-index: 15;
            filter: drop-shadow(0 0 5px #00ffff);
            animation: shieldGlow 1.5s ease-in-out infinite;
        }

        @keyframes shieldGlow {
            0%, 100% { filter: drop-shadow(0 0 5px #00ffff); transform: scale(1); }
            50% { filter: drop-shadow(0 0 10px #00ffff); transform: scale(1.15); }
        }

        .shield-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ccff, #00ffff);
            position: absolute;
            right: 0;
            top: 0;
            border-radius: 2px;
            opacity: 0.8;
        }

        .controls {
            text-align: center;
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 25px;
            font-size: 1em;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .reset-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .new-game-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        .promotion-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .promotion-overlay.hidden {
            display: none;
        }

        .promotion-dialog {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px 40px;
            border-radius: 20px;
            border: 4px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 15px 60px rgba(0, 0, 0, 0.6);
            text-align: center;
        }

        .promotion-dialog h2 {
            color: #fff;
            font-size: 1.8em;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        .promotion-choices {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .promotion-choice {
            font-size: 2.5em;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.15);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .promotion-choice:hover {
            background: rgba(255, 215, 0, 0.3);
            border-color: #ffd700;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }

        .promotion-choice-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.7em;
            margin-top: 4px;
        }

        .promotion-choice-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .game-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 35px 45px;
            border-radius: 20px;
            box-shadow: 0 15px 60px rgba(0, 0, 0, 0.6);
            z-index: 1000;
            text-align: center;
            border: 4px solid rgba(255, 255, 255, 0.5);
            opacity: 0;
            transition: all 0.5s ease;
            max-width: 90%;
        }

        .game-message.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .game-message h2 {
            color: #fff;
            font-size: 2.2em;
            margin-bottom: 12px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
        }

        .game-message p {
            color: #fff;
            font-size: 1.2em;
            margin-bottom: 20px;
        }

        .ranked-results-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 3500;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ranked-results-overlay.hidden {
            display: none;
        }

        .ranked-results-dialog {
            background: linear-gradient(135deg, #dc143c 0%, #ff6b35 50%, #9b59b6 100%);
            padding: 40px;
            border-radius: 25px;
            border: 4px solid #ffd700;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.4), 0 15px 60px rgba(0, 0, 0, 0.8);
            text-align: center;
            max-width: 500px;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .ranked-results-dialog h2 {
            color: #ffd700;
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
        }

        .ranked-result-item {
            margin: 15px 0;
            color: #fff;
            font-size: 1.1em;
        }

        .ranked-result-label {
            color: #ffd700;
            font-weight: bold;
        }

        .rp-change {
            font-size: 1.5em;
            font-weight: bold;
            margin: 15px 0;
            padding: 10px;
            border-radius: 10px;
        }

        .rp-gain {
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }

        .rp-loss {
            background: rgba(255, 0, 0, 0.2);
            color: #ff6b6b;
            text-shadow: 0 0 10px #ff6b6b;
        }

        .rank-up-animation {
            animation: rankUpPulse 0.6s ease-out;
        }

        @keyframes rankUpPulse {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        .ranked-results-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }

        .ranked-results-buttons button {
            padding: 15px 30px;
            font-size: 1.1em;
        }

        .next-round-btn {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: white;
        }

        .back-menu-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .mode-selector {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
        }

        .mode-selector.hidden {
            display: none;
        }

        .mode-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            border: 4px solid rgba(255, 255, 255, 0.5);
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            text-align: center;
        }

        .mode-content h2 {
            color: #fff;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
        }

        .mode-buttons {
            display: grid;
            gap: 15px;
            margin-bottom: 20px;
        }

        .mode-button {
            padding: 20px;
            font-size: 1.3em;
            font-weight: 600;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            transition: all 0.3s ease;
        }

        .mode-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
            border-color: #ffd700;
        }

        .mode-button.selected {
            background: rgba(255, 215, 0, 0.3);
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        #ai-difficulty-section {
            display: none;
            margin-top: 20px;
        }

        #ranked-info-section {
            display: none;
            margin-top: 20px;
        }

        .difficulty-label {
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.2em;
            font-weight: 600;
        }

        .difficulty-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        #difficulty-slider {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            outline: none;
            cursor: pointer;
        }

        #difficulty-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            transition: all 0.2s ease;
        }

        #difficulty-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.8);
        }

        #difficulty-slider::-moz-range-thumb {
            width: 25px;
            height: 25px;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            transition: all 0.2s ease;
        }

        #difficulty-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.8);
        }

        #difficulty-value {
            color: #ffd700;
            font-size: 1.5em;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
            text-shadow: 0 0 10px #ffd700;
        }

        .difficulty-labels {
            display: flex;
            justify-content: space-between;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9em;
            margin-top: 8px;
        }

        .ranked-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .rank-tier-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 0.9em;
        }

        .rank-tier-icon {
            font-size: 1.5em;
            margin-bottom: 5px;
        }

        .rank-tier-name {
            font-weight: bold;
            color: #ffd700;
        }

        .rank-tier-rp {
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 3px;
        }

        #start-game-btn {
            display: none;
            padding: 18px 40px;
            font-size: 1.3em;
            font-weight: 600;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(79, 172, 254, 0.4);
            margin-top: 10px;
        }

        #start-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 30px rgba(79, 172, 254, 0.6);
        }

        .piece-reference-guide {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            padding: 15px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            width: 340px;
            flex-shrink: 0;
            order: -1;
        }

        .piece-reference-guide h3 {
            color: #ffd700;
            text-align: center;
            margin-bottom: 12px;
            font-size: 0.95em;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            line-height: 1.3;
        }

        .piece-reference-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .piece-ref-item {
            background: rgba(255, 255, 255, 0.08);
            padding: 8px 6px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            transition: all 0.3s ease;
            cursor: default;
        }

        .piece-ref-item:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .piece-ref-item.highlighted {
            background: rgba(255, 215, 0, 0.2);
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        .piece-ref-icon {
            font-size: 1.6em;
            margin-bottom: 3px;
        }

        .piece-ref-name {
            color: #fff;
            font-weight: bold;
            font-size: 0.85em;
            margin-bottom: 2px;
        }

        .piece-ref-hp {
            color: #4CAF50;
            font-size: 0.75em;
            margin-bottom: 4px;
        }

        .piece-ref-ability {
            color: #ffeb3b;
            font-size: 0.72em;
            margin-top: 4px;
            padding-top: 4px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .piece-ref-ability-name {
            font-weight: bold;
            margin-bottom: 2px;
        }

        .piece-ref-ability-desc {
            font-size: 0.68em;
            line-height: 1.2;
            color: rgba(255, 235, 59, 0.8);
        }

        @media (max-width: 900px) {
            .game-layout {
                flex-direction: column;
                align-items: center;
            }
            .piece-reference-guide {
                width: 100%;
                max-width: 530px;
                order: 1;
            }
        }

        .explosion {
            position: absolute;
            font-size: 3em;
            z-index: 100;
            pointer-events: none;
            animation: explode 0.6s ease-out;
        }

        @keyframes explode {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        .shockwave {
            position: absolute;
            border: 4px solid #ffd700;
            border-radius: 50%;
            z-index: 100;
            pointer-events: none;
            animation: shockwaveExpand 0.6s ease-out;
        }

        @keyframes shockwaveExpand {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
            }
            100% {
                width: 300%;
                height: 300%;
                opacity: 0;
            }
        }

        .bullet {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ffff00;
            border-radius: 50%;
            box-shadow: 0 0 10px #ffff00;
            z-index: 100;
            pointer-events: none;
        }

        .arrow {
            position: absolute;
            width: 20px;
            height: 3px;
            background: linear-gradient(90deg, #8b4513, #cd853f);
            z-index: 100;
            pointer-events: none;
        }

        .arrow::before {
            content: '';
            position: absolute;
            right: -8px;
            top: -3px;
            width: 0;
            height: 0;
            border-left: 10px solid #cd853f;
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
        }

        .fireball {
            position: absolute;
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, #ff4500, #ff8c00);
            border-radius: 50%;
            box-shadow: 0 0 20px #ff4500;
            z-index: 100;
            pointer-events: none;
        }

        .heal-effect {
            position: absolute;
            font-size: 3em;
            z-index: 100;
            pointer-events: none;
            animation: healFloat 1s ease-out;
        }

        @keyframes healFloat {
            0% {
                transform: translateY(0) scale(0.5);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px) scale(1.5);
                opacity: 0;
            }
        }

        .teleport-effect {
            position: absolute;
            font-size: 4em;
            z-index: 100;
            pointer-events: none;
            animation: teleport 0.8s ease-out;
        }

        @keyframes teleport {
            0%, 100% { opacity: 0; transform: scale(0); }
            50% { opacity: 1; transform: scale(1.5); }
        }

        .slash-effect {
            position: absolute;
            font-size: 4em;
            z-index: 100;
            pointer-events: none;
            animation: slash 0.4s ease-out;
            color: #ff0000;
            text-shadow: 0 0 20px #ff0000;
        }

        @keyframes slash {
            0% {
                transform: translateX(-50px) rotate(-45deg) scale(0);
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: translateX(50px) rotate(-45deg) scale(1.5);
                opacity: 0;
            }
        }

        .shield-effect {
            position: absolute;
            border: 4px solid #00ffff;
            border-radius: 50%;
            z-index: 100;
            pointer-events: none;
            animation: shieldPulseEffect 0.8s ease-out;
        }

        @keyframes shieldPulseEffect {
            0% {
                width: 50%;
                height: 50%;
                opacity: 1;
            }
            100% {
                width: 150%;
                height: 150%;
                opacity: 0;
            }
        }

        .fire-breath {
            position: absolute;
            font-size: 3em;
            z-index: 100;
            pointer-events: none;
            animation: breatheFire 0.8s ease-out;
        }

        @keyframes breatheFire {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* ====== TUTORIAL OVERLAY ====== */
        .tutorial-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.92);
            z-index: 5000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            padding: 20px;
        }
        .tutorial-overlay.hidden { display: none; }

        .tutorial-box {
            background: linear-gradient(135deg, #1a1a3e 0%, #2d1b4e 50%, #1a1a3e 100%);
            border: 3px solid rgba(255, 215, 0, 0.6);
            border-radius: 25px;
            padding: 35px 40px;
            max-width: 650px;
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 0 60px rgba(255, 215, 0, 0.15), 0 20px 60px rgba(0,0,0,0.5);
            position: relative;
        }

        .tutorial-step-counter {
            text-align: center;
            color: rgba(255,215,0,0.6);
            font-size: 0.85em;
            margin-bottom: 8px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .tutorial-title {
            text-align: center;
            color: #ffd700;
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .tutorial-content {
            color: #e0e0e0;
            font-size: 1.05em;
            line-height: 1.7;
            margin-bottom: 25px;
        }

        .tutorial-content .highlight {
            color: #ffd700;
            font-weight: bold;
        }

        .tutorial-content .piece-demo {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: rgba(255,255,255,0.08);
            padding: 3px 10px;
            border-radius: 8px;
            margin: 2px 0;
        }

        .tutorial-content .piece-icon {
            font-size: 1.4em;
        }

        .tutorial-visual {
            background: rgba(0,0,0,0.35);
            border: 2px solid rgba(255,255,255,0.15);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0 20px 0;
            text-align: center;
        }

        .tutorial-visual .demo-board {
            display: inline-grid;
            grid-template-columns: repeat(4, 55px);
            grid-template-rows: repeat(4, 55px);
            gap: 2px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            overflow: hidden;
        }

        .tutorial-visual .demo-sq {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.6em;
        }

        .tutorial-visual .demo-sq.lt { background: linear-gradient(135deg, #e8e8ff, #d0d0ff); }
        .tutorial-visual .demo-sq.dk { background: linear-gradient(135deg, #4a4a7a, #35355a); }
        .tutorial-visual .demo-sq.sel { background: linear-gradient(135deg, #ffd700, #ffed4e) !important; box-shadow: inset 0 0 15px rgba(255,215,0,0.6); }
        .tutorial-visual .demo-sq.mv { background: linear-gradient(135deg, #00ff88, #00cc66) !important; }
        .tutorial-visual .demo-sq.atk { background: linear-gradient(135deg, #ff4444, #cc0000) !important; }

        .tutorial-visual .demo-caption {
            color: rgba(255,255,255,0.7);
            font-size: 0.85em;
            margin-top: 10px;
            font-style: italic;
        }

        .tutorial-tip {
            background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,140,0,0.1));
            border-left: 4px solid #ffd700;
            padding: 12px 16px;
            border-radius: 0 10px 10px 0;
            margin: 15px 0;
            color: #ffd700;
            font-size: 0.95em;
        }

        .tutorial-buttons {
            display: flex;
            justify-content: space-between;
            gap: 12px;
            margin-top: 10px;
        }

        .tutorial-btn {
            padding: 14px 30px;
            font-size: 1.05em;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
        }

        .tutorial-btn-back {
            background: rgba(255,255,255,0.1);
            color: #ccc;
            border: 2px solid rgba(255,255,255,0.2);
        }
        .tutorial-btn-back:hover { background: rgba(255,255,255,0.2); color: #fff; }
        .tutorial-btn-back:disabled { opacity: 0.3; cursor: default; }

        .tutorial-btn-next {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #1a1a3e;
        }
        .tutorial-btn-next:hover { transform: translateY(-2px); box-shadow: 0 4px 20px rgba(255,215,0,0.4); }

        .tutorial-btn-skip {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: rgba(255,255,255,0.4);
            font-size: 0.85em;
            cursor: pointer;
            padding: 5px 10px;
        }
        .tutorial-btn-skip:hover { color: #fff; }

        .tutorial-progress {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
        }

        .tutorial-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255,255,255,0.15);
            transition: all 0.3s ease;
        }
        .tutorial-dot.active {
            background: #ffd700;
            box-shadow: 0 0 8px rgba(255,215,0,0.5);
        }
        .tutorial-dot.done {
            background: rgba(255,215,0,0.4);
        }

        .tutorial-pieces-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 10px 0;
        }

        .tutorial-piece-card {
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 10px;
            padding: 10px 8px;
            text-align: center;
        }

        .tutorial-piece-card .tp-icon { font-size: 1.5em; }
        .tutorial-piece-card .tp-name { color: #fff; font-weight: bold; font-size: 0.85em; margin: 3px 0; }
        .tutorial-piece-card .tp-desc { color: rgba(255,255,255,0.6); font-size: 0.72em; line-height: 1.3; }

    </style>
</head>
<body>
    <div class="container">
        <h1>♟️ CHESS WARFARE ♟️</h1>
        <div id="battle-title" class="battle-title">CHESS WARFARE</div>
        <div class="ranked-hud" id="ranked-hud">
            <div class="ranked-stat">
                <div class="ranked-stat-label">Current Rank</div>
                <div class="rank-badge" id="ranked-rank-badge"></div>
                <div class="ranked-stat-value" id="ranked-rank-name">Bronze</div>
            </div>
            <div class="ranked-stat">
                <div class="ranked-stat-label">Ranking Points</div>
                <div class="ranked-stat-value" id="ranked-rp">0</div>
                <div class="rp-bar">
                    <div class="rp-bar-fill" id="ranked-rp-bar"></div>
                </div>
            </div>
            <div class="ranked-stat">
                <div class="ranked-stat-label">Round</div>
                <div class="ranked-stat-value" id="ranked-round">1</div>
            </div>
            <div class="ranked-stat">
                <div class="ranked-stat-label">Timer</div>
                <div class="ranked-stat-value" id="ranked-timer">0:00</div>
            </div>
            <div class="ranked-stat">
                <div class="ranked-stat-label">AI Difficulty</div>
                <div class="ranked-stat-value" id="ranked-difficulty">-</div>
            </div>
        </div>
        <div class="turn-display" id="turn-display" style="color: rgb(255, 0, 68); animation: 0.5s ease-in-out 0s infinite normal none running checkPulse;">⬛ Black's Turn ⚠️ CHECK!</div>
        <div class="score-display">
            <div class="score-section">
                <div class="score-label">White Score</div>
                <div class="score-value" id="white-score">39</div>
            </div>
            <div class="score-section">
                <div class="score-label">Black Score</div>
                <div class="score-value" id="black-score">38</div>
            </div>
        </div>

        <div class="game-layout">
            <div class="piece-reference-guide">
                <h3>SPECIAL ABILITIES<br><small style="font-size:0.7em; opacity:0.8;">double click to use</small></h3>
                <div class="piece-reference-grid" id="piece-reference-grid"><div class="piece-ref-item" data-type="k">
                    <div class="piece-ref-icon">♔</div>
                    <div class="piece-ref-name">King</div>
                    <div class="piece-ref-hp">❤️ 250 HP</div>
                    <div class="piece-ref-ability">
                        <div class="piece-ref-ability-name">⚡ Counter-Strike</div>
                        <div class="piece-ref-ability-desc">Gain shield + deal 100 damage to all pieces attacking the King</div>
                    </div>
                </div><div class="piece-ref-item" data-type="q">
                    <div class="piece-ref-icon">♕</div>
                    <div class="piece-ref-name">Queen</div>
                    <div class="piece-ref-hp">❤️ 120 HP</div>
                    <div class="piece-ref-ability">
                        <div class="piece-ref-ability-name">⚡ Heal</div>
                        <div class="piece-ref-ability-desc">Restore 50 HP to a friendly piece</div>
                    </div>
                </div><div class="piece-ref-item" data-type="r">
                    <div class="piece-ref-icon">♖</div>
                    <div class="piece-ref-name">Rook</div>
                    <div class="piece-ref-hp">❤️ 75 HP</div>
                    <div class="piece-ref-ability">
                        <div class="piece-ref-ability-name">⚡ Cannon</div>
                        <div class="piece-ref-ability-desc">Fire a cannonball dealing 35 damage</div>
                    </div>
                </div><div class="piece-ref-item" data-type="b">
                    <div class="piece-ref-icon">♗</div>
                    <div class="piece-ref-name">Bishop</div>
                    <div class="piece-ref-hp">❤️ 75 HP</div>
                    <div class="piece-ref-ability">
                        <div class="piece-ref-ability-name">⚡ Swap</div>
                        <div class="piece-ref-ability-desc">Teleport-swap with an enemy, both take 15 damage</div>
                    </div>
                </div><div class="piece-ref-item" data-type="n">
                    <div class="piece-ref-icon">♘</div>
                    <div class="piece-ref-name">Knight</div>
                    <div class="piece-ref-hp">❤️ 75 HP</div>
                    <div class="piece-ref-ability">
                        <div class="piece-ref-ability-name">⚡ Slam</div>
                        <div class="piece-ref-ability-desc">Jump to a square and deal 30 damage in 3x3 area</div>
                    </div>
                </div><div class="piece-ref-item" data-type="p">
                    <div class="piece-ref-icon">♙</div>
                    <div class="piece-ref-name">Pawn</div>
                    <div class="piece-ref-hp">❤️ 30 HP</div>
                    <div class="piece-ref-ability">
                        <div class="piece-ref-ability-name">⚡ Shoot</div>
                        <div class="piece-ref-ability-desc">Fire a bullet at the first enemy ahead for 20 damage</div>
                    </div>
                </div></div>
            </div>
            <div class="board-container">
                <div id="board" class="board"><div class="square light" data-row="0" data-col="0">
                            <span class="piece " data-tooltip="Rook: 75/75 HP">
                                ♜
                            </span>
                            
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="0" data-col="1">
                            <span class="piece " data-tooltip="Knight: 75/75 HP">
                                ♞
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="0" data-col="2">
                            <span class="piece " data-tooltip="Bishop: 75/75 HP">
                                ♝
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="0" data-col="3">
                            <span class="piece " data-tooltip="Queen: 120/120 HP">
                                ♛
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light in-check" data-row="0" data-col="4">
                            <span class="piece " data-tooltip="King: 250/250 HP +50 Shield">
                                ♚
                            </span>
                            
                            
                            <div class="shield-indicator">🛡️50</div>
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                <div class="shield-bar" style="width: 20%"></div>
                            </div>
                        </div><div class="square dark" data-row="0" data-col="5">
                            <span class="piece " data-tooltip="Bishop: 75/75 HP">
                                ♝
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="0" data-col="6">
                            <span class="piece " data-tooltip="Knight: 75/75 HP">
                                ♞
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="0" data-col="7">
                            <span class="piece " data-tooltip="Rook: 75/75 HP">
                                ♜
                            </span>
                            
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="1" data-col="0">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                ♟
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="1" data-col="1">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                ♟
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="1" data-col="2">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                ♟
                            </span>
                            
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="1" data-col="3">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                ♟
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="1" data-col="4">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                ♟
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="1" data-col="5">
                            <span class="piece " data-tooltip="Queen: 20/120 HP">
                                ♕
                            </span>
                            
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 16.666666666666664%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="1" data-col="6">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                ♟
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="1" data-col="7">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                ♟
                            </span>
                            
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="2" data-col="0"></div><div class="square dark" data-row="2" data-col="1"></div><div class="square light" data-row="2" data-col="2"></div><div class="square dark" data-row="2" data-col="3"></div><div class="square light" data-row="2" data-col="4"></div><div class="square dark" data-row="2" data-col="5"></div><div class="square light" data-row="2" data-col="6"></div><div class="square dark" data-row="2" data-col="7"></div><div class="square dark" data-row="3" data-col="0"></div><div class="square light" data-row="3" data-col="1"></div><div class="square dark" data-row="3" data-col="2"></div><div class="square light" data-row="3" data-col="3"></div><div class="square dark" data-row="3" data-col="4"></div><div class="square light" data-row="3" data-col="5"></div><div class="square dark" data-row="3" data-col="6"></div><div class="square light" data-row="3" data-col="7"></div><div class="square light" data-row="4" data-col="0"></div><div class="square dark" data-row="4" data-col="1"></div><div class="square light" data-row="4" data-col="2">
                            <span class="piece " data-tooltip="Bishop: 55/75 HP">
                                ♗
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 73.33333333333333%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="4" data-col="3"></div><div class="square light" data-row="4" data-col="4">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                ♙
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="4" data-col="5"></div><div class="square light" data-row="4" data-col="6"></div><div class="square dark" data-row="4" data-col="7"></div><div class="square dark" data-row="5" data-col="0"></div><div class="square light" data-row="5" data-col="1"></div><div class="square dark" data-row="5" data-col="2"></div><div class="square light" data-row="5" data-col="3"></div><div class="square dark" data-row="5" data-col="4"></div><div class="square light" data-row="5" data-col="5"></div><div class="square dark" data-row="5" data-col="6"></div><div class="square light" data-row="5" data-col="7"></div><div class="square light" data-row="6" data-col="0">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                ♙
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="6" data-col="1">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                ♙
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="6" data-col="2">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                ♙
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="6" data-col="3">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                ♙
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="6" data-col="4"></div><div class="square dark" data-row="6" data-col="5">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                ♙
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="6" data-col="6">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                ♙
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="6" data-col="7">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                ♙
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="7" data-col="0">
                            <span class="piece " data-tooltip="Rook: 40/75 HP">
                                ♖
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 53.333333333333336%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="7" data-col="1">
                            <span class="piece " data-tooltip="Knight: 75/75 HP">
                                ♘
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="7" data-col="2">
                            <span class="piece " data-tooltip="Bishop: 75/75 HP">
                                ♗
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="7" data-col="3"></div><div class="square dark" data-row="7" data-col="4">
                            <span class="piece " data-tooltip="King: 250/250 HP">
                                ♔
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="7" data-col="5"></div><div class="square dark" data-row="7" data-col="6">
                            <span class="piece " data-tooltip="Knight: 75/75 HP">
                                ♘
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="7" data-col="7">
                            <span class="piece " data-tooltip="Rook: 40/75 HP">
                                ♖
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 53.333333333333336%"></div>
                                
                            </div>
                        </div></div>
            </div>
        </div>

        <div class="controls">
            <button class="reset-btn" onclick="resetGame()">Reset Game</button>
            <button class="new-game-btn" onclick="newGame()">New Game</button>
        </div>
    </div>

    <div class="game-message" id="game-message">
        <h2 id="message-title">WHITE WINS! 🏆</h2>
        <p id="message-text">Game Over!</p>
        <button class="reset-btn" id="play-again-btn" onclick="hideMessage(); resetGame()" style="display: block;">Play Again</button>
    </div>

    <div class="promotion-overlay hidden" id="promotion-overlay">
        <div class="promotion-dialog">
            <h2>PROMOTE YOUR PAWN</h2>
            <div class="promotion-choices" id="promotion-choices"></div>
        </div>
    </div>

    <div class="ranked-results-overlay hidden" id="ranked-results-overlay">
        <div class="ranked-results-dialog" id="ranked-results-dialog">
            <h2 id="ranked-result-title">VICTORY!</h2>
            <div id="ranked-result-content"></div>
            <div class="ranked-results-buttons">
                <button class="next-round-btn" id="next-round-btn" onclick="nextRankedRound()">Next Round</button>
                <button class="back-menu-btn" onclick="newGame()">Back to Menu</button>
            </div>
        </div>
    </div>

    <!-- TUTORIAL OVERLAY -->
    <div class="tutorial-overlay hidden" id="tutorial-overlay">
        <div class="tutorial-box">
            <button class="tutorial-btn-skip" onclick="closeTutorial()">Skip Tutorial ✕</button>
            <div class="tutorial-step-counter" id="tutorial-step-counter">STEP 1 OF 8</div>
            <div class="tutorial-progress" id="tutorial-progress"></div>
            <h2 class="tutorial-title" id="tutorial-title">Welcome</h2>
            <div class="tutorial-content" id="tutorial-content"></div>
            <div class="tutorial-buttons">
                <button class="tutorial-btn tutorial-btn-back" id="tutorial-back" onclick="tutorialPrev()" disabled="">Back</button>
                <button class="tutorial-btn tutorial-btn-next" id="tutorial-next" onclick="tutorialNext()">Next</button>
            </div>
        </div>
    </div>

    <!-- ONLINE LOBBY OVERLAY -->
    <div class="online-lobby-overlay hidden" id="online-lobby-overlay">
        <div class="online-lobby">
            <h2>🌐 ONLINE MULTIPLAYER</h2>
            <div class="lobby-status connecting" id="lobby-conn-status">⏳ Connecting...</div>

            <div id="lobby-menu">
                <p style="color:#aaa; margin-bottom:20px;">Play Chess Warfare against a friend online!</p>
                <div>
                    <button class="lobby-btn lobby-btn-create" id="lobby-create-btn" onclick="onlineCreateRoom()" disabled="">Create Room</button>
                </div>
                <div style="margin-top:15px;">
                    <input type="text" id="lobby-code-input" placeholder="CODE" maxlength="4" disabled="">
                    <button class="lobby-btn lobby-btn-join" id="lobby-join-btn" onclick="onlineJoinRoom()" disabled="">Join</button>
                </div>
                <button class="lobby-btn lobby-btn-back" onclick="onlineLeaveLobby()">Back to Menu</button>
            </div>

            <div id="lobby-waiting" style="display:none;">
                <p style="color:#aaa;">Share this code with your friend:</p>
                <div class="lobby-room-code" id="lobby-display-code"></div>
                <p class="lobby-waiting">Waiting for opponent...</p>
                <button class="lobby-btn lobby-btn-back" onclick="onlineLeaveLobby()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="mode-selector" id="mode-selector">
        <div class="mode-content">
            <h2>SELECT GAME MODE</h2>
            <div class="mode-buttons">
                <button id="pvp-btn" class="mode-button" onclick="selectOpponent(&#39;pvp&#39;)">👥 Player vs Player</button>
                <button id="online-btn" class="mode-button" onclick="selectOpponent(&#39;online&#39;)">🌐 Online PvP</button>
                <button id="pvc-btn" class="mode-button selected" onclick="selectOpponent(&#39;pvc&#39;)">🤖 Player vs Computer</button>
                <button id="ranked-btn" class="mode-button" onclick="selectOpponent(&#39;ranked&#39;)">⚔️ Ranked Mode</button>
            </div>

            <div id="ai-difficulty-section" style="display: block;">
                <div class="difficulty-label">AI Difficulty Level</div>
                <div class="difficulty-container">
                    <input type="range" id="difficulty-slider" min="1" max="100" value="50" oninput="updateDifficultyDisplay()">
                    <div id="difficulty-value">40</div>
                </div>
                <div class="difficulty-labels">
                    <span>Easy (Random)</span>
                    <span>Hard (Optimal)</span>
                </div>
            </div>

            <div id="online-info-section" style="display: none;">
                <div class="difficulty-label">Online PvP</div>
                <p style="color:#ccc; font-size:0.9em; margin:10px 0;">Create or join a room to play against a friend on a different device. You'll get a 4-letter code to share.</p>
                <p style="color:#ffd700; font-size:0.85em;">Player 1 (room creator) = White<br>Player 2 (joins room) = Black</p>
            </div>

            <div id="ranked-info-section" style="display: none;">
                <div class="difficulty-label">Ranked Tier System</div>
                <div class="ranked-info-grid" id="ranked-info-grid"><div class="rank-tier-item" style="border-color: rgb(205, 127, 50);">
                    <div class="rank-tier-icon rank-badge-mini"><svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" style="--rank-glow:#cd7f32">
                <defs>
                    <lineargradient id="rg_cd7f32" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#cd7f32"></stop>
                        <stop offset="100%" style="stop-color:#8b5a2b"></stop>
                    </lineargradient>
                    <filter id="rf_cd7f32"><fegaussianblur stdDeviation="2" result="blur"></fegaussianblur>
                        <femerge><femergenode in="blur"></femergenode><femergenode in="SourceGraphic"></femergenode></femerge>
                    </filter>
                </defs>
                <polygon points="50,5 61,35 95,35 68,55 78,90 50,70 22,90 32,55 5,35 39,35" fill="url(#rg_cd7f32)" stroke="#cd7f32" stroke-width="2" filter="url(#rf_cd7f32)" opacity="0.95"></polygon>
                <text x="50" y="58" text-anchor="middle" font-size="28" font-weight="bold" fill="#fff" stroke="#000" stroke-width="1" font-family="Arial">B</text>
            </svg></div>
                    <div class="rank-tier-name" style="color:#cd7f32">Bronze</div>
                    <div class="rank-tier-rp">0 RP</div>
                </div><div class="rank-tier-item" style="border-color: rgb(192, 192, 192);">
                    <div class="rank-tier-icon rank-badge-mini"><svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" style="--rank-glow:#e0e0e0">
                <defs>
                    <lineargradient id="rg_c0c0c0" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#c0c0c0"></stop>
                        <stop offset="100%" style="stop-color:#808080"></stop>
                    </lineargradient>
                    <filter id="rf_c0c0c0"><fegaussianblur stdDeviation="2" result="blur"></fegaussianblur>
                        <femerge><femergenode in="blur"></femergenode><femergenode in="SourceGraphic"></femergenode></femerge>
                    </filter>
                </defs>
                <polygon points="50,5 61,35 95,35 68,55 78,90 50,70 22,90 32,55 5,35 39,35" fill="url(#rg_c0c0c0)" stroke="#e0e0e0" stroke-width="2" filter="url(#rf_c0c0c0)" opacity="0.95"></polygon>
                <text x="50" y="58" text-anchor="middle" font-size="28" font-weight="bold" fill="#fff" stroke="#000" stroke-width="1" font-family="Arial">S</text>
            </svg></div>
                    <div class="rank-tier-name" style="color:#c0c0c0">Silver</div>
                    <div class="rank-tier-rp">100 RP</div>
                </div><div class="rank-tier-item" style="border-color: rgb(255, 215, 0);">
                    <div class="rank-tier-icon rank-badge-mini"><svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" style="--rank-glow:#ffd700">
                <defs>
                    <lineargradient id="rg_ffd700" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#ffd700"></stop>
                        <stop offset="100%" style="stop-color:#daa520"></stop>
                    </lineargradient>
                    <filter id="rf_ffd700"><fegaussianblur stdDeviation="2" result="blur"></fegaussianblur>
                        <femerge><femergenode in="blur"></femergenode><femergenode in="SourceGraphic"></femergenode></femerge>
                    </filter>
                </defs>
                <polygon points="50,5 61,35 95,35 68,55 78,90 50,70 22,90 32,55 5,35 39,35" fill="url(#rg_ffd700)" stroke="#ffd700" stroke-width="2" filter="url(#rf_ffd700)" opacity="0.95"></polygon>
                <text x="50" y="58" text-anchor="middle" font-size="28" font-weight="bold" fill="#fff" stroke="#000" stroke-width="1" font-family="Arial">G</text>
            </svg></div>
                    <div class="rank-tier-name" style="color:#ffd700">Gold</div>
                    <div class="rank-tier-rp">250 RP</div>
                </div><div class="rank-tier-item" style="border-color: rgb(229, 228, 226);">
                    <div class="rank-tier-icon rank-badge-mini"><svg viewBox="0 0 100 120" xmlns="http://www.w3.org/2000/svg" style="--rank-glow:#e5e4e2">
                <defs>
                    <lineargradient id="sg_b0e0e6" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#b0e0e6"></stop>
                        <stop offset="100%" style="stop-color:#5f9ea0"></stop>
                    </lineargradient>
                    <filter id="sf_b0e0e6"><fegaussianblur stdDeviation="2.5" result="blur"></fegaussianblur>
                        <femerge><femergenode in="blur"></femergenode><femergenode in="SourceGraphic"></femergenode></femerge>
                    </filter>
                </defs>
                <path d="M50,5 L90,25 L85,75 L50,110 L15,75 L10,25 Z" fill="url(#sg_b0e0e6)" stroke="#e5e4e2" stroke-width="3" filter="url(#sf_b0e0e6)" opacity="0.95"></path>
                <path d="M50,15 L80,30 L76,70 L50,100 L24,70 L20,30 Z" fill="none" stroke="rgba(255,255,255,0.3)" stroke-width="1.5"></path>
                <text x="50" y="68" text-anchor="middle" font-size="32" font-weight="bold" fill="#fff" stroke="#000" stroke-width="1" font-family="Arial">P</text>
            </svg></div>
                    <div class="rank-tier-name" style="color:#e5e4e2">Platinum</div>
                    <div class="rank-tier-rp">450 RP</div>
                </div><div class="rank-tier-item" style="border-color: rgb(80, 200, 120);">
                    <div class="rank-tier-icon rank-badge-mini"><svg viewBox="0 0 100 120" xmlns="http://www.w3.org/2000/svg" style="--rank-glow:#00ff88">
                <defs>
                    <lineargradient id="sg_50c878" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#50c878"></stop>
                        <stop offset="100%" style="stop-color:#2e8b57"></stop>
                    </lineargradient>
                    <filter id="sf_50c878"><fegaussianblur stdDeviation="2.5" result="blur"></fegaussianblur>
                        <femerge><femergenode in="blur"></femergenode><femergenode in="SourceGraphic"></femergenode></femerge>
                    </filter>
                </defs>
                <path d="M50,5 L90,25 L85,75 L50,110 L15,75 L10,25 Z" fill="url(#sg_50c878)" stroke="#00ff88" stroke-width="3" filter="url(#sf_50c878)" opacity="0.95"></path>
                <path d="M50,15 L80,30 L76,70 L50,100 L24,70 L20,30 Z" fill="none" stroke="rgba(255,255,255,0.3)" stroke-width="1.5"></path>
                <text x="50" y="68" text-anchor="middle" font-size="32" font-weight="bold" fill="#fff" stroke="#000" stroke-width="1" font-family="Arial">E</text>
            </svg></div>
                    <div class="rank-tier-name" style="color:#50c878">Emerald</div>
                    <div class="rank-tier-rp">700 RP</div>
                </div><div class="rank-tier-item" style="border-color: rgb(255, 107, 53);">
                    <div class="rank-tier-icon rank-badge-mini"><svg viewBox="0 0 100 120" xmlns="http://www.w3.org/2000/svg" style="--rank-glow:#ff8c00">
                <defs>
                    <lineargradient id="sg_ff6b35" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#ff6b35"></stop>
                        <stop offset="100%" style="stop-color:#cc3300"></stop>
                    </lineargradient>
                    <filter id="sf_ff6b35"><fegaussianblur stdDeviation="2.5" result="blur"></fegaussianblur>
                        <femerge><femergenode in="blur"></femergenode><femergenode in="SourceGraphic"></femergenode></femerge>
                    </filter>
                </defs>
                <path d="M50,5 L90,25 L85,75 L50,110 L15,75 L10,25 Z" fill="url(#sg_ff6b35)" stroke="#ff8c00" stroke-width="3" filter="url(#sf_ff6b35)" opacity="0.95"></path>
                <path d="M50,15 L80,30 L76,70 L50,100 L24,70 L20,30 Z" fill="none" stroke="rgba(255,255,255,0.3)" stroke-width="1.5"></path>
                <text x="50" y="68" text-anchor="middle" font-size="32" font-weight="bold" fill="#fff" stroke="#000" stroke-width="1" font-family="Arial">C</text>
            </svg></div>
                    <div class="rank-tier-name" style="color:#ff6b35">Champion</div>
                    <div class="rank-tier-rp">1000 RP</div>
                </div><div class="rank-tier-item" style="border-color: rgb(155, 89, 182);">
                    <div class="rank-tier-icon rank-badge-mini"><svg viewBox="0 0 120 100" xmlns="http://www.w3.org/2000/svg" style="--rank-glow:#da70d6">
                <defs>
                    <lineargradient id="cg_9b59b6" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#9b59b6"></stop>
                        <stop offset="100%" style="stop-color:#6a1b9a"></stop>
                    </lineargradient>
                    <filter id="cf_9b59b6"><fegaussianblur stdDeviation="3" result="blur"></fegaussianblur>
                        <femerge><femergenode in="blur"></femergenode><femergenode in="SourceGraphic"></femergenode></femerge>
                    </filter>
                </defs>
                <path d="M10,75 L5,30 L30,50 L60,10 L90,50 L115,30 L110,75 Z" fill="url(#cg_9b59b6)" stroke="#da70d6" stroke-width="3" filter="url(#cf_9b59b6)" opacity="0.95"></path>
                <rect x="10" y="75" width="100" height="15" rx="5" fill="url(#cg_9b59b6)" stroke="#da70d6" stroke-width="2"></rect>
                <circle cx="30" cy="30" r="5" fill="#da70d6" opacity="0.8"></circle>
                <circle cx="60" cy="12" r="6" fill="#da70d6" opacity="0.9"></circle>
                <circle cx="90" cy="30" r="5" fill="#da70d6" opacity="0.8"></circle>
                <text x="60" y="68" text-anchor="middle" font-size="22" font-weight="bold" fill="#fff" stroke="#000" stroke-width="1" font-family="Arial">U</text>
            </svg></div>
                    <div class="rank-tier-name" style="color:#9b59b6">Ultimate Champion</div>
                    <div class="rank-tier-rp">1350 RP</div>
                </div><div class="rank-tier-item" style="border-color: rgb(220, 20, 60);">
                    <div class="rank-tier-icon rank-badge-mini"><svg viewBox="0 0 120 100" xmlns="http://www.w3.org/2000/svg" style="--rank-glow:#ff4444">
                <defs>
                    <lineargradient id="cg_dc143c" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#dc143c"></stop>
                        <stop offset="100%" style="stop-color:#8b0000"></stop>
                    </lineargradient>
                    <filter id="cf_dc143c"><fegaussianblur stdDeviation="3" result="blur"></fegaussianblur>
                        <femerge><femergenode in="blur"></femergenode><femergenode in="SourceGraphic"></femergenode></femerge>
                    </filter>
                </defs>
                <path d="M10,75 L5,30 L30,50 L60,10 L90,50 L115,30 L110,75 Z" fill="url(#cg_dc143c)" stroke="#ff4444" stroke-width="3" filter="url(#cf_dc143c)" opacity="0.95"></path>
                <rect x="10" y="75" width="100" height="15" rx="5" fill="url(#cg_dc143c)" stroke="#ff4444" stroke-width="2"></rect>
                <circle cx="30" cy="30" r="5" fill="#ff4444" opacity="0.8"></circle>
                <circle cx="60" cy="12" r="6" fill="#ff4444" opacity="0.9"></circle>
                <circle cx="90" cy="30" r="5" fill="#ff4444" opacity="0.8"></circle>
                <text x="60" y="68" text-anchor="middle" font-size="22" font-weight="bold" fill="#fff" stroke="#000" stroke-width="1" font-family="Arial">X</text>
            </svg></div>
                    <div class="rank-tier-name" style="color:#dc143c">Crimson</div>
                    <div class="rank-tier-rp">2750 RP</div>
                </div></div>
            </div>

            <button id="start-game-btn" onclick="startSelectedGame()" style="display: block;">START GAME</button>
        </div>
    </div>

    <script>
        // ====== RANKED SYSTEM VARIABLES ======
        let rankedMode = false;
        let rankedRound = 1;
        let rankedRP = 0;
        let rankedTimer = 0;
        let rankedTimerInterval = null;
        let rankedRank = 'Bronze';

        // SVG rank badge builder
        function rankSVG(color1, color2, symbol, glow) {
            return `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" style="--rank-glow:${glow}">
                <defs>
                    <linearGradient id="rg_${color1.replace('#','')}" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:${color1}"/>
                        <stop offset="100%" style="stop-color:${color2}"/>
                    </linearGradient>
                    <filter id="rf_${color1.replace('#','')}"><feGaussianBlur stdDeviation="2" result="blur"/>
                        <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
                    </filter>
                </defs>
                <polygon points="50,5 61,35 95,35 68,55 78,90 50,70 22,90 32,55 5,35 39,35"
                    fill="url(#rg_${color1.replace('#','')})" stroke="${glow}" stroke-width="2"
                    filter="url(#rf_${color1.replace('#','')})" opacity="0.95"/>
                <text x="50" y="58" text-anchor="middle" font-size="28" font-weight="bold"
                    fill="#fff" stroke="#000" stroke-width="1" font-family="Arial">${symbol}</text>
            </svg>`;
        }

        function shieldSVG(color1, color2, symbol, glow) {
            return `<svg viewBox="0 0 100 120" xmlns="http://www.w3.org/2000/svg" style="--rank-glow:${glow}">
                <defs>
                    <linearGradient id="sg_${color1.replace('#','')}" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:${color1}"/>
                        <stop offset="100%" style="stop-color:${color2}"/>
                    </linearGradient>
                    <filter id="sf_${color1.replace('#','')}"><feGaussianBlur stdDeviation="2.5" result="blur"/>
                        <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
                    </filter>
                </defs>
                <path d="M50,5 L90,25 L85,75 L50,110 L15,75 L10,25 Z"
                    fill="url(#sg_${color1.replace('#','')})" stroke="${glow}" stroke-width="3"
                    filter="url(#sf_${color1.replace('#','')})" opacity="0.95"/>
                <path d="M50,15 L80,30 L76,70 L50,100 L24,70 L20,30 Z"
                    fill="none" stroke="rgba(255,255,255,0.3)" stroke-width="1.5"/>
                <text x="50" y="68" text-anchor="middle" font-size="32" font-weight="bold"
                    fill="#fff" stroke="#000" stroke-width="1" font-family="Arial">${symbol}</text>
            </svg>`;
        }

        function crownSVG(color1, color2, symbol, glow) {
            return `<svg viewBox="0 0 120 100" xmlns="http://www.w3.org/2000/svg" style="--rank-glow:${glow}">
                <defs>
                    <linearGradient id="cg_${color1.replace('#','')}" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:${color1}"/>
                        <stop offset="100%" style="stop-color:${color2}"/>
                    </linearGradient>
                    <filter id="cf_${color1.replace('#','')}"><feGaussianBlur stdDeviation="3" result="blur"/>
                        <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
                    </filter>
                </defs>
                <path d="M10,75 L5,30 L30,50 L60,10 L90,50 L115,30 L110,75 Z"
                    fill="url(#cg_${color1.replace('#','')})" stroke="${glow}" stroke-width="3"
                    filter="url(#cf_${color1.replace('#','')})" opacity="0.95"/>
                <rect x="10" y="75" width="100" height="15" rx="5"
                    fill="url(#cg_${color1.replace('#','')})" stroke="${glow}" stroke-width="2"/>
                <circle cx="30" cy="30" r="5" fill="${glow}" opacity="0.8"/>
                <circle cx="60" cy="12" r="6" fill="${glow}" opacity="0.9"/>
                <circle cx="90" cy="30" r="5" fill="${glow}" opacity="0.8"/>
                <text x="60" y="68" text-anchor="middle" font-size="22" font-weight="bold"
                    fill="#fff" stroke="#000" stroke-width="1" font-family="Arial">${symbol}</text>
            </svg>`;
        }

        const RANK_TIERS = [
            { name: 'Bronze',    minRP: 0,    color: '#cd7f32', icon: () => rankSVG('#cd7f32','#8b5a2b','B','#cd7f32') },
            { name: 'Silver',    minRP: 100,  color: '#c0c0c0', icon: () => rankSVG('#c0c0c0','#808080','S','#e0e0e0') },
            { name: 'Gold',      minRP: 250,  color: '#ffd700', icon: () => rankSVG('#ffd700','#daa520','G','#ffd700') },
            { name: 'Platinum',  minRP: 450,  color: '#e5e4e2', icon: () => shieldSVG('#b0e0e6','#5f9ea0','P','#e5e4e2') },
            { name: 'Emerald',   minRP: 700,  color: '#50c878', icon: () => shieldSVG('#50c878','#2e8b57','E','#00ff88') },
            { name: 'Champion',  minRP: 1000, color: '#ff6b35', icon: () => shieldSVG('#ff6b35','#cc3300','C','#ff8c00') },
            { name: 'Ultimate Champion', minRP: 1350, color: '#9b59b6', icon: () => crownSVG('#9b59b6','#6a1b9a','U','#da70d6') },
            { name: 'Crimson',   minRP: 2750, color: '#dc143c', icon: () => crownSVG('#dc143c','#8b0000','X','#ff4444') }
        ];

        // Piece definitions
        const pieces = {
            white: {
                king: '♔', queen: '♕', rook: '♖',
                bishop: '♗', knight: '♘', pawn: '♙',
                wizard: '🧙', grandpa: '👴', lizard: '🦎', tank: '🛡️',
                assassin: '🗡️', dragon: '🐉', ghost: '👻'
            },
            black: {
                king: '♚', queen: '♛', rook: '♜',
                bishop: '♝', knight: '♞', pawn: '♟',
                wizard: '🧙', grandpa: '👴', lizard: '🦎', tank: '🛡️',
                assassin: '🗡️', dragon: '🐉', ghost: '👻'
            }
        };

        const pieceEmojis = {
            w: { white: '🧙', black: '🧙' },
            g: { white: '👴', black: '👴' },
            l: { white: '🦎', black: '🦎' },
            t: { white: '🛡️', black: '🛡️' },
            s: { white: '🗡️', black: '🗡️' },
            d: { white: '🐉', black: '🐉' },
            h: { white: '👻', black: '👻' },
            x: { white: '🕵️', black: '🕵️' }
        };

        let board = [];
        let selectedSquare = null;
        let currentTurn = 'white';
        let gameActive = false;
        let activeAbility = null;
        let pieceIdCounter = 0;
        let landmines = [];

        let gameMode = 'pvp';
        let aiDifficulty = 50;
        let isAIThinking = false;

        // ====== ONLINE MULTIPLAYER ======
        let ws = null;
        let myColor = null;        // 'white' or 'black'
        let myPlayerNumber = null;  // 1 or 2
        let onlineConnected = false;
        let isRemoteAction = false; // prevents sending back received moves

        function onlineConnect() {
            if (location.protocol === 'file:') return;
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            try {
                ws = new WebSocket(`${protocol}//${location.host}`);
            } catch(e) { return; }

            ws.onopen = () => {
                onlineConnected = true;
                updateLobbyStatus('connected', 'Connected');
                setLobbyButtonsEnabled(true);
            };

            ws.onmessage = (event) => {
                let msg;
                try { msg = JSON.parse(event.data); } catch { return; }

                switch(msg.type) {
                    case 'room_created':
                        myPlayerNumber = 1;
                        myColor = 'white';
                        document.getElementById('lobby-display-code').textContent = msg.roomCode;
                        document.getElementById('lobby-menu').style.display = 'none';
                        document.getElementById('lobby-waiting').style.display = 'block';
                        break;

                    case 'room_joined':
                        myPlayerNumber = 2;
                        myColor = 'black';
                        break;

                    case 'game_start':
                        document.getElementById('online-lobby-overlay').classList.add('hidden');
                        startOnlineGame();
                        break;

                    case 'game_move':
                        handleRemoteAction(msg.move);
                        break;

                    case 'player_disconnected':
                        if (gameActive && gameMode === 'online') {
                            showMessage('OPPONENT DISCONNECTED', 'Your opponent left the game.', true);
                            gameActive = false;
                        }
                        break;

                    case 'error':
                        alert(msg.message);
                        break;
                }
            };

            ws.onerror = () => {
                updateLobbyStatus('disconnected', 'Connection error');
            };

            ws.onclose = () => {
                onlineConnected = false;
                setLobbyButtonsEnabled(false);
                updateLobbyStatus('disconnected', 'Disconnected');
                // Auto-reconnect
                setTimeout(() => { if (!onlineConnected) onlineConnect(); }, 3000);
            };
        }

        function updateLobbyStatus(state, text) {
            const el = document.getElementById('lobby-conn-status');
            if (!el) return;
            el.className = 'lobby-status ' + state;
            const icons = {connecting:'⏳', connected:'✅', disconnected:'❌'};
            el.textContent = (icons[state]||'') + ' ' + text;
        }

        function setLobbyButtonsEnabled(enabled) {
            const ids = ['lobby-create-btn','lobby-join-btn','lobby-code-input'];
            ids.forEach(id => { const el = document.getElementById(id); if(el) el.disabled = !enabled; });
        }

        function onlineCreateRoom() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            ws.send(JSON.stringify({ type: 'create_room' }));
        }

        function onlineJoinRoom() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            const code = document.getElementById('lobby-code-input').value.trim();
            if (code.length !== 4) { alert('Enter a 4-letter room code'); return; }
            ws.send(JSON.stringify({ type: 'join_room', roomCode: code }));
        }

        function onlineLeaveLobby() {
            document.getElementById('online-lobby-overlay').classList.add('hidden');
            document.getElementById('lobby-menu').style.display = 'block';
            document.getElementById('lobby-waiting').style.display = 'none';
            if (ws) ws.close();
            ws = null;
            onlineConnected = false;
            newGame();
        }

        function startOnlineGame() {
            document.getElementById('mode-selector').classList.add('hidden');
            document.getElementById('battle-title').textContent = 
                'CHESS WARFARE — ONLINE (' + (myColor === 'white' ? '⬜ White' : '⬛ Black') + ')';
            rankedMode = false;
            document.getElementById('ranked-hud').classList.remove('active');
            initStandardBoard();
            initPieceReferenceGuide();
            gameActive = true;
            renderBoard();
        }

        function sendOnlineAction(actionData) {
            if (gameMode !== 'online' || isRemoteAction || !ws || ws.readyState !== WebSocket.OPEN) return;
            ws.send(JSON.stringify({ type: 'game_move', move: actionData }));
        }

        function handleRemoteAction(data) {
            if (!data) return;
            isRemoteAction = true;
            if (data.action === 'move') {
                makeMove(data.fromRow, data.fromCol, data.toRow, data.toCol);
                clearSelection();
            } else if (data.action === 'ability') {
                useAbility(data.fromRow, data.fromCol, data.toRow, data.toCol, data.abilityType);
                clearSelection();
            } else if (data.action === 'promote') {
                document.getElementById('promotion-overlay').classList.add('hidden');
                promotePawn(data.row, data.col, data.newType);
                switchTurn();
                applyPoisonDamage();
                renderBoard();
                checkGameEnd();
            }
            isRemoteAction = false;
        }

        function isMyTurnOnline() {
            if (gameMode !== 'online') return true;
            return currentTurn === myColor;
        }

        const pieceInfo = {
            'k': { name: 'King', hp: 250, movement: 'Moves 1 square any direction', ability: 'Counter-Strike', abilityDesc: 'Gain shield + deal 100 damage to all pieces attacking the King' },
            'q': { name: 'Queen', hp: 120, movement: 'Moves any direction, any distance', ability: 'Heal', abilityDesc: 'Restore 50 HP to a friendly piece' },
            'r': { name: 'Rook', hp: 75, movement: 'Moves in straight lines (horizontal/vertical)', ability: 'Cannon', abilityDesc: 'Fire a cannonball dealing 35 damage' },
            'b': { name: 'Bishop', hp: 75, movement: 'Moves diagonally any distance', ability: 'Swap', abilityDesc: 'Teleport-swap with an enemy, both take 15 damage' },
            'n': { name: 'Knight', hp: 75, movement: 'L-shape jumps (2+1 squares)', ability: 'Slam', abilityDesc: 'Jump to a square and deal 30 damage in 3x3 area' },
            'p': { name: 'Pawn', hp: 30, movement: 'Forward 1 (or 2 from start), captures diagonally', ability: 'Shoot', abilityDesc: 'Fire a bullet at the first enemy ahead for 20 damage' },
            'w': { name: 'Wizard', hp: 90, movement: 'Moves diagonally up to 3 squares', ability: 'Restore', abilityDesc: 'Refresh a friendly piece\'s used ability' },
            'g': { name: 'Grandpa', hp: 60, movement: 'Moves 1 square any direction', ability: 'Release Lizard', abilityDesc: 'Place a Lizard ally on an adjacent empty square' },
            'l': { name: 'Lizard', hp: 200, movement: 'Moves 1 square any direction', ability: 'Attach', abilityDesc: 'Jump to an enemy within 3 squares, poisoning them + area (10 dmg/turn)' },
            't': { name: 'Tank', hp: 200, movement: 'Moves 1 square any direction', ability: 'Area Shield', abilityDesc: 'Grant +30 shield to all friendly pieces within 2 squares' },
            's': { name: 'Assassin', hp: 60, movement: 'Moves in L-shape like Knight', ability: 'Backstab', abilityDesc: 'Deal 40 damage to an enemy within 2 squares' },
            'd': { name: 'Dragon', hp: 150, movement: 'Moves any direction up to 4 squares', ability: 'Fire Breath', abilityDesc: 'Burn a 3x3 area dealing 50 damage to all' },
            'h': { name: 'Ghost', hp: 10, movement: '1 square (or copies stolen piece\'s movement)', ability: 'Steal Soul', abilityDesc: 'Copy an enemy\'s movement type and kill them (not King)' },
            'x': { name: 'Saboteur', hp: 80, movement: 'Moves 1 square any direction', ability: 'Place Landmine', abilityDesc: 'Set an explosive trap on an empty square (60 dmg)' }
        };

        function createPiece(type) {
            if (!type) return null;
            const healthMap = {
                'k': 250, 'q': 120, 'r': 75, 'b': 75, 'n': 75, 'p': 30,
                'w': 90, 'g': 60, 'l': 200, 't': 200, 's': 60, 'd': 150, 'h': 10, 'x': 80
            };
            const pieceType = type[1];
            const maxHealth = healthMap[pieceType] || 50;
            const piece = {
                type: type,
                abilityUsed: false,
                id: pieceIdCounter++,
                health: maxHealth,
                maxHealth: maxHealth
            };
            if (pieceType === 'k' || pieceType === 'r') {
                piece.hasMoved = false;
            }
            return piece;
        }

        function initStandardBoard() {
            pieceIdCounter = 0;
            landmines = [];
            board = [
                [createPiece('br'), createPiece('bn'), createPiece('bb'), createPiece('bq'), createPiece('bk'), createPiece('bb'), createPiece('bn'), createPiece('br')],
                [createPiece('bp'), createPiece('bp'), createPiece('bp'), createPiece('bp'), createPiece('bp'), createPiece('bp'), createPiece('bp'), createPiece('bp')],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [createPiece('wp'), createPiece('wp'), createPiece('wp'), createPiece('wp'), createPiece('wp'), createPiece('wp'), createPiece('wp'), createPiece('wp')],
                [createPiece('wr'), createPiece('wn'), createPiece('wb'), createPiece('wq'), createPiece('wk'), createPiece('wb'), createPiece('wn'), createPiece('wr')]
            ];
        }

        // ====== RANKED FUNCTIONS ======
        function updateRankedDisplay() {
            if (!rankedMode) return;
            document.getElementById('ranked-round').textContent = rankedRound;
            document.getElementById('ranked-rp').textContent = rankedRP;
            document.getElementById('ranked-timer').textContent = formatTime(rankedTimer);
            document.getElementById('ranked-difficulty').textContent = aiDifficulty;
            updateRankedRank();
            updateRPBar();
        }

        function updateRankedRank() {
            for (let i = RANK_TIERS.length - 1; i >= 0; i--) {
                if (rankedRP >= RANK_TIERS[i].minRP) {
                    rankedRank = RANK_TIERS[i].name;
                    document.getElementById('ranked-rank-name').textContent = rankedRank;
                    document.getElementById('ranked-rank-badge').innerHTML = RANK_TIERS[i].icon();
                    document.getElementById('ranked-rank-name').style.color = RANK_TIERS[i].color;
                    break;
                }
            }
        }

        function updateRPBar() {
            const currentTierIndex = RANK_TIERS.findIndex(t => t.name === rankedRank);
            if (currentTierIndex === -1) return;
            
            const currentMinRP = RANK_TIERS[currentTierIndex].minRP;
            const nextMinRP = currentTierIndex < RANK_TIERS.length - 1 ? RANK_TIERS[currentTierIndex + 1].minRP : currentMinRP + 500;
            
            const rpInTier = rankedRP - currentMinRP;
            const rpToNext = nextMinRP - currentMinRP;
            const percentage = Math.min((rpInTier / rpToNext) * 100, 100);
            
            document.getElementById('ranked-rp-bar').style.width = percentage + '%';
        }

        function startRankedTimer() {
            rankedTimer = 0;
            if (rankedTimerInterval) clearInterval(rankedTimerInterval);
            rankedTimerInterval = setInterval(() => {
                rankedTimer++;
                updateRankedDisplay();
            }, 1000);
        }

        function stopRankedTimer() {
            if (rankedTimerInterval) {
                clearInterval(rankedTimerInterval);
                rankedTimerInterval = null;
            }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function calculateRankedRP(playerWon) {
            if (!playerWon) return -15;

            // Base: 30 RP for a win
            // Bonus up to +5 based on performance (speed + pieces remaining)
            let performanceBonus = 0;

            // Speed bonus: faster wins get up to +3
            if (rankedTimer < 120) performanceBonus += 3;       // Under 2 min
            else if (rankedTimer < 240) performanceBonus += 2;  // Under 4 min
            else if (rankedTimer < 420) performanceBonus += 1;  // Under 7 min

            // Material bonus: more pieces alive = up to +2
            let whitePieces = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = board[r][c];
                    if (p && p.type[0] === 'w') whitePieces++;
                }
            }
            if (whitePieces >= 12) performanceBonus += 2;       // Dominant win
            else if (whitePieces >= 8) performanceBonus += 1;   // Clean win

            return 30 + performanceBonus; // 30-35 RP per win
        }

        function getRankedDifficulty(round) {
            // Ranked starts HARD and scales to near-perfect
            // Round 1: 60, Round 2: 70, Round 3: 78, Round 4: 84, Round 5: 89, Round 6+: 92-99
            return Math.min(99, 50 + Math.floor(round * 8) + Math.floor(Math.pow(round, 0.5) * 3));
        }

        function nextRankedRound() {
            rankedRound++;
            aiDifficulty = getRankedDifficulty(rankedRound);
            gameActive = true;
            currentTurn = 'white';
            activeAbility = null;
            selectedSquare = null;
            isAIThinking = false;
            landmines = [];
            
            initStandardBoard();
            startRankedTimer();
            updateRankedDisplay();
            renderBoard();
            
            document.getElementById('ranked-results-overlay').classList.add('hidden');
        }

        function showRankedResults(playerWon) {
            stopRankedTimer();
            const rpChange = calculateRankedRP(playerWon);
            const previousRP = rankedRP;
            rankedRP = Math.max(0, rankedRP + rpChange);
            
            const previousRank = rankedRank;
            updateRankedRank();
            const rankChanged = previousRank !== rankedRank;
            
            let title = playerWon ? '🏆 VICTORY!' : '💀 DEFEAT';
            let content = `
                <div class="ranked-result-item">
                    <span class="ranked-result-label">Time Taken:</span> ${formatTime(rankedTimer)}
                </div>
                <div class="ranked-result-item">
                    <span class="ranked-result-label">RP Change:</span>
                    <div class="rp-change ${rpChange >= 0 ? 'rp-gain' : 'rp-loss'}">
                        ${rpChange >= 0 ? '+' : ''}${rpChange} RP
                    </div>
                </div>
                <div class="ranked-result-item">
                    <span class="ranked-result-label">Total RP:</span> ${rankedRP}
                </div>
                <div class="ranked-result-item">
                    <span class="ranked-result-label">Current Rank:</span>
                    <div class="rank-badge" style="${rankChanged ? 'animation: rankUpPulse 0.6s ease-out;' : ''}">${getRankTierByName(rankedRank).icon()}</div>
                    <div>${rankedRank}</div>
                </div>
            `;
            
            if (rankChanged && playerWon) {
                content += '<div style="margin-top: 15px; font-size: 1.3em; color: #00ff00; text-shadow: 0 0 10px #00ff00; font-weight: bold;">⭐ RANK UP! ⭐</div>';
            } else if (rankChanged) {
                content += '<div style="margin-top: 15px; font-size: 1.3em; color: #ff6b6b; text-shadow: 0 0 10px #ff6b6b; font-weight: bold;">📉 RANK DOWN</div>';
            }
            
            document.getElementById('ranked-result-title').textContent = title;
            document.getElementById('ranked-result-content').innerHTML = content;
            
            if (!playerWon) {
                document.getElementById('next-round-btn').style.display = 'none';
            } else {
                document.getElementById('next-round-btn').style.display = 'block';
            }
            
            document.getElementById('ranked-results-overlay').classList.remove('hidden');
        }

        function getRankTierByName(name) {
            return RANK_TIERS.find(t => t.name === name) || RANK_TIERS[0];
        }

        // ====== MODE SELECTOR FUNCTIONS ======
        function selectOpponent(mode) {
            gameMode = mode;
            document.getElementById('pvp-btn').classList.remove('selected');
            document.getElementById('pvc-btn').classList.remove('selected');
            document.getElementById('ranked-btn').classList.remove('selected');
            document.getElementById('online-btn').classList.remove('selected');
            
            if (mode === 'pvp') {
                document.getElementById('pvp-btn').classList.add('selected');
                document.getElementById('ai-difficulty-section').style.display = 'none';
                document.getElementById('ranked-info-section').style.display = 'none';
                document.getElementById('online-info-section').style.display = 'none';
            } else if (mode === 'online') {
                document.getElementById('online-btn').classList.add('selected');
                document.getElementById('ai-difficulty-section').style.display = 'none';
                document.getElementById('ranked-info-section').style.display = 'none';
                document.getElementById('online-info-section').style.display = 'block';
            } else if (mode === 'pvc') {
                document.getElementById('pvc-btn').classList.add('selected');
                document.getElementById('ai-difficulty-section').style.display = 'block';
                document.getElementById('ranked-info-section').style.display = 'none';
                document.getElementById('online-info-section').style.display = 'none';
            } else if (mode === 'ranked') {
                document.getElementById('ranked-btn').classList.add('selected');
                document.getElementById('ai-difficulty-section').style.display = 'none';
                document.getElementById('ranked-info-section').style.display = 'block';
                document.getElementById('online-info-section').style.display = 'none';
            }
            document.getElementById('start-game-btn').style.display = 'block';
        }

        function updateDifficultyDisplay() {
            const slider = document.getElementById('difficulty-slider');
            const display = document.getElementById('difficulty-value');
            aiDifficulty = parseInt(slider.value);
            display.textContent = aiDifficulty;
        }

        function initRankedInfoDisplay() {
            const grid = document.getElementById('ranked-info-grid');
            grid.innerHTML = '';
            RANK_TIERS.forEach(tier => {
                const item = document.createElement('div');
                item.className = 'rank-tier-item';
                item.style.borderColor = tier.color;
                item.innerHTML = `
                    <div class="rank-tier-icon rank-badge-mini">${tier.icon()}</div>
                    <div class="rank-tier-name" style="color:${tier.color}">${tier.name}</div>
                    <div class="rank-tier-rp">${tier.minRP} RP</div>
                `;
                grid.appendChild(item);
            });
        }

        function startSelectedGame() {
            if (gameMode === 'online') {
                // Show the lobby and connect
                document.getElementById('mode-selector').classList.add('hidden');
                document.getElementById('online-lobby-overlay').classList.remove('hidden');
                document.getElementById('lobby-menu').style.display = 'block';
                document.getElementById('lobby-waiting').style.display = 'none';
                document.getElementById('lobby-code-input').value = '';
                onlineConnect();
                return;
            }

            document.getElementById('mode-selector').classList.add('hidden');
            document.getElementById('battle-title').textContent = 'CHESS WARFARE';
            
            if (gameMode === 'ranked') {
                rankedMode = true;
                aiDifficulty = getRankedDifficulty(1);
                gameMode = 'pvc';
                document.getElementById('ranked-hud').classList.add('active');
                startRankedTimer();
            } else {
                rankedMode = false;
                document.getElementById('ranked-hud').classList.remove('active');
            }
            
            initStandardBoard();
            initPieceReferenceGuide();
            gameActive = true;
            renderBoard();
        }

        // ====== PIECE REFERENCE GUIDE ======
        function initPieceReferenceGuide() {
            const grid = document.getElementById('piece-reference-grid');
            grid.innerHTML = '';
            const standardTypes = ['k', 'q', 'r', 'b', 'n', 'p'];
            standardTypes.forEach(type => {
                const info = pieceInfo[type];
                const nameMap = { k: 'king', q: 'queen', r: 'rook', b: 'bishop', n: 'knight', p: 'pawn' };
                const pieceSymbol = pieces.white[nameMap[type]];
                const item = document.createElement('div');
                item.className = 'piece-ref-item';
                item.setAttribute('data-type', type);
                item.innerHTML = `
                    <div class="piece-ref-icon">${pieceSymbol}</div>
                    <div class="piece-ref-name">${info.name}</div>
                    <div class="piece-ref-hp">❤️ ${info.hp} HP</div>
                    <div class="piece-ref-ability">
                        <div class="piece-ref-ability-name">⚡ ${info.ability}</div>
                        <div class="piece-ref-ability-desc">${info.abilityDesc}</div>
                    </div>
                `;
                grid.appendChild(item);
            });
        }

        function highlightPieceInGuide(piece) {
            document.querySelectorAll('.piece-ref-item').forEach(el => el.classList.remove('highlighted'));
            if (!piece) return;
            const type = piece.type[1];
            const el = document.querySelector(`.piece-ref-item[data-type="${type}"]`);
            if (el) el.classList.add('highlighted');
        }

        // ====== BOARD RENDERING ======
        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;

                    const piece = board[row][col];

                    if (piece && piece.type[1] === 'k') {
                        const kingColor = piece.type[0];
                        if (isKingInCheck(kingColor)) {
                            square.classList.add('in-check');
                        }
                    }
                    if (piece) {
                        const color = piece.type[0] === 'w' ? 'white' : 'black';
                        const type = piece.type[1];
                        let pieceSymbol;
                        let pieceName = type;

                        if (pieceEmojis[type]) {
                            pieceSymbol = pieceEmojis[type][color];
                            const nameMap = {
                                w: 'Wizard', g: 'Grandpa', l: 'Lizard', t: 'Tank',
                                s: 'Assassin', d: 'Dragon', h: 'Ghost', x: 'Saboteur'
                            };
                            pieceName = nameMap[type] || type;
                        } else {
                            const pieceMap = {
                                k: 'king', q: 'queen', r: 'rook',
                                b: 'bishop', n: 'knight', p: 'pawn'
                            };
                            pieceSymbol = pieces[color][pieceMap[type]];
                            pieceName = pieceMap[type].charAt(0).toUpperCase() + pieceMap[type].slice(1);
                        }

                        const healthPercent = (piece.health / piece.maxHealth) * 100;
                        const abilityIndicator = !piece.abilityUsed ? `<div class="ability-indicator">⚡</div>` : '';
                        const lizardIndicator = piece.lizardAttached ? `<div class="lizard-indicator">🦎</div>` : '';
                        const shieldVal = piece.shield || 0;
                        const shieldIndicator = shieldVal > 0 ? `<div class="shield-indicator">🛡️${shieldVal}</div>` : '';
                        const shieldTooltip = shieldVal > 0 ? ` +${shieldVal} Shield` : '';

                        let customClass = '';
                        if (pieceEmojis[type]) {
                            const classMap = {
                                w: 'custom-wizard', g: 'custom-grandpa', l: 'custom-lizard',
                                t: 'custom-tank', s: 'custom-assassin', d: 'custom-dragon',
                                h: 'custom-ghost', x: 'custom-saboteur'
                            };
                            customClass = classMap[type] || '';
                        }

                        const shieldBarPercent = shieldVal > 0 ? Math.min((shieldVal / piece.maxHealth) * 100, 100) : 0;

                        square.innerHTML = `
                            <span class="piece ${customClass}" data-tooltip="${pieceName}: ${piece.health}/${piece.maxHealth} HP${shieldTooltip}">
                                ${pieceSymbol}
                            </span>
                            ${abilityIndicator}
                            ${lizardIndicator}
                            ${shieldIndicator}
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: ${healthPercent}%"></div>
                                ${shieldVal > 0 ? `<div class="shield-bar" style="width: ${shieldBarPercent}%"></div>` : ''}
                            </div>
                        `;
                    } else {
                        const hasMine = landmines.some(m => m.row === row && m.col === col);
                        if (hasMine) {
                            square.innerHTML = `<div class="landmine-indicator">💣</div>`;
                        }
                    }

                    square.addEventListener('click', () => handleSquareClick(row, col));
                    square.addEventListener('dblclick', () => handleSquareDoubleClick(row, col));
                    boardEl.appendChild(square);
                }
            }

            updateTurnIndicator();
            calculateMaterialScore();

            if (gameActive && gameMode === 'pvc' && currentTurn === 'black' && !isAIThinking) {
                setTimeout(makeAIMove, 1000);
            }
        }

        // ====== INPUT HANDLING ======
        function handleSquareClick(row, col) {
            if (!gameActive) return;
            if (gameMode === 'pvc' && currentTurn === 'black') return;
            if (gameMode === 'online' && !isMyTurnOnline() && !isRemoteAction) return;

            const clickedPiece = board[row][col];

            if (selectedSquare !== null) {
                const [selectedRow, selectedCol] = selectedSquare;
                const selectedPiece = board[selectedRow][selectedCol];

                if (activeAbility && selectedPiece && selectedPiece.type[1] === activeAbility) {
                    if (canUseAbility(selectedRow, selectedCol, row, col, activeAbility)) {
                        useAbility(selectedRow, selectedCol, row, col, activeAbility);
                        return;
                    }
                }

                if (isLegalMove(selectedRow, selectedCol, row, col)) {
                    makeMove(selectedRow, selectedCol, row, col);
                    clearSelection();
                    return;
                } else {
                    const playerColor = currentTurn === 'white' ? 'w' : 'b';
                    if (isKingInCheck(playerColor)) {
                        showMessage('⚠️ YOU ARE IN CHECK!', 'You must get your King out of check!');
                        setTimeout(hideMessage, 2000);
                    }
                }

                clearSelection();

                if (clickedPiece && clickedPiece.type[0] === currentTurn[0]) {
                    selectSquare(row, col);
                }
            } else {
                if (clickedPiece && clickedPiece.type[0] === currentTurn[0]) {
                    selectSquare(row, col);
                }
            }
        }

        function handleSquareDoubleClick(row, col) {
            if (!gameActive) return;
            if (gameMode === 'pvc' && currentTurn === 'black') return;
            if (gameMode === 'online' && !isMyTurnOnline()) return;

            const clickedPiece = board[row][col];
            if (!clickedPiece || clickedPiece.type[0] !== currentTurn[0]) return;

            const pieceType = clickedPiece.type[1];
            if (clickedPiece.abilityUsed) {
                showMessage('⚠️ ABILITY USED', 'This piece already used its ability!');
                setTimeout(hideMessage, 1500);
                return;
            }

            if (activeAbility === pieceType) {
                activeAbility = null;
                clearSelection();
            } else {
                activeAbility = pieceType;
                selectSquare(row, col);
            }
        }

        // ====== AI ======
        // Fast engine: no isLegalMove in eval, quiescence search, transposition table

        // Piece values (centipawns, Stockfish-tuned ratios)
        const PIECE_VALUES = { 
            k: 10000, q: 900, d: 850, r: 500, b: 330, n: 320, 
            w: 500, t: 600, s: 300, g: 250, l: 400, h: 150, x: 350, p: 100 
        };

        // Piece-Square Tables (from piece's own perspective, row 0 = own back rank)
        // Adapted from Stockfish's tuned middlegame tables
        const PST = {
            p: [
                [ 0,  0,  0,  0,  0,  0,  0,  0],
                [ 5, 10, 10,-20,-20, 10, 10,  5],
                [ 5, -5,-10,  0,  0,-10, -5,  5],
                [ 0,  0,  0, 25, 25,  0,  0,  0],
                [ 5,  5, 10, 30, 30, 10,  5,  5],
                [10, 10, 20, 35, 35, 20, 10, 10],
                [50, 50, 50, 50, 50, 50, 50, 50],
                [ 0,  0,  0,  0,  0,  0,  0,  0]
            ],
            n: [
                [-50,-40,-30,-30,-30,-30,-40,-50],
                [-40,-20,  0,  0,  0,  0,-20,-40],
                [-30,  0, 10, 15, 15, 10,  0,-30],
                [-30,  5, 15, 20, 20, 15,  5,-30],
                [-30,  0, 15, 20, 20, 15,  0,-30],
                [-30,  5, 10, 15, 15, 10,  5,-30],
                [-40,-20,  0,  5,  5,  0,-20,-40],
                [-50,-40,-30,-30,-30,-30,-40,-50]
            ],
            b: [
                [-20,-10,-10,-10,-10,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0, 10, 10, 10, 10,  0,-10],
                [-10,  5,  5, 10, 10,  5,  5,-10],
                [-10,  0, 10, 10, 10, 10,  0,-10],
                [-10, 10, 10, 10, 10, 10, 10,-10],
                [-10,  5,  0,  0,  0,  0,  5,-10],
                [-20,-10,-10,-10,-10,-10,-10,-20]
            ],
            r: [
                [  0,  0,  0,  5,  5,  0,  0,  0],
                [ -5,  0,  0,  0,  0,  0,  0, -5],
                [ -5,  0,  0,  0,  0,  0,  0, -5],
                [ -5,  0,  0,  0,  0,  0,  0, -5],
                [ -5,  0,  0,  0,  0,  0,  0, -5],
                [ -5,  0,  0,  0,  0,  0,  0, -5],
                [  5, 10, 10, 10, 10, 10, 10,  5],
                [  0,  0,  0,  0,  0,  0,  0,  0]
            ],
            q: [
                [-20,-10,-10, -5, -5,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0,  5,  5,  5,  5,  0,-10],
                [ -5,  0,  5,  5,  5,  5,  0, -5],
                [  0,  0,  5,  5,  5,  5,  0, -5],
                [-10,  5,  5,  5,  5,  5,  0,-10],
                [-10,  0,  5,  0,  0,  0,  0,-10],
                [-20,-10,-10, -5, -5,-10,-10,-20]
            ],
            k_mg: [ // King middlegame: stay castled
                [ 20, 30, 10,  0,  0, 10, 30, 20],
                [ 20, 20,  0,  0,  0,  0, 20, 20],
                [-10,-20,-20,-20,-20,-20,-20,-10],
                [-20,-30,-30,-40,-40,-30,-30,-20],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30]
            ],
            k_eg: [ // King endgame: centralize
                [-50,-30,-30,-30,-30,-30,-30,-50],
                [-30,-10,  0,  0,  0,  0,-10,-30],
                [-30,  0, 10, 15, 15, 10,  0,-30],
                [-30,  0, 15, 20, 20, 15,  0,-30],
                [-30,  0, 15, 20, 20, 15,  0,-30],
                [-30,  0, 10, 15, 15, 10,  0,-30],
                [-30,-10,  0,  0,  0,  0,-10,-30],
                [-50,-30,-30,-30,-30,-30,-30,-50]
            ],
            default: [
                [  0,  2,  4,  6,  6,  4,  2,  0],
                [  2,  6,  8, 10, 10,  8,  6,  2],
                [  4,  8, 12, 14, 14, 12,  8,  4],
                [  6, 10, 14, 18, 18, 14, 10,  6],
                [  6, 10, 14, 18, 18, 14, 10,  6],
                [  4,  8, 12, 14, 14, 12,  8,  4],
                [  2,  6,  8, 10, 10,  8,  6,  2],
                [  0,  2,  4,  6,  6,  4,  2,  0]
            ]
        };

        // Keep old references for compatibility
        const POSITION_TABLES = PST;
        function getPositionBonus(pieceType, row, col) {
            const table = PST[pieceType] || PST.default;
            return table[row] ? (table[row][col] || 0) : 0;
        }

        // ====== TRANSPOSITION TABLE ======
        const TT = new Map();
        const TT_MAX = 50000;
        const TT_EXACT = 0, TT_LOWER = 1, TT_UPPER = 2;
        let ttHits = 0;

        function boardHash() {
            let h = '';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = board[r][c];
                    if (p) h += p.type + p.health + (p.hasMoved?'1':'0');
                    else h += '.';
                }
            }
            return h;
        }

        // ====== FAST EVALUATION (NO isLegalMove calls!) ======
        function evaluateBoard() {
            let score = 0; // positive = good for black (AI)
            let bKing = false, wKing = false;
            let totalMat = 0;
            let bPawns = [], wPawns = [];

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = board[r][c];
                    if (!p) continue;
                    const type = p.type[1];
                    const isB = p.type[0] === 'b';
                    const val = PIECE_VALUES[type] || 100;
                    const hp = p.health / p.maxHealth;

                    if (type === 'k') { if (isB) bKing = true; else wKing = true; }
                    if (type !== 'k') totalMat += val;

                    // Material * health
                    let ps = val * hp;

                    // Piece-square table
                    const evalRow = isB ? r : (7 - r);
                    const table = (type === 'k') 
                        ? (totalMat > 2500 ? PST.k_mg : PST.k_eg)
                        : (PST[type] || PST.default);
                    if (table[evalRow]) ps += table[evalRow][c];

                    // Ability & shield
                    if (!p.abilityUsed) ps += 12;
                    if (p.shield) ps += p.shield * 0.4;

                    // Track pawns for structure eval
                    if (type === 'p') {
                        if (isB) bPawns.push({r, c}); else wPawns.push({r, c});
                    }

                    // Bishop pair bonus
                    if (type === 'b') ps += 15;

                    // Rook on open/semi-open file
                    if (type === 'r' || type === 'q' || type === 'd') {
                        let friendlyPawnsOnFile = 0, enemyPawnsOnFile = 0;
                        const myPawns = isB ? bPawns : wPawns;
                        const theirPawns = isB ? wPawns : bPawns;
                        // Quick scan column for pawns
                        for (let rr = 0; rr < 8; rr++) {
                            const pp = board[rr][c];
                            if (pp && pp.type[1] === 'p') {
                                if (pp.type[0] === p.type[0]) friendlyPawnsOnFile++;
                                else enemyPawnsOnFile++;
                            }
                        }
                        if (friendlyPawnsOnFile === 0 && enemyPawnsOnFile === 0) ps += 25;
                        else if (friendlyPawnsOnFile === 0) ps += 12;
                    }

                    if (isB) score += ps; else score -= ps;
                }
            }

            if (!wKing) return 999999;
            if (!bKing) return -999999;

            // Pawn structure
            for (const p of bPawns) {
                if (bPawns.some(o => o.c === p.c && o.r !== p.r)) score -= 12; // doubled
                if (!bPawns.some(o => Math.abs(o.c - p.c) === 1)) score -= 10; // isolated
                // Passed pawn: no enemy pawns ahead on same or adjacent cols
                if (!wPawns.some(o => Math.abs(o.c - p.c) <= 1 && o.r > p.r)) {
                    score += 20 + p.r * 12; // more advanced = more valuable
                }
            }
            for (const p of wPawns) {
                if (wPawns.some(o => o.c === p.c && o.r !== p.r)) score += 12;
                if (!wPawns.some(o => Math.abs(o.c - p.c) === 1)) score += 10;
                if (!bPawns.some(o => Math.abs(o.c - p.c) <= 1 && o.r < p.r)) {
                    score -= 20 + (7 - p.r) * 12;
                }
            }

            // King safety (pawn shield) — only in middlegame
            if (totalMat > 2500) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const p = board[r][c];
                        if (!p || p.type[1] !== 'k') continue;
                        let shield = 0;
                        const isB = p.type[0] === 'b';
                        const dir = isB ? 1 : -1;
                        for (let dc = -1; dc <= 1; dc++) {
                            const sc = c + dc;
                            const sr = r + dir;
                            if (sc >= 0 && sc < 8 && sr >= 0 && sr < 8) {
                                const sp = board[sr][sc];
                                if (sp && sp.type[1] === 'p' && sp.type[0] === p.type[0]) {
                                    shield += 18;
                                }
                            }
                        }
                        if (isB) score += shield; else score -= shield;
                    }
                }
            }

            // Check bonuses (cheap calls)
            if (isKingInCheck('w')) score += 50;
            if (isKingInCheck('b')) score -= 50;

            return score;
        }

        // ====== QUIESCENCE SEARCH (captures only — avoids horizon effect) ======
        function quiescence(alpha, beta, isMaximizing, qDepth) {
            const standPat = evaluateBoard();
            if (qDepth <= 0) return standPat;

            if (isMaximizing) {
                if (standPat >= beta) return beta;
                if (standPat > alpha) alpha = standPat;
            } else {
                if (standPat <= alpha) return alpha;
                if (standPat < beta) beta = standPat;
            }

            const color = isMaximizing ? 'b' : 'w';
            const enemy = isMaximizing ? 'w' : 'b';

            // Generate capture moves only (much faster than all moves)
            for (let fr = 0; fr < 8; fr++) {
                for (let fc = 0; fc < 8; fc++) {
                    const p = board[fr][fc];
                    if (!p || p.type[0] !== color) continue;
                    for (let tr = 0; tr < 8; tr++) {
                        for (let tc = 0; tc < 8; tc++) {
                            const target = board[tr][tc];
                            if (!target || target.type[0] !== enemy) continue;
                            if (!isLegalMove(fr, fc, tr, tc)) continue;

                            // Delta pruning: skip if capture can't raise alpha
                            const captureVal = PIECE_VALUES[target.type[1]] || 100;
                            if (isMaximizing && standPat + captureVal + 200 < alpha) continue;
                            if (!isMaximizing && standPat - captureVal - 200 > beta) continue;

                            const mp = board[fr][fc];
                            const cp = board[tr][tc];
                            const oh = mp.hasMoved;
                            board[tr][tc] = mp;
                            board[fr][fc] = null;
                            if (mp.hasMoved !== undefined) mp.hasMoved = true;

                            const val = quiescence(alpha, beta, !isMaximizing, qDepth - 1);

                            board[fr][fc] = mp;
                            board[tr][tc] = cp;
                            if (oh !== undefined) mp.hasMoved = oh;

                            if (isMaximizing) {
                                if (val > alpha) alpha = val;
                                if (alpha >= beta) return beta;
                            } else {
                                if (val < beta) beta = val;
                                if (alpha >= beta) return alpha;
                            }
                        }
                    }
                }
            }

            return isMaximizing ? alpha : beta;
        }

        // ====== MINIMAX WITH ALPHA-BETA + TT ======
        function minimax(depth, alpha, beta, isMaximizing) {
            // TT lookup
            const hash = boardHash();
            const ttE = TT.get(hash);
            if (ttE && ttE.depth >= depth) {
                if (ttE.flag === TT_EXACT) return ttE.score;
                if (ttE.flag === TT_LOWER && ttE.score > alpha) alpha = ttE.score;
                if (ttE.flag === TT_UPPER && ttE.score < beta) beta = ttE.score;
                if (alpha >= beta) { ttHits++; return ttE.score; }
            }

            if (depth <= 0) return quiescence(alpha, beta, isMaximizing, 3);

            const color = isMaximizing ? 'b' : 'w';
            const moves = getAllValidMoves(color);

            if (moves.length === 0) {
                if (isKingInCheck(color)) {
                    return isMaximizing ? -999999 + (30 - depth) : 999999 - (30 - depth);
                }
                return 0; // Stalemate
            }

            // Move ordering: captures by MVV-LVA first, then positional
            moves.sort((a, b) => {
                let sa = 0, sb = 0;
                const at = board[a.to.row][a.to.col];
                const bt = board[b.to.row][b.to.col];
                if (at && at.type[0] !== color) sa += (PIECE_VALUES[at.type[1]]||100)*10 - (PIECE_VALUES[board[a.from.row][a.from.col].type[1]]||100);
                if (bt && bt.type[0] !== color) sb += (PIECE_VALUES[bt.type[1]]||100)*10 - (PIECE_VALUES[board[b.from.row][b.from.col].type[1]]||100);
                return sb - sa;
            });

            let bestScore = isMaximizing ? -Infinity : Infinity;
            let ttFlag = isMaximizing ? TT_UPPER : TT_LOWER;

            for (let i = 0; i < moves.length; i++) {
                const move = moves[i];
                const mp = board[move.from.row][move.from.col];
                const cp = board[move.to.row][move.to.col];
                const oh = mp.hasMoved;

                board[move.to.row][move.to.col] = mp;
                board[move.from.row][move.from.col] = null;
                if (mp.hasMoved !== undefined) mp.hasMoved = true;

                // Late move reduction: reduce depth for late quiet moves
                let reduction = 0;
                if (depth >= 3 && i >= 4 && !cp) reduction = 1;

                let val = minimax(depth - 1 - reduction, alpha, beta, !isMaximizing);

                // Re-search at full depth if reduced search found something good
                if (reduction > 0) {
                    if (isMaximizing && val > alpha) {
                        val = minimax(depth - 1, alpha, beta, !isMaximizing);
                    } else if (!isMaximizing && val < beta) {
                        val = minimax(depth - 1, alpha, beta, !isMaximizing);
                    }
                }

                board[move.from.row][move.from.col] = mp;
                board[move.to.row][move.to.col] = cp;
                if (oh !== undefined) mp.hasMoved = oh;

                if (isMaximizing) {
                    if (val > bestScore) bestScore = val;
                    if (val > alpha) { alpha = val; ttFlag = TT_EXACT; }
                    if (alpha >= beta) { ttFlag = TT_LOWER; break; }
                } else {
                    if (val < bestScore) bestScore = val;
                    if (val < beta) { beta = val; ttFlag = TT_EXACT; }
                    if (alpha >= beta) { ttFlag = TT_UPPER; break; }
                }
            }

            // Store in TT
            if (TT.size > TT_MAX) TT.clear();
            TT.set(hash, { depth, score: bestScore, flag: ttFlag });

            return bestScore;
        }

        // ====== FAST MOVE SCORER (for pre-ordering, no board manipulation) ======
        function scoreMoveFast(move) {
            const { from, to } = move;
            const piece = board[from.row][from.col];
            const target = board[to.row][to.col];
            const type = piece.type[1];
            let s = 0;

            // Captures: MVV-LVA
            if (target && target.type[0] !== piece.type[0]) {
                const victimVal = PIECE_VALUES[target.type[1]] || 100;
                const attackerVal = PIECE_VALUES[type] || 100;
                s += victimVal * 10 - attackerVal;
                // Low HP kill bonus
                if (target.health <= 30) s += 200;
            }

            // Positional improvement
            const evalRow = 7 - to.row;
            const oldEvalRow = 7 - from.row;
            const table = PST[type] || PST.default;
            s += (table[evalRow]?.[to.col] || 0) - (table[oldEvalRow]?.[from.col] || 0);

            // Development: pieces off back rank early
            if (from.row === 0 && type !== 'k' && type !== 'r') s += 25;

            // Center pawn push
            if (type === 'p' && to.col >= 2 && to.col <= 5 && to.row >= 3 && to.row <= 5) s += 20;

            // Avoid hanging pieces (no board manipulation — just check attack tables)
            if (!target && isSquareUnderAttack(to.row, to.col, 'w')) {
                const myVal = PIECE_VALUES[type] || 100;
                if (myVal > 200) s -= myVal;
            }

            return s;
        }

        function isSquareDefended(row, col, byColor) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = board[r][c];
                    if (!p || p.type[0] !== byColor) continue;
                    if (r === row && c === col) continue;
                    const type = p.type[1];
                    switch (type) {
                        case 'p': { const dir = byColor === 'w' ? -1 : 1; if (Math.abs(col-c)===1 && row===r+dir) return true; break; }
                        case 'r': if (isValidRookMove(r,c,row,col)) return true; break;
                        case 'n': if (isValidKnightMove(r,c,row,col)) return true; break;
                        case 'b': if (isValidBishopMove(r,c,row,col)) return true; break;
                        case 'q': if (isValidQueenMove(r,c,row,col)) return true; break;
                        case 'k': if (isValidKingMove(r,c,row,col)) return true; break;
                        case 's': if (isValidKnightMove(r,c,row,col)) return true; break;
                        case 'd': if (isValidQueenMove(r,c,row,col) && Math.max(Math.abs(row-r),Math.abs(col-c))<=4) return true; break;
                        case 'w': if (isValidBishopMove(r,c,row,col) && Math.max(Math.abs(row-r),Math.abs(col-c))<=3) return true; break;
                        default: if (Math.abs(row-r)<=1 && Math.abs(col-c)<=1) return true; break;
                    }
                }
            }
            return false;
        }

        // ====== MAIN AI MOVE FUNCTION ======
        function makeAIMove() {
            if (!gameActive || currentTurn !== 'black' || isAIThinking) return;
            isAIThinking = true;

            setTimeout(() => {
                try {
                    TT.clear();
                    ttHits = 0;

                    const kingInCheck = isKingInCheck('b');

                    // === TRY ABILITIES ===
                    const abilityMoves = getAllValidAbilityMoves('b');
                    const filteredAbilities = kingInCheck
                        ? abilityMoves.filter(m => m.abilityType === 'k')
                        : abilityMoves;

                    if (filteredAbilities.length > 0) {
                        const scored = filteredAbilities.map(m => ({m, s: scoreAbilityMove(m)}));
                        scored.sort((a,b) => b.s - a.s);
                        const threshold = rankedMode ? 10 : 30;
                        const useChance = rankedMode ? 100 : Math.min(aiDifficulty + 20, 100);
                        if (scored[0].s > threshold && Math.random() * 100 < useChance) {
                            const b = scored[0].m;
                            useAbility(b.from.row, b.from.col, b.to.row, b.to.col, b.abilityType);
                            isAIThinking = false;
                            return;
                        }
                    }

                    const allMoves = getAllValidMoves('b');
                    if (allMoves.length === 0) {
                        if (kingInCheck && filteredAbilities.length > 0) {
                            const b = filteredAbilities[0];
                            useAbility(b.from.row, b.from.col, b.to.row, b.to.col, b.abilityType);
                        }
                        isAIThinking = false;
                        checkGameEnd();
                        return;
                    }

                    // ====== DIFFICULTY SCALING ======
                    //  1-15:  Pure random
                    // 16-30:  Random but avoid blunders
                    // 31-45:  Depth 1 + quiescence
                    // 46-60:  Depth 2 + quiescence (sees tactics)
                    // 61-75:  Depth 3 + quiescence (plays real chess)
                    // 76-90:  Depth 4 + quiescence (strong, sees combinations)
                    // 91-100: Depth 5 + quiescence (very strong)
                    // Ranked: Depth 4, full search

                    let chosenMove;
                    const diff = rankedMode ? 85 : aiDifficulty;

                    if (diff <= 15) {
                        // Pure random
                        chosenMove = allMoves[Math.floor(Math.random() * allMoves.length)];

                    } else if (diff <= 30) {
                        // Random but avoid obvious blunders
                        const safe = allMoves.filter(m => {
                            const val = PIECE_VALUES[board[m.from.row][m.from.col].type[1]] || 100;
                            const cap = board[m.to.row][m.to.col];
                            const capVal = cap ? (PIECE_VALUES[cap.type[1]] || 0) : 0;
                            if (isSquareUnderAttack(m.to.row, m.to.col, 'w') && capVal < val && val > 200) return false;
                            return true;
                        });
                        const pool = safe.length > 0 ? safe : allMoves;
                        // Slightly prefer captures
                        const captures = pool.filter(m => board[m.to.row][m.to.col]);
                        if (captures.length > 0 && Math.random() < 0.5) {
                            chosenMove = captures[Math.floor(Math.random() * captures.length)];
                        } else {
                            chosenMove = pool[Math.floor(Math.random() * pool.length)];
                        }

                    } else if (diff <= 45) {
                        chosenMove = searchBestMove(allMoves, 1);
                    } else if (diff <= 60) {
                        chosenMove = searchBestMove(allMoves, 2);
                    } else if (diff <= 75) {
                        chosenMove = searchBestMove(allMoves, 3);
                    } else if (diff <= 90) {
                        chosenMove = searchBestMove(allMoves, 4);
                    } else {
                        chosenMove = searchBestMove(allMoves, 5);
                    }

                    makeMove(chosenMove.from.row, chosenMove.from.col, chosenMove.to.row, chosenMove.to.col);
                } catch(e) {
                    console.error('AI error:', e);
                    const allMoves = getAllValidMoves('b');
                    if (allMoves.length > 0) {
                        allMoves.sort((a,b) => scoreMoveFast(b) - scoreMoveFast(a));
                        makeMove(allMoves[0].from.row, allMoves[0].from.col, allMoves[0].to.row, allMoves[0].to.col);
                    }
                }
                isAIThinking = false;
            }, 300);
        }

        function searchBestMove(moves, depth) {
            // Pre-sort moves for better alpha-beta pruning
            moves.sort((a, b) => scoreMoveFast(b) - scoreMoveFast(a));

            let bestMove = moves[0];
            let bestScore = -Infinity;
            let alpha = -Infinity;
            const beta = Infinity;

            for (let i = 0; i < moves.length; i++) {
                const move = moves[i];
                const mp = board[move.from.row][move.from.col];
                const cp = board[move.to.row][move.to.col];
                const oh = mp.hasMoved;

                board[move.to.row][move.to.col] = mp;
                board[move.from.row][move.from.col] = null;
                if (mp.hasMoved !== undefined) mp.hasMoved = true;

                // Use aspiration window for faster search after first move
                let score;
                if (i === 0) {
                    score = minimax(depth - 1, -Infinity, Infinity, false);
                } else {
                    // Null window search
                    score = minimax(depth - 1, alpha, alpha + 1, false);
                    if (score > alpha) {
                        // Re-search with full window
                        score = minimax(depth - 1, alpha, Infinity, false);
                    }
                }

                board[move.from.row][move.from.col] = mp;
                board[move.to.row][move.to.col] = cp;
                if (oh !== undefined) mp.hasMoved = oh;

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                    if (score > alpha) alpha = score;
                }
            }

            return bestMove;
        }

        // Compatibility wrappers
        function scoreMove(moveData, difficulty) { return scoreMoveFast(moveData); }
        function canOpponentCheckmateIn1() { return false; } // handled by minimax depth now
        function getDefendedPieces(row, col, color) {
            let count = 0;
            for (let r = row-1; r <= row+1; r++) {
                for (let c = col-1; c <= col+1; c++) {
                    if (r>=0 && r<8 && c>=0 && c<8 && board[r][c] && board[r][c].type[0]===color && (r!==row||c!==col)) count++;
                }
            }
            return count;
        }

        function scoreAbilityMove(moveData) {
            const { from, to, abilityType } = moveData;
            const target = board[to.row][to.col];
            let score = 40;

            if (target && target.type[0] === 'w') {
                score += (PIECE_VALUES[target.type[1]] || 100);
                score += Math.max(0, (target.maxHealth - target.health));
                const dmgMap = { p: 20, r: 35, s: 40, d: 50, n: 30, b: 15, l: 0 };
                if (target.health <= (dmgMap[abilityType] || 0)) score += 300;
            }

            if (abilityType === 'q' && target && target.type[0] === 'b') {
                const heal = Math.min(50, target.maxHealth - target.health);
                score += heal * 3;
                if (target.type[1] === 'k') score += 100;
            }

            if (abilityType === 'g') score += 50;
            if (abilityType === 't') score += 80;
            if (abilityType === 'd') score += 120;
            if (abilityType === 'k') score += 200;

            return score;
        }


        function getAllValidAbilityMoves(color) {
            const moves = [];
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && piece.type[0] === color && !piece.abilityUsed) {
                        const abilityType = piece.type[1];
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (canUseAbility(fromRow, fromCol, toRow, toCol, abilityType)) {
                                    moves.push({
                                        from: { row: fromRow, col: fromCol },
                                        to: { row: toRow, col: toCol },
                                        abilityType: abilityType
                                    });
                                }
                            }
                        }
                    }
                }
            }
            return moves;
        }

        function getAllValidMoves(color) {
            const moves = [];
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && piece.type[0] === color) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isLegalMove(fromRow, fromCol, toRow, toCol)) {
                                    moves.push({
                                        from: { row: fromRow, col: fromCol },
                                        to: { row: toRow, col: toCol }
                                    });
                                }
                            }
                        }
                    }
                }
            }
            return moves;
        }

        // ====== SELECTION & HIGHLIGHTS ======
        function selectSquare(row, col) {
            selectedSquare = [row, col];

            document.querySelectorAll('.square').forEach(sq => {
                sq.classList.remove('selected', 'legal-move', 'ability-target');
            });

            const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (square) {
                square.classList.add('selected');
            }

            const piece = board[row][col];
            highlightPieceInGuide(piece);

            if (activeAbility && piece && piece.type[1] === activeAbility) {
                showAbilityTargets(row, col, activeAbility);
            } else {
                showLegalMoves(row, col);
            }
        }

        function showLegalMoves(row, col) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isLegalMove(row, col, r, c)) {
                        const square = document.querySelector(`#board [data-row="${r}"][data-col="${c}"]`);
                        if (square) {
                            square.classList.add('legal-move');
                        }
                    }
                }
            }
        }

        function showAbilityTargets(row, col, abilityType) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (canUseAbility(row, col, r, c, abilityType)) {
                        const square = document.querySelector(`#board [data-row="${r}"][data-col="${c}"]`);
                        if (square) {
                            square.classList.add('ability-target');
                        }
                    }
                }
            }
        }

        function clearSelection() {
            selectedSquare = null;
            activeAbility = null;
            document.querySelectorAll('.square').forEach(sq => {
                sq.classList.remove('selected', 'legal-move', 'ability-target');
            });
            highlightPieceInGuide(null);
        }

        // ====== MOVEMENT RULES ======
        function canCastle(row, kingCol, targetCol, color) {
            const king = board[row][kingCol];
            if (!king || king.hasMoved) return false;
            if (isKingInCheck(color)) return false;

            const isKingside = targetCol > kingCol;
            const rookCol = isKingside ? 7 : 0;
            const rook = board[row][rookCol];

            if (!rook || rook.type[1] !== 'r' || rook.hasMoved) return false;

            const start = Math.min(kingCol, rookCol) + 1;
            const end = Math.max(kingCol, rookCol);
            for (let col = start; col < end; col++) {
                if (board[row][col]) return false;
            }

            const direction = isKingside ? 1 : -1;
            for (let i = 1; i <= 2; i++) {
                const checkCol = kingCol + (i * direction);
                if (isSquareUnderAttack(row, checkCol, color === 'w' ? 'b' : 'w')) {
                    return false;
                }
            }

            return true;
        }

        function isLegalMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            if (!piece) return false;

            const targetPiece = board[toRow][toCol];
            if (targetPiece && targetPiece.type[0] === piece.type[0]) return false;
            if (targetPiece && targetPiece.type[1] === 'k') return false;
            if (fromRow === toRow && fromCol === toCol) return false;

            const type = piece.type[1];
            const color = piece.type[0];

            let isValid = false;

            switch (type) {
                case 'p':
                    isValid = isValidPawnMove(fromRow, fromCol, toRow, toCol, color);
                    break;
                case 'r':
                    isValid = isValidRookMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'n':
                    isValid = isValidKnightMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'b':
                    isValid = isValidBishopMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'q':
                    isValid = isValidQueenMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'k':
                    if (fromRow === toRow && Math.abs(toCol - fromCol) === 2) {
                        isValid = canCastle(fromRow, fromCol, toCol, color);
                    } else {
                        isValid = isValidKingMove(fromRow, fromCol, toRow, toCol);
                    }
                    break;
                case 'w':
                    isValid = isValidBishopMove(fromRow, fromCol, toRow, toCol) &&
                              Math.max(Math.abs(toRow - fromRow), Math.abs(toCol - fromCol)) <= 3;
                    break;
                case 'g':
                    isValid = isValidKingMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'l':
                    isValid = isValidKingMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 't':
                    isValid = isValidKingMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 's':
                    const sRowDiff = Math.abs(toRow - fromRow);
                    const sColDiff = Math.abs(toCol - fromCol);
                    isValid = (sRowDiff === 2 && sColDiff === 1) || (sRowDiff === 1 && sColDiff === 2);
                    break;
                case 'd':
                    isValid = isValidQueenMove(fromRow, fromCol, toRow, toCol) &&
                              Math.max(Math.abs(toRow - fromRow), Math.abs(toCol - fromCol)) <= 4;
                    break;
                case 'x':
                    isValid = isValidKingMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'h':
                    if (piece.stolenSoul) {
                        const stolenType = piece.stolenSoul;
                        switch(stolenType) {
                            case 'p': isValid = isValidPawnMove(fromRow, fromCol, toRow, toCol, color); break;
                            case 'r': isValid = isValidRookMove(fromRow, fromCol, toRow, toCol, color); break;
                            case 'n': isValid = isValidKnightMove(fromRow, fromCol, toRow, toCol); break;
                            case 'b': isValid = isValidBishopMove(fromRow, fromCol, toRow, toCol, color); break;
                            case 'q': isValid = isValidQueenMove(fromRow, fromCol, toRow, toCol, color); break;
                            case 'k': isValid = isValidKingMove(fromRow, fromCol, toRow, toCol); break;
                            case 'w':
                                isValid = isValidBishopMove(fromRow, fromCol, toRow, toCol, color) &&
                                         Math.max(Math.abs(toRow - fromRow), Math.abs(toCol - fromCol)) <= 3;
                                break;
                            case 'd':
                                isValid = isValidQueenMove(fromRow, fromCol, toRow, toCol, color) &&
                                         Math.max(Math.abs(toRow - fromRow), Math.abs(toCol - fromCol)) <= 4;
                                break;
                            case 'g': case 'l': case 't': case 's': case 'x':
                                if (stolenType === 's') {
                                    const sRowDiff2 = Math.abs(toRow - fromRow);
                                    const sColDiff2 = Math.abs(toCol - fromCol);
                                    isValid = (sRowDiff2 === 2 && sColDiff2 === 1) || (sRowDiff2 === 1 && sColDiff2 === 2);
                                } else {
                                    isValid = isValidKingMove(fromRow, fromCol, toRow, toCol);
                                }
                                break;
                            default: isValid = isValidKingMove(fromRow, fromCol, toRow, toCol);
                        }
                    } else {
                        isValid = Math.abs(toRow - fromRow) <= 1 && Math.abs(toCol - fromCol) <= 1;
                    }
                    break;
            }

            if (!isValid) return false;

            return !wouldBeInCheckAfterMove(fromRow, fromCol, toRow, toCol, color);
        }

        function isValidPawnMove(fromRow, fromCol, toRow, toCol, color) {
            const direction = color === 'w' ? -1 : 1;
            const startRow = color === 'w' ? 6 : 1;

            if (toCol === fromCol && toRow === fromRow + direction && !board[toRow][toCol]) {
                return true;
            }

            if (toCol === fromCol && fromRow === startRow && toRow === fromRow + 2 * direction &&
                !board[toRow][toCol] && !board[fromRow + direction][fromCol]) {
                return true;
            }

            if (Math.abs(toCol - fromCol) === 1 && toRow === fromRow + direction && board[toRow][toCol]) {
                return true;
            }

            return false;
        }

        function isValidRookMove(fromRow, fromCol, toRow, toCol, ignoreFriendlyColor) {
            if (fromRow !== toRow && fromCol !== toCol) return false;
            return !isPathBlocked(fromRow, fromCol, toRow, toCol, ignoreFriendlyColor);
        }

        function isValidKnightMove(fromRow, fromCol, toRow, toCol) {
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
        }

        function isValidBishopMove(fromRow, fromCol, toRow, toCol, ignoreFriendlyColor) {
            if (Math.abs(toRow - fromRow) !== Math.abs(toCol - fromCol)) return false;
            return !isPathBlocked(fromRow, fromCol, toRow, toCol, ignoreFriendlyColor);
        }

        function isValidQueenMove(fromRow, fromCol, toRow, toCol, ignoreFriendlyColor) {
            return isValidRookMove(fromRow, fromCol, toRow, toCol, ignoreFriendlyColor) ||
                   isValidBishopMove(fromRow, fromCol, toRow, toCol, ignoreFriendlyColor);
        }

        function isValidKingMove(fromRow, fromCol, toRow, toCol) {
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            return rowDiff <= 1 && colDiff <= 1;
        }

        function isPathBlocked(fromRow, fromCol, toRow, toCol, ignoreFriendlyColor) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;

            while (currentRow !== toRow || currentCol !== toCol) {
                const blockingPiece = board[currentRow][currentCol];
                if (blockingPiece) {
                    if (ignoreFriendlyColor && blockingPiece.type[0] === ignoreFriendlyColor) {
                        // Skip friendly pieces for Ghost
                    } else {
                        return true;
                    }
                }
                currentRow += rowStep;
                currentCol += colStep;
            }

            return false;
        }

        // ====== CHECK DETECTION ======
        function findKing(color) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.type[0] === color && piece.type[1] === 'k') {
                        return { row, col };
                    }
                }
            }
            return null;
        }

        function isSquareUnderAttack(row, col, byColor) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.type[0] !== byColor) continue;

                    const type = piece.type[1];
                    let canAttack = false;

                    switch (type) {
                        case 'p':
                            const direction = byColor === 'w' ? -1 : 1;
                            canAttack = Math.abs(col - c) === 1 && row === r + direction;
                            break;
                        case 'r':
                            canAttack = isValidRookMove(r, c, row, col);
                            break;
                        case 'n':
                            canAttack = isValidKnightMove(r, c, row, col);
                            break;
                        case 'b':
                            canAttack = isValidBishopMove(r, c, row, col);
                            break;
                        case 'q':
                            canAttack = isValidQueenMove(r, c, row, col);
                            break;
                        case 'k':
                            canAttack = isValidKingMove(r, c, row, col);
                            break;
                        case 'w':
                            canAttack = isValidBishopMove(r, c, row, col) &&
                                      Math.max(Math.abs(row - r), Math.abs(col - c)) <= 3;
                            break;
                        case 't':
                            canAttack = isValidKingMove(r, c, row, col);
                            break;
                        case 's':
                            canAttack = isValidKnightMove(r, c, row, col);
                            break;
                        case 'd':
                            canAttack = isValidQueenMove(r, c, row, col) &&
                                      Math.max(Math.abs(row - r), Math.abs(col - c)) <= 4;
                            break;
                        case 'g':
                            canAttack = isValidKingMove(r, c, row, col);
                            break;
                        case 'l':
                            canAttack = isValidKingMove(r, c, row, col);
                            break;
                        case 'h':
                            canAttack = Math.abs(row - r) <= 1 && Math.abs(col - c) <= 1;
                            break;
                        case 'x':
                            canAttack = isValidKingMove(r, c, row, col);
                            break;
                    }

                    if (canAttack) return true;
                }
            }
            return false;
        }

        function isKingInCheck(color) {
            const kingPos = findKing(color);
            if (!kingPos) return false;
            const opponentColor = color === 'w' ? 'b' : 'w';
            return isSquareUnderAttack(kingPos.row, kingPos.col, opponentColor);
        }

        function wouldBeInCheckAfterMove(fromRow, fromCol, toRow, toCol, color) {
            const movingPiece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];

            board[toRow][toCol] = movingPiece;
            board[fromRow][fromCol] = null;

            const inCheck = isKingInCheck(color);

            board[fromRow][fromCol] = movingPiece;
            board[toRow][toCol] = capturedPiece;

            return inCheck;
        }

        // ====== MAKING MOVES ======
        function makeMove(fromRow, fromCol, toRow, toCol) {
            // Notify the other player in online mode
            sendOnlineAction({action:'move', fromRow, fromCol, toRow, toCol});

            const movingPiece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];

            if (movingPiece.type[1] === 'k' && Math.abs(toCol - fromCol) === 2) {
                const isKingside = toCol > fromCol;
                const rookCol = isKingside ? 7 : 0;
                const newRookCol = isKingside ? toCol - 1 : toCol + 1;
                const rook = board[fromRow][rookCol];

                board[toRow][toCol] = movingPiece;
                board[fromRow][fromCol] = null;
                movingPiece.hasMoved = true;

                if (rook) {
                    board[fromRow][newRookCol] = rook;
                    board[fromRow][rookCol] = null;
                    rook.hasMoved = true;
                }

                switchTurn();
                applyPoisonDamage();
                renderBoard();
                checkGameEnd();
                return;
            }

            if (targetPiece) {
                if (targetPiece.type[1] === 'k') {
                    const winner = movingPiece.type[0] === 'w' ? 'WHITE' : 'BLACK';
                    board[toRow][toCol] = movingPiece;
                    board[fromRow][fromCol] = null;
                    renderBoard();
                    setTimeout(() => endGame(winner, currentTurn === 'white'), 300);
                    return;
                }
            }

            board[toRow][toCol] = movingPiece;
            board[fromRow][fromCol] = null;

            if (movingPiece.hasMoved !== undefined) {
                movingPiece.hasMoved = true;
            }

            const mineIndex = landmines.findIndex(m => m.row === toRow && m.col === toCol);
            if (mineIndex !== -1) {
                const mine = landmines[mineIndex];
                createExplosion(toRow, toCol);
                setTimeout(() => {
                    dealDamage(toRow, toCol, 60);
                    landmines.splice(mineIndex, 1);
                    renderBoard();
                }, 300);
            }

            if (movingPiece.type[1] === 'p') {
                const color = movingPiece.type[0];
                const promotionRow = color === 'w' ? 0 : 7;
                if (toRow === promotionRow) {
                    if (gameMode === 'pvc' && color === 'b') {
                        promotePawn(toRow, toCol, 'q');
                    } else if (gameMode === 'online' && isRemoteAction) {
                        // Wait for separate 'promote' action from remote
                        renderBoard();
                        return;
                    } else {
                        renderBoard();
                        showPromotionDialog(toRow, toCol, color);
                        return;
                    }
                }
            }

            switchTurn();
            applyPoisonDamage();
            renderBoard();
            checkGameEnd();
        }

        // ====== ABILITIES ======
        function canUseAbility(fromRow, fromCol, toRow, toCol, abilityType) {
            const piece = board[fromRow][fromCol];
            if (!piece || piece.type[1] !== abilityType) return false;
            if (piece.abilityUsed) return false;

            const color = piece.type[0];
            const targetPiece = board[toRow][toCol];

            switch (abilityType) {
                case 'p':
                    const direction = color === 'w' ? -1 : 1;
                    if (toCol !== fromCol) return false;
                    if (color === 'w' && toRow >= fromRow) return false;
                    if (color === 'b' && toRow <= fromRow) return false;
                    let checkRow = fromRow + direction;
                    while (checkRow >= 0 && checkRow < 8) {
                        if (board[checkRow][fromCol]) {
                            if (checkRow === toRow) {
                                return targetPiece && targetPiece.type[0] !== color;
                            }
                            return false;
                        }
                        checkRow += direction;
                    }
                    return false;

                case 'q':
                    return targetPiece && targetPiece.type[0] === color;

                case 'r':
                    if (fromRow !== toRow && fromCol !== toCol) return false;
                    return targetPiece && targetPiece.type[0] !== color;

                case 'b':
                    if (Math.abs(toRow - fromRow) !== Math.abs(toCol - fromCol)) return false;
                    if (!targetPiece || targetPiece.type[0] === color) return false;
                    return !isPathBlocked(fromRow, fromCol, toRow, toCol);

                case 'n':
                    const rowDiff = Math.abs(toRow - fromRow);
                    const colDiff = Math.abs(toCol - fromCol);
                    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);

                case 'k':
                    if (!isKingInCheck(color)) return false;
                    return Math.abs(toRow - fromRow) <= 1 && Math.abs(toCol - fromCol) <= 1;

                case 'w':
                    if (!targetPiece || targetPiece.type[0] !== color) return false;
                    return targetPiece.abilityUsed === true;

                case 'g':
                    if (Math.abs(toRow - fromRow) > 1 || Math.abs(toCol - fromCol) > 1) return false;
                    return !targetPiece;

                case 'l':
                    if (Math.abs(toRow - fromRow) > 3 || Math.abs(toCol - fromCol) > 3) return false;
                    return targetPiece && targetPiece.type[0] !== color;

                case 't':
                    return Math.abs(toRow - fromRow) <= 2 && Math.abs(toCol - fromCol) <= 2;

                case 's':
                    if (Math.abs(toRow - fromRow) > 2 || Math.abs(toCol - fromCol) > 2) return false;
                    return targetPiece && targetPiece.type[0] !== color;

                case 'd':
                    return Math.abs(toRow - fromRow) <= 3 && Math.abs(toCol - fromCol) <= 3;

                case 'h':
                    if (Math.abs(toRow - fromRow) > 2 || Math.abs(toCol - fromCol) > 2) return false;
                    if (!targetPiece || targetPiece.type[0] === color) return false;
                    return targetPiece.type[1] !== 'k';

                case 'x':
                    if (Math.abs(toRow - fromRow) > 3 || Math.abs(toCol - fromCol) > 3) return false;
                    const hasMine = landmines.some(m => m.row === toRow && m.col === toCol);
                    return !targetPiece && !hasMine;
            }
            return false;
        }

        function useAbility(fromRow, fromCol, toRow, toCol, abilityType) {
            // Notify the other player in online mode
            sendOnlineAction({action:'ability', fromRow, fromCol, toRow, toCol, abilityType});

            const piece = board[fromRow][fromCol];
            if (piece) {
                piece.abilityUsed = true;
            }

            switch (abilityType) {
                case 'p':
                    animateProjectile(fromRow, fromCol, toRow, toCol, 'bullet', () => {
                        dealDamage(toRow, toCol, 20);
                        switchTurn();
                        clearSelection();
                        renderBoard();
                        checkGameEnd();
                    });
                    return;

                case 'q':
                    createHealEffect(toRow, toCol);
                    setTimeout(() => {
                        if (board[toRow][toCol]) {
                            board[toRow][toCol].health = Math.min(
                                board[toRow][toCol].health + 50,
                                board[toRow][toCol].maxHealth
                            );
                        }
                        switchTurn();
                        clearSelection();
                        renderBoard();
                        checkGameEnd();
                    }, 500);
                    return;

                case 'r':
                    animateProjectile(fromRow, fromCol, toRow, toCol, 'cannonball', () => {
                        dealDamage(toRow, toCol, 35);
                        switchTurn();
                        clearSelection();
                        renderBoard();
                        checkGameEnd();
                    });
                    return;

                case 'b':
                    createTeleportEffect(fromRow, fromCol);
                    createTeleportEffect(toRow, toCol);
                    setTimeout(() => {
                        const temp = board[fromRow][fromCol];
                        board[fromRow][fromCol] = board[toRow][toCol];
                        board[toRow][toCol] = temp;
                        dealDamage(fromRow, fromCol, 15);
                        dealDamage(toRow, toCol, 15);
                        switchTurn();
                        clearSelection();
                        renderBoard();
                        checkGameEnd();
                    }, 500);
                    return;

                case 'n':
                    board[toRow][toCol] = piece;
                    board[fromRow][fromCol] = null;
                    renderBoard();
                    setTimeout(() => {
                        createShockwave(toRow, toCol);
                        const slamColor = piece.type[0];
                        for (let r = toRow - 1; r <= toRow + 1; r++) {
                            for (let c = toCol - 1; c <= toCol + 1; c++) {
                                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                                    const slamTarget = board[r][c];
                                    if (slamTarget && slamTarget.type[0] === slamColor) continue;
                                    dealDamage(r, c, 30);
                                }
                            }
                        }
                        setTimeout(() => {
                            switchTurn();
                            clearSelection();
                            renderBoard();
                            checkGameEnd();
                        }, 300);
                    }, 200);
                    return;

                case 'k':
                    createShieldEffect(fromRow, fromCol);
                    setTimeout(() => {
                        if (piece) piece.shield = 50;
                        const kingColor = piece.type[0];
                        const opponentColor = kingColor === 'w' ? 'b' : 'w';

                        for (let r = 0; r < 8; r++) {
                            for (let c = 0; c < 8; c++) {
                                const enemyPiece = board[r][c];
                                if (enemyPiece && enemyPiece.type[0] === opponentColor) {
                                    const type = enemyPiece.type[1];
                                    let canAttack = false;

                                    switch (type) {
                                        case 'p':
                                            const dir = opponentColor === 'w' ? -1 : 1;
                                            canAttack = Math.abs(fromCol - c) === 1 && fromRow === r + dir;
                                            break;
                                        case 'r':
                                            canAttack = isValidRookMove(r, c, fromRow, fromCol);
                                            break;
                                        case 'n':
                                            canAttack = isValidKnightMove(r, c, fromRow, fromCol);
                                            break;
                                        case 'b':
                                            canAttack = isValidBishopMove(r, c, fromRow, fromCol);
                                            break;
                                        case 'q':
                                            canAttack = isValidQueenMove(r, c, fromRow, fromCol);
                                            break;
                                        case 'k':
                                            canAttack = isValidKingMove(r, c, fromRow, fromCol);
                                            break;
                                        case 'w':
                                            canAttack = isValidBishopMove(r, c, fromRow, fromCol) &&
                                                      Math.max(Math.abs(fromRow - r), Math.abs(fromCol - c)) <= 3;
                                            break;
                                        case 'd':
                                            canAttack = isValidQueenMove(r, c, fromRow, fromCol) &&
                                                      Math.max(Math.abs(fromRow - r), Math.abs(fromCol - c)) <= 4;
                                            break;
                                        case 's':
                                            canAttack = isValidKnightMove(r, c, fromRow, fromCol);
                                            break;
                                        default:
                                            canAttack = Math.abs(fromRow - r) <= 1 && Math.abs(fromCol - c) <= 1;
                                    }

                                    if (canAttack) {
                                        dealDamage(r, c, 100);
                                    }
                                }
                            }
                        }

                        clearSelection();
                        renderBoard();

                        const csColor = kingColor;
                        const csHasLegalMoves = getAllValidMoves(csColor).length > 0;
                        const csStillInCheck = isKingInCheck(csColor);

                        if (csStillInCheck && !csHasLegalMoves) {
                            const csWinner = csColor === 'w' ? 'BLACK' : 'WHITE';
                            endGame(csWinner, false);
                        } else {
                            switchTurn();
                            renderBoard();
                            checkGameEnd();
                        }
                    }, 500);
                    return;

                case 'w':
                    const targetPieceW = board[toRow][toCol];
                    if (targetPieceW) {
                        targetPieceW.abilityUsed = false;
                        createHealEffect(toRow, toCol);
                    }
                    switchTurn();
                    clearSelection();
                    renderBoard();
                    checkGameEnd();
                    return;

                case 'g':
                    const gColor = piece.type[0];
                    const lizard = createPiece(gColor + 'l');
                    board[toRow][toCol] = lizard;
                    piece.abilityUsed = true;
                    switchTurn();
                    clearSelection();
                    renderBoard();
                    checkGameEnd();
                    return;

                case 'l':
                    const targetPieceL = board[toRow][toCol];
                    if (targetPieceL) {
                        targetPieceL.lizardAttached = true;
                        board[fromRow][fromCol] = null;
                    }
                    switchTurn();
                    clearSelection();
                    renderBoard();
                    checkGameEnd();
                    return;

                case 't':
                    createShieldEffect(fromRow, fromCol);
                    setTimeout(() => {
                        for (let r = fromRow - 2; r <= fromRow + 2; r++) {
                            for (let c = fromCol - 2; c <= fromCol + 2; c++) {
                                if (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c]) {
                                    const p = board[r][c];
                                    if (p.type[0] === piece.type[0]) {
                                        p.shield = (p.shield || 0) + 30;
                                        createShieldEffect(r, c);
                                    }
                                }
                            }
                        }
                        switchTurn();
                        clearSelection();
                        renderBoard();
                        checkGameEnd();
                    }, 500);
                    return;

                case 's':
                    createSlashEffect(toRow, toCol);
                    setTimeout(() => {
                        dealDamage(toRow, toCol, 40);
                        switchTurn();
                        clearSelection();
                        renderBoard();
                        checkGameEnd();
                    }, 300);
                    return;

                case 'd':
                    createFireBreath(toRow, toCol);
                    setTimeout(() => {
                        const breathColor = piece.type[0];
                        for (let r = toRow - 1; r <= toRow + 1; r++) {
                            for (let c = toCol - 1; c <= toCol + 1; c++) {
                                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                                    const breathTarget = board[r][c];
                                    if (breathTarget && breathTarget.type[0] === breathColor) continue;
                                    dealDamage(r, c, 50);
                                    createExplosion(r, c);
                                }
                            }
                        }
                        switchTurn();
                        clearSelection();
                        renderBoard();
                        checkGameEnd();
                    }, 600);
                    return;

                case 'x':
                    if (piece) {
                        const mineOwner = piece.type[0];
                        landmines.push({ row: toRow, col: toCol, owner: mineOwner });
                        createExplosion(toRow, toCol);
                    }
                    switchTurn();
                    clearSelection();
                    renderBoard();
                    checkGameEnd();
                    return;

                case 'h':
                    const targetPieceH = board[toRow][toCol];
                    if (targetPieceH && piece) {
                        piece.stolenSoul = targetPieceH.type[1];
                        createTeleportEffect(fromRow, fromCol);
                        createTeleportEffect(toRow, toCol);
                        setTimeout(() => {
                            board[toRow][toCol] = null;
                            switchTurn();
                            clearSelection();
                            renderBoard();
                            checkGameEnd();
                        }, 500);
                    } else {
                        switchTurn();
                        clearSelection();
                        renderBoard();
                        checkGameEnd();
                    }
                    return;
            }

            switchTurn();
            clearSelection();
            renderBoard();
            checkGameEnd();
        }

        // ====== PAWN PROMOTION ======
        function showPromotionDialog(row, col, color) {
            const overlay = document.getElementById('promotion-overlay');
            const choices = document.getElementById('promotion-choices');
            choices.innerHTML = '';

            const options = [
                { type: 'q', symbol: color === 'w' ? '♕' : '♛', name: 'Queen' },
                { type: 'r', symbol: color === 'w' ? '♖' : '♜', name: 'Rook' },
                { type: 'n', symbol: color === 'w' ? '♘' : '♞', name: 'Knight' },
                { type: 'b', symbol: color === 'w' ? '♗' : '♝', name: 'Bishop' }
            ];

            options.forEach(opt => {
                const wrapper = document.createElement('div');
                wrapper.className = 'promotion-choice-wrapper';

                const btn = document.createElement('div');
                btn.className = 'promotion-choice';
                btn.textContent = opt.symbol;
                btn.addEventListener('click', () => {
                    overlay.classList.add('hidden');
                    sendOnlineAction({action:'promote', row, col, newType: opt.type});
                    promotePawn(row, col, opt.type);
                    switchTurn();
                    applyPoisonDamage();
                    renderBoard();
                    checkGameEnd();
                });

                const label = document.createElement('div');
                label.className = 'promotion-choice-label';
                label.textContent = opt.name;

                wrapper.appendChild(btn);
                wrapper.appendChild(label);
                choices.appendChild(wrapper);
            });

            overlay.classList.remove('hidden');
        }

        function promotePawn(row, col, newType) {
            const pawn = board[row][col];
            if (!pawn) return;
            const color = pawn.type[0];
            const promoted = createPiece(color + newType);
            promoted.abilityUsed = false;
            board[row][col] = promoted;
        }

        // ====== DAMAGE & EFFECTS ======
        function dealDamage(row, col, damage) {
            const piece = board[row][col];
            if (!piece) return false;

            if (piece.shield && piece.shield > 0) {
                if (piece.shield >= damage) {
                    piece.shield -= damage;
                    return false;
                } else {
                    damage -= piece.shield;
                    piece.shield = 0;
                }
            }

            piece.health -= damage;
            createExplosion(row, col);

            if (piece.health <= 0) {
                if (piece.type[1] === 'k') {
                    const winner = piece.type[0] === 'w' ? 'BLACK' : 'WHITE';
                    setTimeout(() => {
                        board[row][col] = null;
                        renderBoard();
                        endGame(winner, piece.type[0] === 'b');
                    }, 300);
                    return true;
                }
                board[row][col] = null;
                return true;
            }
            return false;
        }

        function createExplosion(row, col) {
            const square = document.querySelector(`#board [data-row="${row}"][data-col="${col}"]`);
            if (!square) return;
            const explosion = document.createElement('div');
            explosion.className = 'explosion';
            explosion.textContent = '💥';
            square.appendChild(explosion);
            setTimeout(() => explosion.remove(), 600);
        }

        function createShockwave(row, col) {
            const square = document.querySelector(`#board [data-row="${row}"][data-col="${col}"]`);
            if (!square) return;
            const shockwave = document.createElement('div');
            shockwave.className = 'shockwave';
            shockwave.style.left = '50%';
            shockwave.style.top = '50%';
            shockwave.style.transform = 'translate(-50%, -50%)';
            square.appendChild(shockwave);
            setTimeout(() => shockwave.remove(), 600);
        }

        function animateProjectile(fromRow, fromCol, toRow, toCol, type, callback) {
            const boardEl = document.getElementById('board');
            const boardRect = boardEl.getBoundingClientRect();
            const squareSize = boardRect.width / 8;

            const startX = fromCol * squareSize + squareSize / 2;
            const startY = fromRow * squareSize + squareSize / 2;
            const endX = toCol * squareSize + squareSize / 2;
            const endY = toRow * squareSize + squareSize / 2;

            const projectile = document.createElement('div');

            if (type === 'bullet') {
                projectile.className = 'bullet';
            } else if (type === 'arrow') {
                projectile.className = 'arrow';
                const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;
                projectile.style.transform = `rotate(${angle}deg)`;
            } else if (type === 'fireball') {
                projectile.className = 'fireball';
            } else if (type === 'cannonball') {
                projectile.style.width = '15px';
                projectile.style.height = '15px';
                projectile.style.background = 'radial-gradient(circle, #ff6600, #cc3300)';
                projectile.style.borderRadius = '50%';
                projectile.style.boxShadow = '0 0 15px #ff6600';
                projectile.style.position = 'absolute';
                projectile.style.zIndex = '100';
            }

            projectile.style.position = 'absolute';
            projectile.style.left = startX + 'px';
            projectile.style.top = startY + 'px';
            projectile.style.zIndex = '100';
            boardEl.appendChild(projectile);

            const distance = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
            const duration = distance * 1.5;

            const animation = projectile.animate([
                { left: startX + 'px', top: startY + 'px' },
                { left: endX + 'px', top: endY + 'px' }
            ], {
                duration: duration,
                easing: 'linear'
            });

            animation.onfinish = () => {
                projectile.remove();
                callback();
            };
        }

        function createHealEffect(row, col) {
            const square = document.querySelector(`#board [data-row="${row}"][data-col="${col}"]`);
            if (!square) return;
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const heal = document.createElement('div');
                    heal.className = 'heal-effect';
                    heal.textContent = '✨';
                    heal.style.left = Math.random() * 80 + 10 + '%';
                    heal.style.top = Math.random() * 80 + 10 + '%';
                    square.appendChild(heal);
                    setTimeout(() => heal.remove(), 1000);
                }, i * 100);
            }
        }

        function createTeleportEffect(row, col) {
            const square = document.querySelector(`#board [data-row="${row}"][data-col="${col}"]`);
            if (!square) return;
            const teleport = document.createElement('div');
            teleport.className = 'teleport-effect';
            teleport.textContent = '🔮';
            teleport.style.left = '50%';
            teleport.style.top = '50%';
            teleport.style.transform = 'translate(-50%, -50%)';
            square.appendChild(teleport);
            setTimeout(() => teleport.remove(), 800);
        }

        function createSlashEffect(row, col) {
            const square = document.querySelector(`#board [data-row="${row}"][data-col="${col}"]`);
            if (!square) return;
            const slash = document.createElement('div');
            slash.className = 'slash-effect';
            slash.textContent = '⚔️';
            slash.style.left = '50%';
            slash.style.top = '50%';
            slash.style.transform = 'translate(-50%, -50%)';
            square.appendChild(slash);
            setTimeout(() => slash.remove(), 400);
        }

        function createShieldEffect(row, col) {
            const square = document.querySelector(`#board [data-row="${row}"][data-col="${col}"]`);
            if (!square) return;
            const shield = document.createElement('div');
            shield.className = 'shield-effect';
            shield.style.left = '50%';
            shield.style.top = '50%';
            shield.style.transform = 'translate(-50%, -50%)';
            square.appendChild(shield);
            setTimeout(() => shield.remove(), 800);
        }

        function createFireBreath(row, col) {
            const square = document.querySelector(`#board [data-row="${row}"][data-col="${col}"]`);
            if (!square) return;
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const fire = document.createElement('div');
                    fire.className = 'fire-breath';
                    fire.textContent = '🔥';
                    fire.style.left = Math.random() * 60 + 20 + '%';
                    fire.style.top = Math.random() * 60 + 20 + '%';
                    square.appendChild(fire);
                    setTimeout(() => fire.remove(), 800);
                }, i * 150);
            }
        }

        // ====== GAME STATE ======
        function applyPoisonDamage() {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.lizardAttached) {
                        dealDamage(row, col, 10);
                        const poisonedColor = piece.type[0];
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const r = row + dr;
                                const c = col + dc;
                                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                                    const target = board[r][c];
                                    if (target && target.type[0] === poisonedColor) {
                                        dealDamage(r, c, 10);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        function switchTurn() {
            currentTurn = currentTurn === 'white' ? 'black' : 'white';
            updateTurnIndicator();
        }

        function calculateMaterialScore() {
            const materialValues = {
                'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9,
                'w': 5, 'g': 3, 'l': 8, 't': 7, 's': 3, 'd': 9, 'h': 1, 'x': 4
            };

            let whiteScore = 0;
            let blackScore = 0;

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.type[1] !== 'k') {
                        const value = materialValues[piece.type[1]] || 1;
                        if (piece.type[0] === 'w') {
                            whiteScore += value;
                        } else {
                            blackScore += value;
                        }
                    }
                }
            }

            document.getElementById('white-score').textContent = whiteScore;
            document.getElementById('black-score').textContent = blackScore;
        }

        function updateTurnIndicator() {
            const indicator = document.getElementById('turn-display');
            const color = currentTurn === 'white' ? 'w' : 'b';
            const inCheck = isKingInCheck(color);

            let turnText = currentTurn === 'white' ? '⬜ White\'s Turn' : '⬛ Black\'s Turn';
            if (gameMode === 'online') {
                turnText += isMyTurnOnline() ? ' (YOUR TURN)' : ' (Waiting...)';
            }

            if (inCheck) {
                indicator.textContent = turnText + ' ⚠️ CHECK!';
                indicator.style.color = '#ff0044';
                indicator.style.animation = 'checkPulse 0.5s ease-in-out infinite';
            } else {
                indicator.textContent = turnText;
                indicator.style.color = isMyTurnOnline() ? '#ffd700' : '#aaa';
                indicator.style.animation = 'turnGlow 2s ease-in-out infinite';
            }
        }

        function checkGameEnd() {
            let whiteKing = false;
            let blackKing = false;
            let totalPieces = 0;

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        totalPieces++;
                        if (piece.type[1] === 'k') {
                            if (piece.type[0] === 'w') whiteKing = true;
                            if (piece.type[0] === 'b') blackKing = true;
                        }
                    }
                }
            }

            if (!whiteKing) {
                endGame('BLACK', false);
                return;
            } else if (!blackKing) {
                endGame('WHITE', true);
                return;
            }

            if (totalPieces === 2 && whiteKing && blackKing) {
                endGame('DRAW', null);
                return;
            }

            const currentColor = currentTurn === 'white' ? 'w' : 'b';
            const hasLegalMoves = getAllValidMoves(currentColor).length > 0;

            if (!hasLegalMoves) {
                if (isKingInCheck(currentColor)) {
                    const kingPos = findKing(currentColor);
                    const king = kingPos ? board[kingPos.row][kingPos.col] : null;
                    if (king && !king.abilityUsed) {
                        showMessage('⚠️ CHECKMATE INCOMING!', 'Use your King\'s Counter-Strike ability! (double-click your King)');
                        setTimeout(hideMessage, 3000);
                        return;
                    }
                    const winner = currentTurn === 'white' ? 'BLACK' : 'WHITE';
                    endGame(winner, currentTurn === 'white' ? false : true);
                } else {
                    endGame('DRAW', null);
                }
            }
        }

        function endGame(winner, playerWon) {
            gameActive = false;
            stopRankedTimer();

            // In ranked mode, player is ALWAYS white — derive win from winner string
            if (rankedMode && winner !== 'DRAW') {
                const actuallyWon = (winner === 'WHITE');
                showRankedResults(actuallyWon);
            } else {
                if (winner === 'DRAW') {
                    showMessage('DRAW!', 'The game has ended in a draw.');
                } else {
                    showMessage(`${winner} WINS! 🏆`, `Game Over!`, true);
                }
            }
        }

        function showMessage(title, text, showButton) {
            document.getElementById('message-title').textContent = title;
            document.getElementById('message-text').textContent = text;
            document.getElementById('play-again-btn').style.display = showButton ? 'block' : 'none';
            document.getElementById('game-message').classList.add('show');
        }

        function hideMessage() {
            document.getElementById('game-message').classList.remove('show');
        }

        function resetGame() {
            document.getElementById('ranked-results-overlay').classList.add('hidden');
            if (rankedMode) {
                currentTurn = 'white';
                gameActive = true;
                activeAbility = null;
                selectedSquare = null;
                isAIThinking = false;
                landmines = [];
                initStandardBoard();
                startRankedTimer();
                renderBoard();
                hideMessage();
            } else {
                currentTurn = 'white';
                gameActive = true;
                activeAbility = null;
                selectedSquare = null;
                isAIThinking = false;
                landmines = [];
                initStandardBoard();
                renderBoard();
                hideMessage();
            }
        }

        function newGame() {
            stopRankedTimer();
            gameActive = false;
            gameMode = 'pvp';
            currentTurn = 'white';
            activeAbility = null;
            selectedSquare = null;
            isAIThinking = false;
            landmines = [];
            rankedMode = false;
            myColor = null;
            myPlayerNumber = null;

            // Close online connection if open
            if (ws) { ws.close(); ws = null; onlineConnected = false; }
            document.getElementById('online-lobby-overlay').classList.add('hidden');

            board = Array(8).fill(null).map(() => Array(8).fill(null));
            hideMessage();
            document.getElementById('ranked-results-overlay').classList.add('hidden');
            renderBoard();

            document.getElementById('pvp-btn').classList.remove('selected');
            document.getElementById('pvc-btn').classList.remove('selected');
            document.getElementById('ranked-btn').classList.remove('selected');
            document.getElementById('online-btn').classList.remove('selected');
            document.getElementById('ai-difficulty-section').style.display = 'none';
            document.getElementById('ranked-info-section').style.display = 'none';
            document.getElementById('online-info-section').style.display = 'none';
            document.getElementById('start-game-btn').style.display = 'none';
            document.getElementById('ranked-hud').classList.remove('active');

            document.getElementById('mode-selector').classList.remove('hidden');
        }

        // ====== TUTORIAL SYSTEM ======
        let tutorialStep = 0;

        const TUTORIAL_STEPS = [
            {
                title: "Welcome to Chess Warfare!",
                content: `
                    <p>This isn't regular chess — it's chess with <span class="highlight">health bars, special abilities, and custom pieces</span>!</p>
                    <p>Every piece has HP and a unique ability. Your goal is still to destroy the enemy King, but now you can do it through <span class="highlight">checkmate OR by draining their HP to zero</span>.</p>
                    <div class="tutorial-tip">💡 Don't worry if you've never played chess before — this tutorial will teach you everything step by step!</div>
                `
            },
            {
                title: "The Board & Moving Pieces",
                content: `
                    <p>The board is an 8×8 grid. You play as <span class="highlight">White</span> (bottom) and move first.</p>
                    <p>To move a piece:</p>
                    <p>1. <span class="highlight">Click</span> one of your pieces — it highlights yellow</p>
                    <p>2. <span class="highlight">Green squares</span> appear showing where you can move</p>
                    <p>3. <span class="highlight">Click a green square</span> to move there</p>
                    <div class="tutorial-visual">
                        <div class="demo-board">
                            <div class="demo-sq lt"></div><div class="demo-sq dk"></div><div class="demo-sq lt"></div><div class="demo-sq dk"></div>
                            <div class="demo-sq dk"></div><div class="demo-sq lt"></div><div class="demo-sq dk mv"></div><div class="demo-sq lt"></div>
                            <div class="demo-sq lt mv"></div><div class="demo-sq dk"></div><div class="demo-sq sel">♘</div><div class="demo-sq dk"></div>
                            <div class="demo-sq dk"></div><div class="demo-sq lt mv"></div><div class="demo-sq dk"></div><div class="demo-sq lt mv"></div>
                        </div>
                        <div class="demo-caption">A Knight is selected (yellow) — green squares show where it can jump</div>
                    </div>
                    <div class="tutorial-tip">💡 If you click the wrong piece, just click a different one to switch.</div>
                `
            },
            {
                title: "Standard Chess Pieces",
                content: `
                    <p>Each piece moves differently:</p>
                    <div class="tutorial-pieces-grid">
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♔</div>
                            <div class="tp-name">King</div>
                            <div class="tp-desc">1 square any direction. 250 HP. Protect him at all costs!</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♕</div>
                            <div class="tp-name">Queen</div>
                            <div class="tp-desc">Any direction, any distance. 120 HP. Your strongest piece.</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♖</div>
                            <div class="tp-name">Rook</div>
                            <div class="tp-desc">Straight lines (up/down/left/right). 75 HP.</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♗</div>
                            <div class="tp-name">Bishop</div>
                            <div class="tp-desc">Diagonal lines only. 75 HP.</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♘</div>
                            <div class="tp-name">Knight</div>
                            <div class="tp-desc">L-shape jumps (can hop over pieces). 75 HP.</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♙</div>
                            <div class="tp-name">Pawn</div>
                            <div class="tp-desc">Forward 1 (or 2 from start). Captures diagonally. 30 HP.</div>
                        </div>
                    </div>
                    <div class="tutorial-tip">💡 Move onto an enemy piece to capture it — they take damage or get removed!</div>
                `
            },
            {
                title: "Health Bars & Damage",
                content: `
                    <p>Every piece has a <span class="highlight">health bar</span> shown under it. Unlike normal chess, pieces don't always die in one hit!</p>
                    <p>When you move onto an enemy piece, you <span class="highlight">capture</span> it (removes it). But abilities deal <span class="highlight">damage</span> instead — the piece loses HP and only dies when it hits 0.</p>
                    <div class="tutorial-visual">
                        <div style="display: flex; justify-content: center; gap: 30px; align-items: center; font-size: 1.3em;">
                            <div style="text-align: center;">
                                <div style="font-size: 2em;">♖</div>
                                <div style="width: 60px; height: 6px; background: #333; border-radius: 3px; margin: 5px auto;">
                                    <div style="width: 100%; height: 100%; background: linear-gradient(90deg, #ff0, #0f0); border-radius: 3px;"></div>
                                </div>
                                <div style="color: #4CAF50; font-size: 0.7em;">75/75 HP</div>
                            </div>
                            <div style="color: #ffd700; font-size: 1.5em;">→ 💥 →</div>
                            <div style="text-align: center;">
                                <div style="font-size: 2em;">♖</div>
                                <div style="width: 60px; height: 6px; background: #333; border-radius: 3px; margin: 5px auto;">
                                    <div style="width: 53%; height: 100%; background: linear-gradient(90deg, #f00, #ff0); border-radius: 3px;"></div>
                                </div>
                                <div style="color: #ff6b6b; font-size: 0.7em;">40/75 HP</div>
                            </div>
                        </div>
                        <div class="demo-caption">A Rook takes 35 damage from a Cannon ability — it survives with 40 HP!</div>
                    </div>
                    <p>The <span class="highlight">King has 250 HP</span> — the most of any piece. You win by either checkmating the King OR reducing it to 0 HP.</p>
                `
            },
            {
                title: "Special Abilities ⚡",
                content: `
                    <p>This is what makes Chess Warfare unique! Every piece has a <span class="highlight">one-time special ability</span>.</p>
                    <p>To use an ability:</p>
                    <p>1. <span class="highlight">Double-click</span> your piece (the ⚡ icon means it's available)</p>
                    <p>2. <span class="highlight">Red squares</span> appear showing valid targets</p>
                    <p>3. <span class="highlight">Click a red square</span> to use the ability</p>
                    <div class="tutorial-pieces-grid">
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♙</div>
                            <div class="tp-name">Pawn: Shoot</div>
                            <div class="tp-desc">Fire a bullet forward for 20 damage</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♖</div>
                            <div class="tp-name">Rook: Cannon</div>
                            <div class="tp-desc">Fire a cannonball for 35 damage</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♘</div>
                            <div class="tp-name">Knight: Slam</div>
                            <div class="tp-desc">Jump and deal 30 dmg in a 3×3 area</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♗</div>
                            <div class="tp-name">Bishop: Swap</div>
                            <div class="tp-desc">Teleport-swap with an enemy piece</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♕</div>
                            <div class="tp-name">Queen: Heal</div>
                            <div class="tp-desc">Restore 50 HP to a friendly piece</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♔</div>
                            <div class="tp-name">King: Counter</div>
                            <div class="tp-desc">Shield + 100 dmg to all attackers (only when in check!)</div>
                        </div>
                    </div>
                    <div class="tutorial-tip">⚠️ Each ability can only be used ONCE per game — use them wisely!</div>
                `
            },
            {
                title: "Check, Checkmate & Winning",
                content: `
                    <p><span class="highlight">Check:</span> When the enemy King is being attacked. The turn display will flash red with "CHECK!" — you must escape it.</p>
                    <p><span class="highlight">Checkmate:</span> The King is in check and has no legal moves to escape. Game over!</p>
                    <p><span class="highlight">Two ways to win:</span></p>
                    <p>1. ♟ <span class="highlight">Checkmate</span> — trap the King with no escape</p>
                    <p>2. 💥 <span class="highlight">Destroy the King</span> — reduce its HP to 0 with abilities</p>
                    <div class="tutorial-tip">💡 The King's Counter-Strike ability is a last resort — if you're checkmated but haven't used it yet, double-click your King for a chance to survive!</div>
                    <p><span class="highlight">Pawn Promotion:</span> If your Pawn reaches the opposite end of the board, you can upgrade it to a Queen, Rook, Knight, or Bishop!</p>
                `
            },
            {
                title: "Game Modes",
                content: `
                    <p>There are three ways to play:</p>
                    <p><span class="highlight">👥 Player vs Player</span> — Two players take turns on the same screen. Great for playing with a friend!</p>
                    <p><span class="highlight">🤖 Player vs Computer</span> — Play against the AI. Use the difficulty slider to set how hard it plays (1 = random moves, 100 = very smart).</p>
                    <p><span class="highlight">⚔️ Ranked Mode</span> — Competitive mode against the AI! You earn <span class="highlight">Ranked Points (RP)</span> for winning and climb through 8 tiers:</p>
                    <p style="text-align:center; font-size:0.9em; color:#ccc; line-height: 2;">
                        Bronze → Silver → Gold → Platinum → Emerald → Champion → Ultimate Champion → <span style="color:#dc143c; font-weight:bold;">Crimson</span>
                    </p>
                    <div class="tutorial-tip">💡 In Ranked, the AI gets harder every round. You earn 30-35 RP per win based on speed and how many pieces you keep alive. Losses cost 15 RP.</div>
                `
            },
            {
                title: "You're Ready!",
                content: `
                    <p>Here's a quick cheat sheet:</p>
                    <p>🖱️ <span class="highlight">Click</span> a piece to select it, then click a green square to move</p>
                    <p>🖱️🖱️ <span class="highlight">Double-click</span> a piece to activate its ability, then click a red target</p>
                    <p>⚡ Every piece has <span class="highlight">one ability</span> — use them at the right moment</p>
                    <p>❤️ Pieces have <span class="highlight">health bars</span> — abilities deal damage, captures remove pieces</p>
                    <p>👑 Win by <span class="highlight">checkmate or destroying the King's HP</span></p>
                    <div class="tutorial-tip">💡 Check the piece guide on the left side of the board during the game — it shows all abilities and stats!</div>
                    <p style="text-align: center; margin-top: 15px; color: #ffd700; font-size: 1.1em; font-weight: bold;">Good luck, Commander! ♟️</p>
                `
            }
        ];

        function openTutorial() {
            tutorialStep = 0;
            document.getElementById('tutorial-overlay').classList.remove('hidden');
            renderTutorialStep();
        }

        function closeTutorial() {
            document.getElementById('tutorial-overlay').classList.add('hidden');
        }

        function tutorialNext() {
            if (tutorialStep < TUTORIAL_STEPS.length - 1) {
                tutorialStep++;
                renderTutorialStep();
            } else {
                closeTutorial();
            }
        }

        function tutorialPrev() {
            if (tutorialStep > 0) {
                tutorialStep--;
                renderTutorialStep();
            }
        }

        function renderTutorialStep() {
            const step = TUTORIAL_STEPS[tutorialStep];
            const total = TUTORIAL_STEPS.length;

            document.getElementById('tutorial-step-counter').textContent = `STEP ${tutorialStep + 1} OF ${total}`;
            document.getElementById('tutorial-title').textContent = step.title;
            document.getElementById('tutorial-content').innerHTML = step.content;

            // Progress dots
            const dotsContainer = document.getElementById('tutorial-progress');
            dotsContainer.innerHTML = '';
            for (let i = 0; i < total; i++) {
                const dot = document.createElement('div');
                dot.className = 'tutorial-dot';
                if (i === tutorialStep) dot.classList.add('active');
                else if (i < tutorialStep) dot.classList.add('done');
                dotsContainer.appendChild(dot);
            }

            // Button states
            document.getElementById('tutorial-back').disabled = (tutorialStep === 0);
            document.getElementById('tutorial-next').textContent =
                tutorialStep === total - 1 ? "Let's Play!" : 'Next';
        }

        window.onload = function() {
            initRankedInfoDisplay();
            document.getElementById('mode-selector').classList.remove('hidden');
            document.getElementById('lobby-code-input').addEventListener('keyup', (e) => {
                if (e.key === 'Enter') onlineJoinRoom();
            });
        };
    </script>

</body></html>