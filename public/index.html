<!DOCTYPE html>
<!-- saved from url=(0051)file:///Users/lindseylister/Downloads/index_17.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Warfare</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        html {
            -webkit-text-size-adjust: 100%;
            -moz-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
            touch-action: manipulation;
            width: 100%;
            position: relative;
        }

        .container {
            max-width: 1100px;
            margin: 0 auto;
        }

        .game-layout {
            display: flex;
            gap: 15px;
            align-items: flex-start;
            justify-content: center;
            flex-wrap: wrap;
        }

        h1 {
            text-align: center;
            color: #fff;
            font-size: 2.5em;
            margin: 10px 0;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 20px rgba(255, 255, 255, 0.5); }
            to { text-shadow: 0 0 30px rgba(255, 255, 255, 0.8); }
        }

        .battle-title {
            text-align: center;
            color: #ff6b6b;
            font-size: 1.5em;
            margin-bottom: 10px;
            font-weight: bold;
            text-shadow: 0 0 15px #ff6b6b;
            animation: battleGlow 1s ease-in-out infinite alternate;
        }

        @keyframes battleGlow {
            from { text-shadow: 0 0 15px #ff6b6b; }
            to { text-shadow: 0 0 25px #ff6b6b, 0 0 35px #ff3333; }
        }


        .turn-display {
            font-size: 1.8em;
            font-weight: bold;
            text-align: center;
            color: #ffd700;
            text-shadow: 0 0 15px #ffd700, 0 0 30px #ffd700;
            padding: 15px;
            margin-bottom: 15px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.1));
            border-radius: 15px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            animation: turnGlow 2s ease-in-out infinite;
        }

        @keyframes turnGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }
            50% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.6); }
        }

        .online-lobby-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); z-index: 10000;
            display: flex; align-items: center; justify-content: center;
        }
        .online-lobby-overlay.hidden { display: none; }
        .online-lobby {
            background: linear-gradient(135deg, #1a1a3e, #2a2a5e);
            border: 2px solid #ffd700; border-radius: 20px;
            padding: 30px; text-align: center; max-width: 420px; width: 90%;
        }
        .online-lobby h2 { color: #ffd700; margin-bottom: 20px; font-size: 1.5em; }
        .online-lobby .lobby-status {
            padding: 8px 16px; border-radius: 20px; font-size: 13px;
            font-weight: bold; display: inline-block; margin-bottom: 20px;
        }
        .lobby-status.connecting { background: #533483; color: #ccc; }
        .lobby-status.connected { background: #1b5e20; color: #a5d6a7; }
        .lobby-status.disconnected { background: #b71c1c; color: #ef9a9a; }
        .online-lobby .lobby-btn {
            padding: 12px 30px; font-size: 18px; border: none;
            border-radius: 8px; cursor: pointer; margin: 8px;
            font-weight: bold; transition: transform 0.1s;
        }
        .online-lobby .lobby-btn:active { transform: scale(0.95); }
        .online-lobby .lobby-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .lobby-btn-create { background: #e94560; color: white; }
        .lobby-btn-join { background: #0f3460; color: white; }
        .lobby-btn-back { background: #555; color: white; margin-top: 15px; }
        .online-lobby input {
            padding: 12px; font-size: 20px; border-radius: 8px;
            border: 2px solid #0f3460; text-align: center; width: 140px;
            text-transform: uppercase; background: #16213e; color: #eee;
            letter-spacing: 5px;
        }
        .lobby-room-code {
            font-size: 52px; font-weight: bold; color: #e94560;
            letter-spacing: 12px; margin: 20px 0;
            text-shadow: 0 0 20px rgba(233,69,96,0.5);
        }
        .lobby-waiting { color: #aaa; font-size: 16px; animation: lobbyPulse 1.5s ease-in-out infinite; }
        @keyframes lobbyPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .online-player-badge {
            display: inline-block; background: #533483; color: #fff;
            padding: 4px 12px; border-radius: 15px; font-size: 12px;
            margin-bottom: 10px;
        }

        .score-display {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 10px;
            margin-bottom: 15px;
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.2), rgba(33, 150, 243, 0.2));
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        .score-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .score-label {
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .score-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
        }

        .board-container {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            padding: 15px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 3px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            margin-bottom: 15px;
            position: relative;
            width: 100%;
            max-width: 530px;
            margin-left: auto;
            margin-right: auto;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            width: 90vw;
            max-width: 500px;
            height: 90vw;
            max-height: 500px;
            margin: 0 auto;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.5em, 4.5vw, 2.2em);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            min-height: 40px;
        }

        .square.light {
            background: linear-gradient(135deg, #e8e8ff 0%, #d0d0ff 100%);
        }

        .square.dark {
            background: linear-gradient(135deg, #4a4a7a 0%, #35355a 100%);
        }

        .square.selected {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%) !important;
            box-shadow: inset 0 0 20px rgba(255, 215, 0, 0.8);
            animation: pulse 0.8s ease-in-out infinite;
        }

        .square.legal-move {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%) !important;
        }

        .square.legal-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            background: rgba(0, 255, 136, 0.5);
            border-radius: 50%;
        }

        .square.ability-target {
            background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%) !important;
            animation: targetPulse 0.5s ease-in-out infinite;
        }

        @keyframes targetPulse {
            0%, 100% { box-shadow: inset 0 0 20px rgba(255, 68, 68, 0.8); }
            50% { box-shadow: inset 0 0 30px rgba(255, 68, 68, 1); }
        }

        .square.in-check {
            background: linear-gradient(135deg, #ff0044 0%, #cc0033 100%) !important;
            animation: checkPulse 0.5s ease-in-out infinite;
        }

        @keyframes checkPulse {
            0%, 100% {
                box-shadow: inset 0 0 20px rgba(255, 0, 68, 0.8);
            }
            50% {
                box-shadow: inset 0 0 30px rgba(255, 0, 68, 1), 0 0 20px rgba(255, 0, 68, 0.8);
            }
        }

        .piece {
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.9));
            transition: all 0.3s ease;
            position: relative;
            z-index: 10;
            animation: pieceFloat 3s ease-in-out infinite;
            line-height: 1;
            width: 80%;
            height: 80%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .piece.custom-wizard {
            background: radial-gradient(circle, rgba(138, 43, 226, 0.4), transparent);
            padding: 3px;
            border-radius: 50%;
        }

        .piece.custom-grandpa {
            background: radial-gradient(circle, rgba(139, 69, 19, 0.4), transparent);
            padding: 3px;
            border-radius: 50%;
        }

        .piece.custom-tank {
            background: radial-gradient(circle, rgba(128, 128, 128, 0.4), transparent);
            padding: 3px;
            border-radius: 50%;
        }

        .piece.custom-assassin {
            background: radial-gradient(circle, rgba(220, 20, 60, 0.4), transparent);
            padding: 3px;
            border-radius: 50%;
        }

        .piece.custom-dragon {
            background: radial-gradient(circle, rgba(255, 140, 0, 0.4), transparent);
            padding: 3px;
            border-radius: 50%;
        }

        .piece.custom-lizard {
            background: radial-gradient(circle, rgba(34, 139, 34, 0.5), transparent);
            padding: 3px;
            border-radius: 50%;
            animation: lizardWiggle 0.5s ease-in-out infinite;
        }

        .piece.custom-ghost {
            background: radial-gradient(circle, rgba(200, 200, 255, 0.3), transparent);
            padding: 3px;
            border-radius: 50%;
            animation: ghostFloat 2s ease-in-out infinite;
            opacity: 0.9;
        }

        @keyframes ghostFloat {
            0%, 100% { transform: translateY(0px); opacity: 0.9; }
            50% { transform: translateY(-5px); opacity: 0.7; }
        }

        .piece.custom-saboteur {
            background: radial-gradient(circle, rgba(50, 50, 50, 0.4), transparent);
            padding: 3px;
            border-radius: 50%;
            filter: drop-shadow(0 0 5px rgba(255, 100, 0, 0.5));
        }

        .landmine-indicator {
            font-size: 1.5em;
            animation: mineFlash 1.5s ease-in-out infinite;
        }

        @keyframes mineFlash {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        @keyframes lizardWiggle {
            0%, 100% { transform: translateY(0px) rotate(-2deg); }
            50% { transform: translateY(-2px) rotate(2deg); }
        }

        @keyframes pieceFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-3px); }
        }

        .piece:hover {
            transform: scale(1.05) translateY(-2px);
            filter: drop-shadow(0 10px 15px rgba(0, 0, 0, 1));
        }

        .piece::after {
            content: attr(data-tooltip);
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 0.5em;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 10000;
            border: 1px solid #4CAF50;
            font-weight: bold;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
        }

        .piece:hover::after {
            opacity: 1;
        }

        .health-bar-container {
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 4px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 2px;
            overflow: hidden;
        }

        .health-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff0000 0%, #ffff00 50%, #00ff00 100%);
            transition: width 0.3s ease;
            border-radius: 2px;
        }

        .ability-indicator {
            position: absolute;
            top: -3px;
            left: -3px;
            font-size: 0.4em;
            z-index: 15;
            filter: drop-shadow(0 0 3px #ffd700);
            animation: abilityPulse 2s ease-in-out infinite;
        }

        @keyframes abilityPulse {
            0%, 100% { transform: scale(1) rotate(-10deg); }
            50% { transform: scale(1.15) rotate(10deg); }
        }

        .lizard-indicator {
            position: absolute;
            top: -3px;
            right: -3px;
            font-size: 0.4em;
            z-index: 15;
            filter: drop-shadow(0 0 3px #00ff00);
            animation: lizardWiggle 0.5s ease-in-out infinite;
        }

        .shield-indicator {
            position: absolute;
            bottom: 8px;
            right: -2px;
            font-size: 0.4em;
            z-index: 15;
            filter: drop-shadow(0 0 5px #00ffff);
            animation: shieldGlow 1.5s ease-in-out infinite;
        }

        @keyframes shieldGlow {
            0%, 100% { filter: drop-shadow(0 0 5px #00ffff); transform: scale(1); }
            50% { filter: drop-shadow(0 0 10px #00ffff); transform: scale(1.15); }
        }

        .shield-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ccff, #00ffff);
            position: absolute;
            right: 0;
            top: 0;
            border-radius: 2px;
            opacity: 0.8;
        }

        .controls {
            text-align: center;
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 25px;
            font-size: 1em;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .reset-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .new-game-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        .promotion-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .promotion-overlay.hidden {
            display: none;
        }

        .promotion-dialog {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px 40px;
            border-radius: 20px;
            border: 4px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 15px 60px rgba(0, 0, 0, 0.6);
            text-align: center;
        }

        .promotion-dialog h2 {
            color: #fff;
            font-size: 1.8em;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        .promotion-choices {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .promotion-choice {
            width: 80px;
            height: 80px;
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.15);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .promotion-choice:hover {
            background: rgba(255, 215, 0, 0.3);
            border-color: #ffd700;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }

        .promotion-choice-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.7em;
            margin-top: 4px;
        }

        .promotion-choice-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .game-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 35px 45px;
            border-radius: 20px;
            box-shadow: 0 15px 60px rgba(0, 0, 0, 0.6);
            z-index: 1000;
            text-align: center;
            border: 4px solid rgba(255, 255, 255, 0.5);
            opacity: 0;
            transition: all 0.5s ease;
            max-width: 90%;
        }

        .game-message.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .game-message h2 {
            color: #fff;
            font-size: 2.2em;
            margin-bottom: 12px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
        }

        .game-message p {
            color: #fff;
            font-size: 1.2em;
            margin-bottom: 20px;
        }

        .mode-selector {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
        }

        .mode-selector.hidden {
            display: none;
        }

        .mode-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            border: 4px solid rgba(255, 255, 255, 0.5);
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            text-align: center;
        }

        .mode-content h2 {
            color: #fff;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
        }

        .mode-buttons {
            display: grid;
            gap: 15px;
            margin-bottom: 20px;
        }

        .mode-button {
            padding: 20px;
            font-size: 1.3em;
            font-weight: 600;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            transition: all 0.3s ease;
        }

        .mode-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
            border-color: #ffd700;
        }

        .mode-button.selected {
            background: rgba(255, 215, 0, 0.3);
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        #ai-difficulty-section {
            display: none;
            margin-top: 20px;
        }


        .difficulty-label {
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.2em;
            font-weight: 600;
        }

        .difficulty-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        #difficulty-slider {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            outline: none;
            cursor: pointer;
        }

        #difficulty-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            transition: all 0.2s ease;
        }

        #difficulty-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.8);
        }

        #difficulty-slider::-moz-range-thumb {
            width: 25px;
            height: 25px;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            transition: all 0.2s ease;
        }

        #difficulty-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.8);
        }

        #difficulty-value {
            color: #ffd700;
            font-size: 1.5em;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
            text-shadow: 0 0 10px #ffd700;
        }

        .difficulty-labels {
            display: flex;
            justify-content: space-between;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9em;
            margin-top: 8px;
        }


        #start-game-btn {
            display: none;
            padding: 18px 40px;
            font-size: 1.3em;
            font-weight: 600;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(79, 172, 254, 0.4);
            margin-top: 10px;
        }

        #start-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 30px rgba(79, 172, 254, 0.6);
        }

        .piece-reference-guide {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            padding: 15px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            width: 340px;
            flex-shrink: 0;
            order: -1;
        }

        .piece-reference-guide h3 {
            color: #ffd700;
            text-align: center;
            margin-bottom: 12px;
            font-size: 0.95em;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            line-height: 1.3;
        }

        .piece-reference-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .piece-ref-item {
            background: rgba(255, 255, 255, 0.08);
            padding: 8px 6px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            transition: all 0.3s ease;
            cursor: default;
        }

        .piece-ref-item:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .piece-ref-item.highlighted {
            background: rgba(255, 215, 0, 0.2);
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        .piece-ref-icon {
            width: 40px;
            height: 40px;
            margin: 0 auto 3px;
        }

        .piece-ref-name {
            color: #fff;
            font-weight: bold;
            font-size: 0.85em;
            margin-bottom: 2px;
        }

        .piece-ref-hp {
            color: #4CAF50;
            font-size: 0.75em;
            margin-bottom: 4px;
        }

        .piece-ref-ability {
            color: #ffeb3b;
            font-size: 0.72em;
            margin-top: 4px;
            padding-top: 4px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .piece-ref-ability-name {
            font-weight: bold;
            margin-bottom: 2px;
        }

        .piece-ref-ability-desc {
            font-size: 0.68em;
            line-height: 1.2;
            color: rgba(255, 235, 59, 0.8);
        }

        @media (max-width: 900px) {
            .game-layout {
                flex-direction: column;
                align-items: center;
            }
            .piece-reference-guide {
                width: 100%;
                max-width: 530px;
                order: 1;
            }
        }

        .explosion {
            position: absolute;
            font-size: 3em;
            z-index: 100;
            pointer-events: none;
            animation: explode 0.6s ease-out;
        }

        @keyframes explode {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        .shockwave {
            position: absolute;
            border: 4px solid #ffd700;
            border-radius: 50%;
            z-index: 100;
            pointer-events: none;
            animation: shockwaveExpand 0.6s ease-out;
        }

        @keyframes shockwaveExpand {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
            }
            100% {
                width: 300%;
                height: 300%;
                opacity: 0;
            }
        }

        .bullet {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ffff00;
            border-radius: 50%;
            box-shadow: 0 0 10px #ffff00;
            z-index: 100;
            pointer-events: none;
        }

        .arrow {
            position: absolute;
            width: 20px;
            height: 3px;
            background: linear-gradient(90deg, #8b4513, #cd853f);
            z-index: 100;
            pointer-events: none;
        }

        .arrow::before {
            content: '';
            position: absolute;
            right: -8px;
            top: -3px;
            width: 0;
            height: 0;
            border-left: 10px solid #cd853f;
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
        }

        .fireball {
            position: absolute;
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, #ff4500, #ff8c00);
            border-radius: 50%;
            box-shadow: 0 0 20px #ff4500;
            z-index: 100;
            pointer-events: none;
        }

        .heal-effect {
            position: absolute;
            font-size: 3em;
            z-index: 100;
            pointer-events: none;
            animation: healFloat 1s ease-out;
        }

        @keyframes healFloat {
            0% {
                transform: translateY(0) scale(0.5);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px) scale(1.5);
                opacity: 0;
            }
        }

        .teleport-effect {
            position: absolute;
            font-size: 4em;
            z-index: 100;
            pointer-events: none;
            animation: teleport 0.8s ease-out;
        }

        @keyframes teleport {
            0%, 100% { opacity: 0; transform: scale(0); }
            50% { opacity: 1; transform: scale(1.5); }
        }

        .slash-effect {
            position: absolute;
            font-size: 4em;
            z-index: 100;
            pointer-events: none;
            animation: slash 0.4s ease-out;
            color: #ff0000;
            text-shadow: 0 0 20px #ff0000;
        }

        @keyframes slash {
            0% {
                transform: translateX(-50px) rotate(-45deg) scale(0);
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: translateX(50px) rotate(-45deg) scale(1.5);
                opacity: 0;
            }
        }

        .shield-effect {
            position: absolute;
            border: 4px solid #00ffff;
            border-radius: 50%;
            z-index: 100;
            pointer-events: none;
            animation: shieldPulseEffect 0.8s ease-out;
        }

        @keyframes shieldPulseEffect {
            0% {
                width: 50%;
                height: 50%;
                opacity: 1;
            }
            100% {
                width: 150%;
                height: 150%;
                opacity: 0;
            }
        }

        .fire-breath {
            position: absolute;
            font-size: 3em;
            z-index: 100;
            pointer-events: none;
            animation: breatheFire 0.8s ease-out;
        }

        @keyframes breatheFire {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* ====== TUTORIAL OVERLAY ====== */
        .tutorial-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.92);
            z-index: 5000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            padding: 20px;
        }
        .tutorial-overlay.hidden { display: none; }

        .tutorial-box {
            background: linear-gradient(135deg, #1a1a3e 0%, #2d1b4e 50%, #1a1a3e 100%);
            border: 3px solid rgba(255, 215, 0, 0.6);
            border-radius: 25px;
            padding: 35px 40px;
            max-width: 650px;
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 0 60px rgba(255, 215, 0, 0.15), 0 20px 60px rgba(0,0,0,0.5);
            position: relative;
        }

        .tutorial-step-counter {
            text-align: center;
            color: rgba(255,215,0,0.6);
            font-size: 0.85em;
            margin-bottom: 8px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .tutorial-title {
            text-align: center;
            color: #ffd700;
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .tutorial-content {
            color: #e0e0e0;
            font-size: 1.05em;
            line-height: 1.7;
            margin-bottom: 25px;
        }

        .tutorial-content .highlight {
            color: #ffd700;
            font-weight: bold;
        }

        .tutorial-content .piece-demo {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: rgba(255,255,255,0.08);
            padding: 3px 10px;
            border-radius: 8px;
            margin: 2px 0;
        }

        .tutorial-content .piece-icon {
            font-size: 1.4em;
        }

        .tutorial-visual {
            background: rgba(0,0,0,0.35);
            border: 2px solid rgba(255,255,255,0.15);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0 20px 0;
            text-align: center;
        }

        .tutorial-visual .demo-board {
            display: inline-grid;
            grid-template-columns: repeat(4, 55px);
            grid-template-rows: repeat(4, 55px);
            gap: 2px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            overflow: hidden;
        }

        .tutorial-visual .demo-sq {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.6em;
        }

        .tutorial-visual .demo-sq.lt { background: linear-gradient(135deg, #e8e8ff, #d0d0ff); }
        .tutorial-visual .demo-sq.dk { background: linear-gradient(135deg, #4a4a7a, #35355a); }
        .tutorial-visual .demo-sq.sel { background: linear-gradient(135deg, #ffd700, #ffed4e) !important; box-shadow: inset 0 0 15px rgba(255,215,0,0.6); }
        .tutorial-visual .demo-sq.mv { background: linear-gradient(135deg, #00ff88, #00cc66) !important; }
        .tutorial-visual .demo-sq.atk { background: linear-gradient(135deg, #ff4444, #cc0000) !important; }

        .tutorial-visual .demo-caption {
            color: rgba(255,255,255,0.7);
            font-size: 0.85em;
            margin-top: 10px;
            font-style: italic;
        }

        .tutorial-tip {
            background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,140,0,0.1));
            border-left: 4px solid #ffd700;
            padding: 12px 16px;
            border-radius: 0 10px 10px 0;
            margin: 15px 0;
            color: #ffd700;
            font-size: 0.95em;
        }

        .tutorial-buttons {
            display: flex;
            justify-content: space-between;
            gap: 12px;
            margin-top: 10px;
        }

        .tutorial-btn {
            padding: 14px 30px;
            font-size: 1.05em;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
        }

        .tutorial-btn-back {
            background: rgba(255,255,255,0.1);
            color: #ccc;
            border: 2px solid rgba(255,255,255,0.2);
        }
        .tutorial-btn-back:hover { background: rgba(255,255,255,0.2); color: #fff; }
        .tutorial-btn-back:disabled { opacity: 0.3; cursor: default; }

        .tutorial-btn-next {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #1a1a3e;
        }
        .tutorial-btn-next:hover { transform: translateY(-2px); box-shadow: 0 4px 20px rgba(255,215,0,0.4); }

        .tutorial-btn-skip {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: rgba(255,255,255,0.4);
            font-size: 0.85em;
            cursor: pointer;
            padding: 5px 10px;
        }
        .tutorial-btn-skip:hover { color: #fff; }

        .tutorial-progress {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
        }

        .tutorial-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255,255,255,0.15);
            transition: all 0.3s ease;
        }
        .tutorial-dot.active {
            background: #ffd700;
            box-shadow: 0 0 8px rgba(255,215,0,0.5);
        }
        .tutorial-dot.done {
            background: rgba(255,215,0,0.4);
        }

        .tutorial-pieces-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 10px 0;
        }

        .tutorial-piece-card {
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 10px;
            padding: 10px 8px;
            text-align: center;
        }

        .tutorial-piece-card .tp-icon { font-size: 1.5em; }
        .tutorial-piece-card .tp-name { color: #fff; font-weight: bold; font-size: 0.85em; margin: 3px 0; }
        .tutorial-piece-card .tp-desc { color: rgba(255,255,255,0.6); font-size: 0.72em; line-height: 1.3; }

    </style>
</head>
<body>
    <div class="container">
        <h1>♟️ CHESS WARFARE ♟️</h1>
        <div id="battle-title" class="battle-title">CHESS WARFARE</div>
        <div class="turn-display" id="turn-display" style="color: rgb(255, 215, 0); animation: 2s ease-in-out 0s infinite normal none running turnGlow;">⬜ White's Turn</div>
        <div class="score-display">
            <div class="score-section">
                <div class="score-label">White Score</div>
                <div class="score-value" id="white-score">37</div>
            </div>
            <div class="score-section">
                <div class="score-label">Black Score</div>
                <div class="score-value" id="black-score">38</div>
            </div>
        </div>

        <div class="game-layout">
            <div class="piece-reference-guide">
                <h3>SPECIAL ABILITIES<br><small style="font-size:0.7em; opacity:0.8;">double click to use</small></h3>
                <div class="piece-reference-grid" id="piece-reference-grid"><div class="piece-ref-item" data-type="k">
                    <div class="piece-ref-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="15" y="42" width="20" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M13 42 L15 32 L35 32 L37 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <path d="M16 32 L18 22 L32 22 L34 32 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <path d="M20 22 L20 14 L17 14 L25 6 L33 14 L30 14 L30 22 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <line x1="25" y1="4" x2="25" y2="12" stroke="#333" stroke-width="2"></line>
                        <line x1="21" y1="8" x2="29" y2="8" stroke="#333" stroke-width="2"></line>
                    </svg></div>
                    <div class="piece-ref-name">King</div>
                    <div class="piece-ref-hp">❤️ 250 HP</div>
                    <div class="piece-ref-ability">
                        <div class="piece-ref-ability-name">⚡ Counter-Strike</div>
                        <div class="piece-ref-ability-desc">Gain shield + deal 100 damage to all pieces attacking the King</div>
                    </div>
                </div><div class="piece-ref-item" data-type="q">
                    <div class="piece-ref-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="15" y="42" width="20" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M13 42 L15 32 L35 32 L37 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <path d="M15 32 L12 12 L20 22 L25 8 L30 22 L38 12 L35 32 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <circle cx="12" cy="10" r="3" fill="#fff" stroke="#333" stroke-width="1.5"></circle>
                        <circle cx="25" cy="6" r="3" fill="#fff" stroke="#333" stroke-width="1.5"></circle>
                        <circle cx="38" cy="10" r="3" fill="#fff" stroke="#333" stroke-width="1.5"></circle>
                    </svg></div>
                    <div class="piece-ref-name">Queen</div>
                    <div class="piece-ref-hp">❤️ 120 HP</div>
                    <div class="piece-ref-ability">
                        <div class="piece-ref-ability-name">⚡ Heal</div>
                        <div class="piece-ref-ability-desc">Restore 50 HP to a friendly piece</div>
                    </div>
                </div><div class="piece-ref-item" data-type="r">
                    <div class="piece-ref-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="13" y="42" width="24" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M15 42 L15 18 L35 18 L35 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <rect x="15" y="8" width="4" height="10" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <rect x="23" y="8" width="4" height="10" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <rect x="31" y="8" width="4" height="10" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <rect x="13" y="16" width="24" height="4" fill="#fff" stroke="#333" stroke-width="1"></rect>
                    </svg></div>
                    <div class="piece-ref-name">Rook</div>
                    <div class="piece-ref-hp">❤️ 75 HP</div>
                    <div class="piece-ref-ability">
                        <div class="piece-ref-ability-name">⚡ Cannon</div>
                        <div class="piece-ref-ability-desc">Fire a cannonball dealing 35 damage</div>
                    </div>
                </div><div class="piece-ref-item" data-type="b">
                    <div class="piece-ref-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M15 42 L18 34 L32 34 L35 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="8" ry="3" fill="#fff" stroke="#333" stroke-width="1.5"></ellipse>
                        <path d="M19 34 Q25 10 31 34" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <circle cx="25" cy="12" r="3" fill="#fff" stroke="#333" stroke-width="1.5"></circle>
                        <line x1="22" y1="26" x2="28" y2="22" stroke="#333" stroke-width="1.5"></line>
                    </svg></div>
                    <div class="piece-ref-name">Bishop</div>
                    <div class="piece-ref-hp">❤️ 75 HP</div>
                    <div class="piece-ref-ability">
                        <div class="piece-ref-ability-name">⚡ Swap</div>
                        <div class="piece-ref-ability-desc">Teleport-swap with an enemy, both take 15 damage</div>
                    </div>
                </div><div class="piece-ref-item" data-type="n">
                    <div class="piece-ref-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="13" y="42" width="24" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M15 42 L17 32 L33 32 L35 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <path d="M17 32 L17 22 L14 18 L14 12 L20 8 L24 8 L28 12 L33 12 L35 16 L33 22 L33 32 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <circle cx="20" cy="16" r="1.5" fill="#333"></circle>
                        <path d="M14 12 L18 14" stroke="#333" stroke-width="1" fill="none"></path>
                    </svg></div>
                    <div class="piece-ref-name">Knight</div>
                    <div class="piece-ref-hp">❤️ 75 HP</div>
                    <div class="piece-ref-ability">
                        <div class="piece-ref-ability-name">⚡ Slam</div>
                        <div class="piece-ref-ability-desc">Jump to a square and deal 30 damage in 3x3 area</div>
                    </div>
                </div><div class="piece-ref-item" data-type="p">
                    <div class="piece-ref-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M16 42 L19 34 L31 34 L34 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="7" ry="3" fill="#fff" stroke="#333" stroke-width="1.5"></ellipse>
                        <path d="M20 34 L21 26 L29 26 L30 34" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <circle cx="25" cy="20" r="7" fill="#fff" stroke="#333" stroke-width="1.5"></circle>
                    </svg></div>
                    <div class="piece-ref-name">Pawn</div>
                    <div class="piece-ref-hp">❤️ 30 HP</div>
                    <div class="piece-ref-ability">
                        <div class="piece-ref-ability-name">⚡ Shoot</div>
                        <div class="piece-ref-ability-desc">Fire a bullet at the first enemy ahead for 20 damage</div>
                    </div>
                </div></div>
            </div>
            <div class="board-container">
                <div id="board" class="board"><div class="square light" data-row="0" data-col="0">
                            <span class="piece " data-tooltip="Rook: 75/75 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="13" y="42" width="24" height="4" rx="1" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <path d="M15 42 L15 18 L35 18 L35 42 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <rect x="15" y="8" width="4" height="10" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <rect x="23" y="8" width="4" height="10" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <rect x="31" y="8" width="4" height="10" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <rect x="13" y="16" width="24" height="4" fill="#222" stroke="#000" stroke-width="1"></rect>
                    </svg>
                            </span>
                            
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="0" data-col="1">
                            <span class="piece " data-tooltip="Knight: 75/75 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="13" y="42" width="24" height="4" rx="1" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <path d="M15 42 L17 32 L33 32 L35 42 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <path d="M17 32 L17 22 L14 18 L14 12 L20 8 L24 8 L28 12 L33 12 L35 16 L33 22 L33 32 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <circle cx="20" cy="16" r="1.5" fill="#000"></circle>
                        <path d="M14 12 L18 14" stroke="#000" stroke-width="1" fill="none"></path>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="0" data-col="2">
                            <span class="piece " data-tooltip="Bishop: 75/75 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <path d="M15 42 L18 34 L32 34 L35 42 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="8" ry="3" fill="#222" stroke="#000" stroke-width="1.5"></ellipse>
                        <path d="M19 34 Q25 10 31 34" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <circle cx="25" cy="12" r="3" fill="#222" stroke="#000" stroke-width="1.5"></circle>
                        <line x1="22" y1="26" x2="28" y2="22" stroke="#000" stroke-width="1.5"></line>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="0" data-col="3">
                            <span class="piece " data-tooltip="Queen: 120/120 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="15" y="42" width="20" height="4" rx="1" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <path d="M13 42 L15 32 L35 32 L37 42 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <path d="M15 32 L12 12 L20 22 L25 8 L30 22 L38 12 L35 32 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <circle cx="12" cy="10" r="3" fill="#222" stroke="#000" stroke-width="1.5"></circle>
                        <circle cx="25" cy="6" r="3" fill="#222" stroke="#000" stroke-width="1.5"></circle>
                        <circle cx="38" cy="10" r="3" fill="#222" stroke="#000" stroke-width="1.5"></circle>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="0" data-col="4">
                            <span class="piece " data-tooltip="King: 250/250 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="15" y="42" width="20" height="4" rx="1" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <path d="M13 42 L15 32 L35 32 L37 42 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <path d="M16 32 L18 22 L32 22 L34 32 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <path d="M20 22 L20 14 L17 14 L25 6 L33 14 L30 14 L30 22 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <line x1="25" y1="4" x2="25" y2="12" stroke="#000" stroke-width="2"></line>
                        <line x1="21" y1="8" x2="29" y2="8" stroke="#000" stroke-width="2"></line>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="0" data-col="5">
                            <span class="piece " data-tooltip="Bishop: 75/75 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <path d="M15 42 L18 34 L32 34 L35 42 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="8" ry="3" fill="#222" stroke="#000" stroke-width="1.5"></ellipse>
                        <path d="M19 34 Q25 10 31 34" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <circle cx="25" cy="12" r="3" fill="#222" stroke="#000" stroke-width="1.5"></circle>
                        <line x1="22" y1="26" x2="28" y2="22" stroke="#000" stroke-width="1.5"></line>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="0" data-col="6">
                            <span class="piece " data-tooltip="Knight: 75/75 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="13" y="42" width="24" height="4" rx="1" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <path d="M15 42 L17 32 L33 32 L35 42 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <path d="M17 32 L17 22 L14 18 L14 12 L20 8 L24 8 L28 12 L33 12 L35 16 L33 22 L33 32 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <circle cx="20" cy="16" r="1.5" fill="#000"></circle>
                        <path d="M14 12 L18 14" stroke="#000" stroke-width="1" fill="none"></path>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="0" data-col="7">
                            <span class="piece " data-tooltip="Rook: 75/75 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="13" y="42" width="24" height="4" rx="1" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <path d="M15 42 L15 18 L35 18 L35 42 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <rect x="15" y="8" width="4" height="10" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <rect x="23" y="8" width="4" height="10" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <rect x="31" y="8" width="4" height="10" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <rect x="13" y="16" width="24" height="4" fill="#222" stroke="#000" stroke-width="1"></rect>
                    </svg>
                            </span>
                            
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="1" data-col="0">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <path d="M16 42 L19 34 L31 34 L34 42 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="7" ry="3" fill="#222" stroke="#000" stroke-width="1.5"></ellipse>
                        <path d="M20 34 L21 26 L29 26 L30 34" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <circle cx="25" cy="20" r="7" fill="#222" stroke="#000" stroke-width="1.5"></circle>
                    </svg>
                            </span>
                            
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="1" data-col="1">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <path d="M16 42 L19 34 L31 34 L34 42 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="7" ry="3" fill="#222" stroke="#000" stroke-width="1.5"></ellipse>
                        <path d="M20 34 L21 26 L29 26 L30 34" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <circle cx="25" cy="20" r="7" fill="#222" stroke="#000" stroke-width="1.5"></circle>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="1" data-col="2">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <path d="M16 42 L19 34 L31 34 L34 42 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="7" ry="3" fill="#222" stroke="#000" stroke-width="1.5"></ellipse>
                        <path d="M20 34 L21 26 L29 26 L30 34" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <circle cx="25" cy="20" r="7" fill="#222" stroke="#000" stroke-width="1.5"></circle>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="1" data-col="3">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <path d="M16 42 L19 34 L31 34 L34 42 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="7" ry="3" fill="#222" stroke="#000" stroke-width="1.5"></ellipse>
                        <path d="M20 34 L21 26 L29 26 L30 34" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <circle cx="25" cy="20" r="7" fill="#222" stroke="#000" stroke-width="1.5"></circle>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="1" data-col="4">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <path d="M16 42 L19 34 L31 34 L34 42 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="7" ry="3" fill="#222" stroke="#000" stroke-width="1.5"></ellipse>
                        <path d="M20 34 L21 26 L29 26 L30 34" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <circle cx="25" cy="20" r="7" fill="#222" stroke="#000" stroke-width="1.5"></circle>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="1" data-col="5">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <path d="M16 42 L19 34 L31 34 L34 42 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="7" ry="3" fill="#222" stroke="#000" stroke-width="1.5"></ellipse>
                        <path d="M20 34 L21 26 L29 26 L30 34" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <circle cx="25" cy="20" r="7" fill="#222" stroke="#000" stroke-width="1.5"></circle>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="1" data-col="6">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#222" stroke="#000" stroke-width="1.5"></rect>
                        <path d="M16 42 L19 34 L31 34 L34 42 Z" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="7" ry="3" fill="#222" stroke="#000" stroke-width="1.5"></ellipse>
                        <path d="M20 34 L21 26 L29 26 L30 34" fill="#222" stroke="#000" stroke-width="1.5"></path>
                        <circle cx="25" cy="20" r="7" fill="#222" stroke="#000" stroke-width="1.5"></circle>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="1" data-col="7"></div><div class="square light" data-row="2" data-col="0"></div><div class="square dark" data-row="2" data-col="1"></div><div class="square light" data-row="2" data-col="2"></div><div class="square dark" data-row="2" data-col="3"></div><div class="square light" data-row="2" data-col="4"></div><div class="square dark" data-row="2" data-col="5"></div><div class="square light" data-row="2" data-col="6"></div><div class="square dark" data-row="2" data-col="7"></div><div class="square dark" data-row="3" data-col="0"></div><div class="square light" data-row="3" data-col="1"></div><div class="square dark" data-row="3" data-col="2"></div><div class="square light" data-row="3" data-col="3"></div><div class="square dark" data-row="3" data-col="4"></div><div class="square light" data-row="3" data-col="5"></div><div class="square dark" data-row="3" data-col="6"></div><div class="square light" data-row="3" data-col="7"></div><div class="square light" data-row="4" data-col="0"></div><div class="square dark" data-row="4" data-col="1"></div><div class="square light" data-row="4" data-col="2"></div><div class="square dark" data-row="4" data-col="3"></div><div class="square light" data-row="4" data-col="4">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M16 42 L19 34 L31 34 L34 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="7" ry="3" fill="#fff" stroke="#333" stroke-width="1.5"></ellipse>
                        <path d="M20 34 L21 26 L29 26 L30 34" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <circle cx="25" cy="20" r="7" fill="#fff" stroke="#333" stroke-width="1.5"></circle>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="4" data-col="5"></div><div class="square light" data-row="4" data-col="6"></div><div class="square dark" data-row="4" data-col="7"></div><div class="square dark" data-row="5" data-col="0"></div><div class="square light" data-row="5" data-col="1"></div><div class="square dark" data-row="5" data-col="2"></div><div class="square light" data-row="5" data-col="3"></div><div class="square dark" data-row="5" data-col="4"></div><div class="square light" data-row="5" data-col="5">
                            <span class="piece " data-tooltip="Knight: 75/75 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="13" y="42" width="24" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M15 42 L17 32 L33 32 L35 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <path d="M17 32 L17 22 L14 18 L14 12 L20 8 L24 8 L28 12 L33 12 L35 16 L33 22 L33 32 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <circle cx="20" cy="16" r="1.5" fill="#333"></circle>
                        <path d="M14 12 L18 14" stroke="#333" stroke-width="1" fill="none"></path>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="5" data-col="6"></div><div class="square light" data-row="5" data-col="7"></div><div class="square light" data-row="6" data-col="0"></div><div class="square dark" data-row="6" data-col="1">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M16 42 L19 34 L31 34 L34 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="7" ry="3" fill="#fff" stroke="#333" stroke-width="1.5"></ellipse>
                        <path d="M20 34 L21 26 L29 26 L30 34" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <circle cx="25" cy="20" r="7" fill="#fff" stroke="#333" stroke-width="1.5"></circle>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="6" data-col="2">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M16 42 L19 34 L31 34 L34 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="7" ry="3" fill="#fff" stroke="#333" stroke-width="1.5"></ellipse>
                        <path d="M20 34 L21 26 L29 26 L30 34" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <circle cx="25" cy="20" r="7" fill="#fff" stroke="#333" stroke-width="1.5"></circle>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="6" data-col="3">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M16 42 L19 34 L31 34 L34 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="7" ry="3" fill="#fff" stroke="#333" stroke-width="1.5"></ellipse>
                        <path d="M20 34 L21 26 L29 26 L30 34" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <circle cx="25" cy="20" r="7" fill="#fff" stroke="#333" stroke-width="1.5"></circle>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="6" data-col="4"></div><div class="square dark" data-row="6" data-col="5">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M16 42 L19 34 L31 34 L34 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="7" ry="3" fill="#fff" stroke="#333" stroke-width="1.5"></ellipse>
                        <path d="M20 34 L21 26 L29 26 L30 34" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <circle cx="25" cy="20" r="7" fill="#fff" stroke="#333" stroke-width="1.5"></circle>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="6" data-col="6">
                            <span class="piece " data-tooltip="Pawn: 30/30 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M16 42 L19 34 L31 34 L34 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="7" ry="3" fill="#fff" stroke="#333" stroke-width="1.5"></ellipse>
                        <path d="M20 34 L21 26 L29 26 L30 34" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <circle cx="25" cy="20" r="7" fill="#fff" stroke="#333" stroke-width="1.5"></circle>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="6" data-col="7"></div><div class="square dark" data-row="7" data-col="0">
                            <span class="piece " data-tooltip="Rook: 55/75 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="13" y="42" width="24" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M15 42 L15 18 L35 18 L35 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <rect x="15" y="8" width="4" height="10" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <rect x="23" y="8" width="4" height="10" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <rect x="31" y="8" width="4" height="10" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <rect x="13" y="16" width="24" height="4" fill="#fff" stroke="#333" stroke-width="1"></rect>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 73.33333333333333%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="7" data-col="1">
                            <span class="piece " data-tooltip="Knight: 75/75 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="13" y="42" width="24" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M15 42 L17 32 L33 32 L35 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <path d="M17 32 L17 22 L14 18 L14 12 L20 8 L24 8 L28 12 L33 12 L35 16 L33 22 L33 32 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <circle cx="20" cy="16" r="1.5" fill="#333"></circle>
                        <path d="M14 12 L18 14" stroke="#333" stroke-width="1" fill="none"></path>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="7" data-col="2">
                            <span class="piece " data-tooltip="Bishop: 75/75 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M15 42 L18 34 L32 34 L35 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="8" ry="3" fill="#fff" stroke="#333" stroke-width="1.5"></ellipse>
                        <path d="M19 34 Q25 10 31 34" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <circle cx="25" cy="12" r="3" fill="#fff" stroke="#333" stroke-width="1.5"></circle>
                        <line x1="22" y1="26" x2="28" y2="22" stroke="#333" stroke-width="1.5"></line>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="7" data-col="3">
                            <span class="piece " data-tooltip="Queen: 120/120 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="15" y="42" width="20" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M13 42 L15 32 L35 32 L37 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <path d="M15 32 L12 12 L20 22 L25 8 L30 22 L38 12 L35 32 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <circle cx="12" cy="10" r="3" fill="#fff" stroke="#333" stroke-width="1.5"></circle>
                        <circle cx="25" cy="6" r="3" fill="#fff" stroke="#333" stroke-width="1.5"></circle>
                        <circle cx="38" cy="10" r="3" fill="#fff" stroke="#333" stroke-width="1.5"></circle>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="7" data-col="4">
                            <span class="piece " data-tooltip="King: 250/250 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="15" y="42" width="20" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M13 42 L15 32 L35 32 L37 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <path d="M16 32 L18 22 L32 22 L34 32 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <path d="M20 22 L20 14 L17 14 L25 6 L33 14 L30 14 L30 22 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <line x1="25" y1="4" x2="25" y2="12" stroke="#333" stroke-width="2"></line>
                        <line x1="21" y1="8" x2="29" y2="8" stroke="#333" stroke-width="2"></line>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square light" data-row="7" data-col="5">
                            <span class="piece " data-tooltip="Bishop: 75/75 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M15 42 L18 34 L32 34 L35 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <ellipse cx="25" cy="34" rx="8" ry="3" fill="#fff" stroke="#333" stroke-width="1.5"></ellipse>
                        <path d="M19 34 Q25 10 31 34" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <circle cx="25" cy="12" r="3" fill="#fff" stroke="#333" stroke-width="1.5"></circle>
                        <line x1="22" y1="26" x2="28" y2="22" stroke="#333" stroke-width="1.5"></line>
                    </svg>
                            </span>
                            <div class="ability-indicator">⚡</div>
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div><div class="square dark" data-row="7" data-col="6"></div><div class="square light" data-row="7" data-col="7">
                            <span class="piece " data-tooltip="Rook: 75/75 HP">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">
                        <rect x="13" y="42" width="24" height="4" rx="1" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <path d="M15 42 L15 18 L35 18 L35 42 Z" fill="#fff" stroke="#333" stroke-width="1.5"></path>
                        <rect x="15" y="8" width="4" height="10" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <rect x="23" y="8" width="4" height="10" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <rect x="31" y="8" width="4" height="10" fill="#fff" stroke="#333" stroke-width="1.5"></rect>
                        <rect x="13" y="16" width="24" height="4" fill="#fff" stroke="#333" stroke-width="1"></rect>
                    </svg>
                            </span>
                            
                            
                            
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: 100%"></div>
                                
                            </div>
                        </div></div>
            </div>
        </div>

        <div class="controls">
            <button class="reset-btn" onclick="resetGame()">Reset Game</button>
            <button class="new-game-btn" onclick="newGame()">New Game</button>
        </div>
    </div>

    <div class="game-message" id="game-message">
        <h2 id="message-title">WHITE WINS! 🏆</h2>
        <p id="message-text">Game Over!</p>
        <button class="reset-btn" id="play-again-btn" onclick="hideMessage(); resetGame()" style="display: block;">Play Again</button>
    </div>

    <div class="promotion-overlay hidden" id="promotion-overlay">
        <div class="promotion-dialog">
            <h2>PROMOTE YOUR PAWN</h2>
            <div class="promotion-choices" id="promotion-choices"></div>
        </div>
    </div>

    <!-- TUTORIAL OVERLAY -->
    <div class="tutorial-overlay hidden" id="tutorial-overlay">
        <div class="tutorial-box">
            <button class="tutorial-btn-skip" onclick="closeTutorial()">Skip Tutorial ✕</button>
            <div class="tutorial-step-counter" id="tutorial-step-counter">STEP 1 OF 8</div>
            <div class="tutorial-progress" id="tutorial-progress"></div>
            <h2 class="tutorial-title" id="tutorial-title">Welcome</h2>
            <div class="tutorial-content" id="tutorial-content"></div>
            <div class="tutorial-buttons">
                <button class="tutorial-btn tutorial-btn-back" id="tutorial-back" onclick="tutorialPrev()" disabled="">Back</button>
                <button class="tutorial-btn tutorial-btn-next" id="tutorial-next" onclick="tutorialNext()">Next</button>
            </div>
        </div>
    </div>

    <!-- ONLINE LOBBY OVERLAY -->
    <div class="online-lobby-overlay hidden" id="online-lobby-overlay">
        <div class="online-lobby">
            <h2>🌐 ONLINE MULTIPLAYER</h2>
            <div class="lobby-status connecting" id="lobby-conn-status">⏳ Connecting...</div>

            <div id="lobby-menu">
                <p style="color:#aaa; margin-bottom:20px;">Play Chess Warfare against a friend online!</p>
                <div>
                    <button class="lobby-btn lobby-btn-create" id="lobby-create-btn" onclick="onlineCreateRoom()" disabled="">Create Room</button>
                </div>
                <div style="margin-top:15px;">
                    <input type="text" id="lobby-code-input" placeholder="CODE" maxlength="4" disabled="">
                    <button class="lobby-btn lobby-btn-join" id="lobby-join-btn" onclick="onlineJoinRoom()" disabled="">Join</button>
                </div>
                <button class="lobby-btn lobby-btn-back" onclick="onlineLeaveLobby()">Back to Menu</button>
            </div>

            <div id="lobby-waiting" style="display:none;">
                <p style="color:#aaa;">Share this code with your friend:</p>
                <div class="lobby-room-code" id="lobby-display-code"></div>
                <p class="lobby-waiting">Waiting for opponent...</p>
                <button class="lobby-btn lobby-btn-back" onclick="onlineLeaveLobby()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="mode-selector hidden" id="mode-selector">
        <div class="mode-content">
            <h2>SELECT GAME MODE</h2>
            <div class="mode-buttons">
                <button id="pvp-btn" class="mode-button" onclick="selectOpponent(&#39;pvp&#39;)">👥 Player vs Player</button>
                <button id="online-btn" class="mode-button" onclick="selectOpponent(&#39;online&#39;)">🌐 Online PvP</button>
                <button id="pvc-btn" class="mode-button selected" onclick="selectOpponent(&#39;pvc&#39;)">🤖 Player vs Computer</button>
            </div>

            <div id="ai-difficulty-section" style="display: block;">
                <div class="difficulty-label">AI Difficulty Level</div>
                <div class="difficulty-container">
                    <input type="range" id="difficulty-slider" min="1" max="100" value="50" oninput="updateDifficultyDisplay()">
                    <div id="difficulty-value">100</div>
                </div>
                <div class="difficulty-labels">
                    <span>Easy (Random)</span>
                    <span>Hard (Optimal)</span>
                </div>
            </div>

            <div id="online-info-section" style="display: none;">
                <div class="difficulty-label">Online PvP</div>
                <p style="color:#ccc; font-size:0.9em; margin:10px 0;">Create or join a room to play against a friend on a different device. You'll get a 4-letter code to share.</p>
                <p style="color:#ffd700; font-size:0.85em;">Player 1 (room creator) = White<br>Player 2 (joins room) = Black</p>
            </div>


            <button id="start-game-btn" onclick="startSelectedGame()" style="display: block;">START GAME</button>
        </div>
    </div>

    <script>
        // Piece definitions
        // ====== SVG PIECE SYSTEM (consistent across all platforms) ======
        function getPieceSVG(type, isWhite) {
            const fill = isWhite ? '#fff' : '#222';
            const stroke = isWhite ? '#333' : '#000';
            let paths = '';

            switch(type) {
                case 'k': // King
                    paths = `
                        <rect x="15" y="42" width="20" height="4" rx="1" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M13 42 L15 32 L35 32 L37 42 Z" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M16 32 L18 22 L32 22 L34 32 Z" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M20 22 L20 14 L17 14 L25 6 L33 14 L30 14 L30 22 Z" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <line x1="25" y1="4" x2="25" y2="12" stroke="${stroke}" stroke-width="2"/>
                        <line x1="21" y1="8" x2="29" y2="8" stroke="${stroke}" stroke-width="2"/>
                    `;
                    break;
                case 'q': // Queen
                    paths = `
                        <rect x="15" y="42" width="20" height="4" rx="1" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M13 42 L15 32 L35 32 L37 42 Z" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M15 32 L12 12 L20 22 L25 8 L30 22 L38 12 L35 32 Z" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <circle cx="12" cy="10" r="3" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <circle cx="25" cy="6" r="3" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <circle cx="38" cy="10" r="3" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                    `;
                    break;
                case 'r': // Rook
                    paths = `
                        <rect x="13" y="42" width="24" height="4" rx="1" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M15 42 L15 18 L35 18 L35 42 Z" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <rect x="15" y="8" width="4" height="10" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <rect x="23" y="8" width="4" height="10" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <rect x="31" y="8" width="4" height="10" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <rect x="13" y="16" width="24" height="4" fill="${fill}" stroke="${stroke}" stroke-width="1"/>
                    `;
                    break;
                case 'b': // Bishop
                    paths = `
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M15 42 L18 34 L32 34 L35 42 Z" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <ellipse cx="25" cy="34" rx="8" ry="3" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M19 34 Q25 10 31 34" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <circle cx="25" cy="12" r="3" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <line x1="22" y1="26" x2="28" y2="22" stroke="${stroke}" stroke-width="1.5"/>
                    `;
                    break;
                case 'n': // Knight
                    paths = `
                        <rect x="13" y="42" width="24" height="4" rx="1" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M15 42 L17 32 L33 32 L35 42 Z" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M17 32 L17 22 L14 18 L14 12 L20 8 L24 8 L28 12 L33 12 L35 16 L33 22 L33 32 Z" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <circle cx="20" cy="16" r="1.5" fill="${stroke}"/>
                        <path d="M14 12 L18 14" stroke="${stroke}" stroke-width="1" fill="none"/>
                    `;
                    break;
                case 'p': // Pawn
                    paths = `
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M16 42 L19 34 L31 34 L34 42 Z" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <ellipse cx="25" cy="34" rx="7" ry="3" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M20 34 L21 26 L29 26 L30 34" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <circle cx="25" cy="20" r="7" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                    `;
                    break;
                case 'w': // Wizard
                    paths = `
                        <rect x="15" y="42" width="20" height="4" rx="1" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M14 42 L18 30 L32 30 L36 42 Z" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <ellipse cx="25" cy="30" rx="8" ry="3" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M17 30 L25 4 L33 30" fill="#7B2FBE" stroke="${stroke}" stroke-width="1.5"/>
                        <polygon points="25,10 26.5,14 30.5,14 27.5,17 28.5,21 25,18.5 21.5,21 22.5,17 19.5,14 23.5,14" fill="#ffd700"/>
                        <circle cx="18" cy="28" r="1.5" fill="#ffd700"/>
                        <circle cx="32" cy="28" r="1.5" fill="#ffd700"/>
                    `;
                    break;
                case 'd': // Dragon
                    paths = `
                        <rect x="14" y="42" width="22" height="4" rx="1" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M16 42 L16 24 L10 16 L16 20 L18 10 L22 16 L28 16 L32 10 L34 20 L40 16 L34 24 L34 42 Z" fill="#D4380D" stroke="${stroke}" stroke-width="1.5"/>
                        <circle cx="21" cy="24" r="2.5" fill="#FFD700" stroke="${stroke}" stroke-width="1"/>
                        <circle cx="29" cy="24" r="2.5" fill="#FFD700" stroke="${stroke}" stroke-width="1"/>
                        <circle cx="21" cy="24" r="1" fill="#000"/>
                        <circle cx="29" cy="24" r="1" fill="#000"/>
                        <path d="M20 34 L25 30 L30 34" fill="none" stroke="${stroke}" stroke-width="1.5"/>
                        <line x1="22" y1="36" x2="22" y2="38" stroke="#FF6600" stroke-width="1.5"/>
                        <line x1="25" y1="35" x2="25" y2="38" stroke="#FF6600" stroke-width="1.5"/>
                        <line x1="28" y1="36" x2="28" y2="38" stroke="#FF6600" stroke-width="1.5"/>
                    `;
                    break;
                case 't': // Tank
                    paths = `
                        <rect x="13" y="42" width="24" height="4" rx="1" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M14 42 L14 14 Q25 4 36 14 L36 42 Z" fill="#708090" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M18 38 L18 18 Q25 10 32 18 L32 38 Z" fill="#8899AA" stroke="${stroke}" stroke-width="1"/>
                        <line x1="25" y1="16" x2="25" y2="28" stroke="${fill}" stroke-width="2.5"/>
                        <line x1="19" y1="22" x2="31" y2="22" stroke="${fill}" stroke-width="2.5"/>
                        <circle cx="25" cy="34" r="2" fill="${stroke}"/>
                    `;
                    break;
                case 's': // Assassin
                    paths = `
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M16 42 L18 30 L32 30 L34 42 Z" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M17 30 Q25 8 33 30 Z" fill="#8B0000" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M22 26 Q25 18 28 26 Z" fill="#111"/>
                        <line x1="36" y1="10" x2="36" y2="28" stroke="#C0C0C0" stroke-width="2"/>
                        <path d="M34 10 L38 10 L36 6 Z" fill="#C0C0C0" stroke="#888" stroke-width="0.5"/>
                        <line x1="34" y1="28" x2="38" y2="28" stroke="#8B4513" stroke-width="2"/>
                    `;
                    break;
                case 'h': // Ghost
                    paths = `
                        <path d="M16 44 L16 20 Q16 6 25 6 Q34 6 34 20 L34 44 L31 38 L28 44 L25 38 L22 44 L19 38 Z" fill="${isWhite ? '#E8E8FF' : '#4A4A6A'}" stroke="${stroke}" stroke-width="1.5"/>
                        <circle cx="20" cy="20" r="3" fill="${isWhite ? '#333' : '#AAF'}"/>
                        <circle cx="30" cy="20" r="3" fill="${isWhite ? '#333' : '#AAF'}"/>
                        <circle cx="20.5" cy="19.5" r="1.2" fill="#fff"/>
                        <circle cx="30.5" cy="19.5" r="1.2" fill="#fff"/>
                        <ellipse cx="25" cy="28" rx="3" ry="2" fill="${isWhite ? '#666' : '#222'}"/>
                    `;
                    break;
                case 'g': // Grandpa
                    paths = `
                        <rect x="16" y="42" width="18" height="4" rx="1" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M18 42 L19 30 L31 30 L32 42 Z" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <circle cx="25" cy="22" r="8" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M19 16 Q25 8 31 16" fill="#C0C0C0" stroke="${stroke}" stroke-width="1.5"/>
                        <circle cx="22" cy="22" r="1.5" fill="${stroke}"/>
                        <circle cx="28" cy="22" r="1.5" fill="${stroke}"/>
                        <path d="M22 27 Q25 30 28 27" fill="none" stroke="${stroke}" stroke-width="1"/>
                        <line x1="36" y1="18" x2="36" y2="44" stroke="#8B4513" stroke-width="2.5"/>
                        <path d="M33 18 Q36 14 39 18" fill="none" stroke="#8B4513" stroke-width="2.5"/>
                    `;
                    break;
                case 'l': // Lizard
                    paths = `
                        <ellipse cx="25" cy="36" rx="12" ry="6" fill="#228B22" stroke="${stroke}" stroke-width="1.5"/>
                        <circle cx="20" cy="28" r="7" fill="#2ECC40" stroke="${stroke}" stroke-width="1.5"/>
                        <circle cx="17" cy="26" r="3" fill="#ADFF2F" stroke="${stroke}" stroke-width="1"/>
                        <circle cx="17" cy="26" r="1.2" fill="#000"/>
                        <path d="M26 26 Q32 22 36 26 Q32 30 26 26" fill="#FF4444"/>
                        <path d="M30 38 Q38 44 42 40 Q40 36 34 38" fill="#228B22" stroke="${stroke}" stroke-width="1"/>
                        <line x1="14" y1="40" x2="10" y2="44" stroke="#228B22" stroke-width="2"/>
                        <line x1="20" y1="42" x2="18" y2="46" stroke="#228B22" stroke-width="2"/>
                        <line x1="30" y1="42" x2="32" y2="46" stroke="#228B22" stroke-width="2"/>
                        <line x1="36" y1="40" x2="40" y2="44" stroke="#228B22" stroke-width="2"/>
                    `;
                    break;
                case 'x': // Saboteur
                    paths = `
                        <rect x="14" y="42" width="22" height="4" rx="1" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <path d="M16 42 L18 30 L32 30 L34 42 Z" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <circle cx="25" cy="22" r="8" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>
                        <rect x="17" y="18" width="16" height="5" rx="2" fill="#333" stroke="${stroke}" stroke-width="1"/>
                        <circle cx="22" cy="20" r="1.5" fill="#ff4444"/>
                        <circle cx="28" cy="20" r="1.5" fill="#ff4444"/>
                        <circle cx="38" cy="16" r="5" fill="#333" stroke="#555" stroke-width="1.5"/>
                        <line x1="38" y1="11" x2="40" y2="6" stroke="#FF6600" stroke-width="1.5"/>
                        <circle cx="40" cy="5" r="2" fill="#FF6600" opacity="0.8"/>
                    `;
                    break;
                default:
                    paths = `<circle cx="25" cy="25" r="12" fill="${fill}" stroke="${stroke}" stroke-width="2"/>`;
            }

            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="100%" height="100%" style="max-width:48px;max-height:48px;display:block;margin:auto;">${paths}</svg>`;
        }

        const pieces = {
            white: { king: 'k', queen: 'q', rook: 'r', bishop: 'b', knight: 'n', pawn: 'p' },
            black: { king: 'k', queen: 'q', rook: 'r', bishop: 'b', knight: 'n', pawn: 'p' }
        };

        const pieceEmojis = {
            w: { white: 'w', black: 'w' },
            g: { white: 'g', black: 'g' },
            l: { white: 'l', black: 'l' },
            t: { white: 't', black: 't' },
            s: { white: 's', black: 's' },
            d: { white: 'd', black: 'd' },
            h: { white: 'h', black: 'h' },
            x: { white: 'x', black: 'x' }
        };

        let board = [];
        let selectedSquare = null;
        let currentTurn = 'white';
        let gameActive = false;
        let activeAbility = null;
        let pieceIdCounter = 0;
        let landmines = [];

        let gameMode = 'pvp';
        let aiDifficulty = 50;
        let isAIThinking = false;

        // ====== ONLINE MULTIPLAYER ======
        let ws = null;
        let myColor = null;        // 'white' or 'black'
        let myPlayerNumber = null;  // 1 or 2
        let onlineConnected = false;
        let isRemoteAction = false; // prevents sending back received moves
        let currentRoomCode = null; // remember room for reconnection
        let pingInterval = null;
        let pendingSync = null; // pending board state sync from opponent
        let moveSeqNum = 0; // move sequence counter for desync detection

        function onlineConnect() {
            if (location.protocol === 'file:') return;
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            try {
                ws = new WebSocket(`${protocol}//${location.host}`);
            } catch(e) { return; }

            ws.onopen = () => {
                onlineConnected = true;
                updateLobbyStatus('connected', 'Connected');
                setLobbyButtonsEnabled(true);
                updateGameConnectionStatus(true);

                // Start client-side keepalive ping every 20s
                if (pingInterval) clearInterval(pingInterval);
                pingInterval = setInterval(() => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({ type: 'ping' }));
                    }
                }, 20000);

                // Auto-rejoin room if we were in a game
                if (currentRoomCode && gameActive && gameMode === 'online') {
                    console.log('Reconnected - rejoining room', currentRoomCode);
                    ws.send(JSON.stringify({
                        type: 'rejoin_room',
                        code: currentRoomCode,
                        playerNumber: myPlayerNumber
                    }));
                }
            };

            ws.onmessage = (event) => {
                let msg;
                try { msg = JSON.parse(event.data); } catch { return; }
                if (msg.type === 'pong') return; // keepalive response

                try {
                    switch(msg.type) {
                        case 'room_created':
                            myPlayerNumber = 1;
                            myColor = 'white';
                            currentRoomCode = msg.code;
                            document.getElementById('lobby-display-code').textContent = msg.code;
                            document.getElementById('lobby-menu').style.display = 'none';
                            document.getElementById('lobby-waiting').style.display = 'block';
                            break;

                        case 'room_joined':
                            myPlayerNumber = 2;
                            myColor = 'black';
                            currentRoomCode = msg.code;
                            break;

                        case 'rejoined':
                            console.log('Successfully rejoined room', currentRoomCode);
                            updateGameConnectionStatus(true);
                            break;

                        case 'game_start':
                            document.getElementById('online-lobby-overlay').classList.add('hidden');
                            startOnlineGame();
                            break;

                        case 'game_move':
                            handleRemoteAction(msg.move);
                            break;

                        case 'state_sync':
                            // Store pending sync — applied before next user action
                            pendingSync = msg;
                            // Also apply with a delay in case user doesn't click immediately
                            // (ensures turn indicator and board update even if waiting)
                            setTimeout(() => {
                                if (pendingSync === msg) {
                                    applyPendingSync();
                                }
                            }, 1200);
                            break;

                        case 'pong':
                            // Keepalive response — connection is alive
                            break;

                        case 'player_disconnected':
                            if (gameActive && gameMode === 'online') {
                                updateGameConnectionStatus(false, 'Opponent disconnected - waiting for reconnect...');
                            }
                            break;

                        case 'opponent_reconnected':
                            if (gameActive && gameMode === 'online') {
                                updateGameConnectionStatus(true);
                            }
                            break;

                        case 'error':
                            alert(msg.message);
                            break;
                    }
                } catch(e) {
                    console.error('WebSocket message handling error:', e);
                    isRemoteAction = false; // always reset
                }
            };

            ws.onerror = () => {
                updateLobbyStatus('disconnected', 'Connection error');
                updateGameConnectionStatus(false, 'Connection error');
            };

            ws.onclose = () => {
                onlineConnected = false;
                if (pingInterval) { clearInterval(pingInterval); pingInterval = null; }
                setLobbyButtonsEnabled(false);
                updateLobbyStatus('disconnected', 'Disconnected');
                updateGameConnectionStatus(false, 'Reconnecting...');
                // Auto-reconnect (keeps room code for rejoin)
                setTimeout(() => { if (!onlineConnected) onlineConnect(); }, 2000);
            };
        }

        function updateGameConnectionStatus(connected, message) {
            let statusEl = document.getElementById('online-conn-indicator');
            if (!statusEl) {
                statusEl = document.createElement('div');
                statusEl.id = 'online-conn-indicator';
                statusEl.style.cssText = 'position:fixed;top:5px;right:10px;padding:4px 10px;border-radius:12px;font-size:0.75em;z-index:9999;font-weight:bold;transition:all 0.3s;';
                document.body.appendChild(statusEl);
            }
            if (gameMode !== 'online' || !gameActive) {
                statusEl.style.display = 'none';
                return;
            }
            statusEl.style.display = 'block';
            if (connected) {
                statusEl.style.background = 'rgba(0,200,0,0.3)';
                statusEl.style.color = '#0f0';
                statusEl.textContent = '🟢 Connected';
                setTimeout(() => { if (statusEl.textContent === '🟢 Connected') statusEl.style.opacity = '0.4'; }, 3000);
            } else {
                statusEl.style.background = 'rgba(200,0,0,0.3)';
                statusEl.style.color = '#f44';
                statusEl.style.opacity = '1';
                statusEl.textContent = '🔴 ' + (message || 'Disconnected');
            }
        }

        function updateLobbyStatus(state, text) {
            const el = document.getElementById('lobby-conn-status');
            if (!el) return;
            el.className = 'lobby-status ' + state;
            const icons = {connecting:'⏳', connected:'✅', disconnected:'❌'};
            el.textContent = (icons[state]||'') + ' ' + text;
        }

        function setLobbyButtonsEnabled(enabled) {
            const ids = ['lobby-create-btn','lobby-join-btn','lobby-code-input'];
            ids.forEach(id => { const el = document.getElementById(id); if(el) el.disabled = !enabled; });
        }

        function onlineCreateRoom() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            ws.send(JSON.stringify({ type: 'create_room' }));
        }

        function onlineJoinRoom() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            const code = document.getElementById('lobby-code-input').value.trim();
            if (code.length !== 4) { alert('Enter a 4-letter room code'); return; }
            ws.send(JSON.stringify({ type: 'join_room', code: code }));
        }

        function onlineLeaveLobby() {
            document.getElementById('online-lobby-overlay').classList.add('hidden');
            document.getElementById('lobby-menu').style.display = 'block';
            document.getElementById('lobby-waiting').style.display = 'none';
            currentRoomCode = null;
            if (pingInterval) { clearInterval(pingInterval); pingInterval = null; }
            if (ws) ws.close();
            ws = null;
            onlineConnected = false;
            newGame();
        }

        function startOnlineGame() {
            document.getElementById('mode-selector').classList.add('hidden');
            document.getElementById('battle-title').textContent = 
                'CHESS WARFARE — ONLINE (' + (myColor === 'white' ? '⬜ White' : '⬛ Black') + ')';
            pendingSync = null;
            moveSeqNum = 0;
            initStandardBoard();
            initPieceReferenceGuide();
            gameActive = true;
            renderBoard();
        }

        function sendOnlineAction(actionData) {
            if (gameMode !== 'online' || isRemoteAction || !ws || ws.readyState !== WebSocket.OPEN) return;
            ws.send(JSON.stringify({ type: 'game_move', move: actionData }));
        }

        // ====== BOARD STATE SYNC (prevents desync between clients) ======
        function serializeBoard() {
            const data = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = board[r][c];
                    if (p) {
                        data.push({
                            r, c,
                            t: p.type,
                            hp: p.health,
                            mhp: p.maxHealth,
                            au: p.abilityUsed || false,
                            hm: p.hasMoved || false,
                            sh: p.shield || 0,
                            la: p.lizardAttached || false,
                            ss: p.stolenSoul || null,
                            id: p.id
                        });
                    }
                }
            }
            return data;
        }

        function deserializeBoard(data) {
            // Clear board
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    board[r][c] = null;
                }
            }
            // Rebuild from data
            data.forEach(p => {
                board[p.r][p.c] = {
                    type: p.t,
                    health: p.hp,
                    maxHealth: p.mhp,
                    abilityUsed: p.au,
                    hasMoved: p.hm,
                    shield: p.sh,
                    lizardAttached: p.la,
                    stolenSoul: p.ss || null,
                    id: p.id
                };
            });
        }

        function sendStateSync() {
            if (gameMode !== 'online' || !ws || ws.readyState !== WebSocket.OPEN) return;
            moveSeqNum++;
            ws.send(JSON.stringify({
                type: 'state_sync',
                board: serializeBoard(),
                turn: currentTurn,
                mines: landmines.map(m => ({ row: m.row, col: m.col, owner: m.owner })),
                seq: moveSeqNum
            }));
        }

        function applyPendingSync() {
            if (!pendingSync) return;
            const sync = pendingSync;
            pendingSync = null;
            deserializeBoard(sync.board);
            currentTurn = sync.turn;
            landmines = (sync.mines || []).map(m => ({ row: m.row, col: m.col, owner: m.owner }));
            renderBoard();
        }

        function handleRemoteAction(data) {
            if (!data) return;
            isRemoteAction = true;
            try {
                if (data.action === 'move') {
                    if (!board[data.fromRow][data.fromCol]) {
                        console.warn('Remote move: no piece at', data.fromRow, data.fromCol, '— state sync will fix');
                        // CRITICAL: still switch turn so turns stay aligned
                        switchTurn();
                        applyPoisonDamage();
                        renderBoard();
                    } else {
                        makeMove(data.fromRow, data.fromCol, data.toRow, data.toCol);
                    }
                    clearSelection();
                } else if (data.action === 'ability') {
                    if (!board[data.fromRow][data.fromCol]) {
                        console.warn('Remote ability: no piece at', data.fromRow, data.fromCol, '— state sync will fix');
                        // CRITICAL: still switch turn so turns stay aligned
                        switchTurn();
                        renderBoard();
                    } else {
                        useAbilityImmediate(data.fromRow, data.fromCol, data.toRow, data.toCol, data.abilityType);
                    }
                    clearSelection();
                } else if (data.action === 'promote') {
                    document.getElementById('promotion-overlay').classList.add('hidden');
                    promotePawn(data.row, data.col, data.newType);
                    switchTurn();
                    applyPoisonDamage();
                    renderBoard();
                    checkGameEnd();
                }
            } catch(e) {
                console.error('Remote action error:', e, 'Data:', data);
                // Force turn switch on error so game doesn't freeze
                try { switchTurn(); renderBoard(); } catch(e2) {}
            }
            isRemoteAction = false;
        }

        // Immediate version of useAbility - no animations, synchronous
        // Used for remote actions to prevent async desync
        function useAbilityImmediate(fromRow, fromCol, toRow, toCol, abilityType) {
            const piece = board[fromRow][fromCol];
            if (piece) piece.abilityUsed = true;

            switch (abilityType) {
                case 'p': // Pawn shoot
                    dealDamage(toRow, toCol, 20);
                    break;
                case 'q': // Queen heal
                    if (board[toRow][toCol]) {
                        board[toRow][toCol].health = Math.min(
                            board[toRow][toCol].health + 50,
                            board[toRow][toCol].maxHealth
                        );
                    }
                    break;
                case 'r': // Rook cannon
                    dealDamage(toRow, toCol, 35);
                    break;
                case 'b': // Bishop swap
                    const temp = board[fromRow][fromCol];
                    board[fromRow][fromCol] = board[toRow][toCol];
                    board[toRow][toCol] = temp;
                    dealDamage(fromRow, fromCol, 15);
                    dealDamage(toRow, toCol, 15);
                    break;
                case 'n': // Knight slam
                    board[toRow][toCol] = piece;
                    board[fromRow][fromCol] = null;
                    const slamColor = piece.type[0];
                    for (let r = toRow - 1; r <= toRow + 1; r++) {
                        for (let c = toCol - 1; c <= toCol + 1; c++) {
                            if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                                const slamTarget = board[r][c];
                                if (slamTarget && slamTarget.type[0] === slamColor) continue;
                                dealDamage(r, c, 30);
                            }
                        }
                    }
                    break;
                case 'k': // King counter-strike
                    if (piece) piece.shield = 50;
                    const kingColor = piece.type[0];
                    const opponentColor = kingColor === 'w' ? 'b' : 'w';
                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 8; c++) {
                            const enemyPiece = board[r][c];
                            if (enemyPiece && enemyPiece.type[0] === opponentColor) {
                                const et = enemyPiece.type[1];
                                let canAttack = false;
                                switch (et) {
                                    case 'p':
                                        const dir = opponentColor === 'w' ? -1 : 1;
                                        canAttack = Math.abs(fromCol - c) === 1 && fromRow === r + dir;
                                        break;
                                    case 'r': canAttack = isValidRookMove(r, c, fromRow, fromCol); break;
                                    case 'n': canAttack = isValidKnightMove(r, c, fromRow, fromCol); break;
                                    case 'b': canAttack = isValidBishopMove(r, c, fromRow, fromCol); break;
                                    case 'q': canAttack = isValidQueenMove(r, c, fromRow, fromCol); break;
                                    case 'k': canAttack = isValidKingMove(r, c, fromRow, fromCol); break;
                                    case 'w': canAttack = isValidBishopMove(r, c, fromRow, fromCol) && Math.max(Math.abs(fromRow - r), Math.abs(fromCol - c)) <= 3; break;
                                    case 'd': canAttack = isValidQueenMove(r, c, fromRow, fromCol) && Math.max(Math.abs(fromRow - r), Math.abs(fromCol - c)) <= 4; break;
                                    case 's': canAttack = isValidKnightMove(r, c, fromRow, fromCol); break;
                                    default: canAttack = Math.abs(fromRow - r) <= 1 && Math.abs(fromCol - c) <= 1;
                                }
                                if (canAttack) dealDamage(r, c, 100);
                            }
                        }
                    }
                    break;
                case 'w': // Wizard refresh
                    const targetPieceW = board[toRow][toCol];
                    if (targetPieceW) targetPieceW.abilityUsed = false;
                    break;
                case 'g': // Grandpa summon lizard
                    const gColor = piece.type[0];
                    const lizard = createPiece(gColor + 'l');
                    board[toRow][toCol] = lizard;
                    break;
                case 'l': // Lizard attach
                    const targetPieceL = board[toRow][toCol];
                    if (targetPieceL) {
                        targetPieceL.lizardAttached = true;
                        board[fromRow][fromCol] = null;
                    }
                    break;
                case 't': // Tank fortify
                    for (let r = fromRow - 2; r <= fromRow + 2; r++) {
                        for (let c = fromCol - 2; c <= fromCol + 2; c++) {
                            if (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c]) {
                                const p = board[r][c];
                                if (p.type[0] === piece.type[0]) {
                                    p.shield = (p.shield || 0) + 30;
                                }
                            }
                        }
                    }
                    break;
                case 's': // Assassin backstab
                    dealDamage(toRow, toCol, 40);
                    break;
                case 'd': // Dragon fire breath
                    const breathColor = piece.type[0];
                    for (let r = toRow - 1; r <= toRow + 1; r++) {
                        for (let c = toCol - 1; c <= toCol + 1; c++) {
                            if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                                const breathTarget = board[r][c];
                                if (breathTarget && breathTarget.type[0] === breathColor) continue;
                                dealDamage(r, c, 50);
                            }
                        }
                    }
                    break;
                case 'x': // Saboteur mine
                    if (piece) {
                        const mineOwner = piece.type[0];
                        landmines.push({ row: toRow, col: toCol, owner: mineOwner });
                    }
                    break;
                case 'h': // Ghost possess
                    const targetPieceH = board[toRow][toCol];
                    if (targetPieceH && piece) {
                        piece.stolenSoul = targetPieceH.type[1];
                        board[toRow][toCol] = null;
                    }
                    break;
            }

            // Always switch turn and update - synchronous, guaranteed
            switchTurn();
            clearSelection();
            renderBoard();
            checkGameEnd();
        }

        function isMyTurnOnline() {
            if (gameMode !== 'online') return true;
            return currentTurn === myColor;
        }

        const pieceInfo = {
            'k': { name: 'King', hp: 250, movement: 'Moves 1 square any direction', ability: 'Counter-Strike', abilityDesc: 'Gain shield + deal 100 damage to all pieces attacking the King' },
            'q': { name: 'Queen', hp: 120, movement: 'Moves any direction, any distance', ability: 'Heal', abilityDesc: 'Restore 50 HP to a friendly piece' },
            'r': { name: 'Rook', hp: 75, movement: 'Moves in straight lines (horizontal/vertical)', ability: 'Cannon', abilityDesc: 'Fire a cannonball dealing 35 damage' },
            'b': { name: 'Bishop', hp: 75, movement: 'Moves diagonally any distance', ability: 'Swap', abilityDesc: 'Teleport-swap with an enemy, both take 15 damage' },
            'n': { name: 'Knight', hp: 75, movement: 'L-shape jumps (2+1 squares)', ability: 'Slam', abilityDesc: 'Jump to a square and deal 30 damage in 3x3 area' },
            'p': { name: 'Pawn', hp: 30, movement: 'Forward 1 (or 2 from start), captures diagonally', ability: 'Shoot', abilityDesc: 'Fire a bullet at the first enemy ahead for 20 damage' },
            'w': { name: 'Wizard', hp: 90, movement: 'Moves diagonally up to 3 squares', ability: 'Restore', abilityDesc: 'Refresh a friendly piece\'s used ability' },
            'g': { name: 'Grandpa', hp: 60, movement: 'Moves 1 square any direction', ability: 'Release Lizard', abilityDesc: 'Place a Lizard ally on an adjacent empty square' },
            'l': { name: 'Lizard', hp: 200, movement: 'Moves 1 square any direction', ability: 'Attach', abilityDesc: 'Jump to an enemy within 3 squares, poisoning them + area (10 dmg/turn)' },
            't': { name: 'Tank', hp: 200, movement: 'Moves 1 square any direction', ability: 'Area Shield', abilityDesc: 'Grant +30 shield to all friendly pieces within 2 squares' },
            's': { name: 'Assassin', hp: 60, movement: 'Moves in L-shape like Knight', ability: 'Backstab', abilityDesc: 'Deal 40 damage to an enemy within 2 squares' },
            'd': { name: 'Dragon', hp: 150, movement: 'Moves any direction up to 4 squares', ability: 'Fire Breath', abilityDesc: 'Burn a 3x3 area dealing 50 damage to all' },
            'h': { name: 'Ghost', hp: 10, movement: '1 square (or copies stolen piece\'s movement)', ability: 'Steal Soul', abilityDesc: 'Copy an enemy\'s movement type and kill them (not King)' },
            'x': { name: 'Saboteur', hp: 80, movement: 'Moves 1 square any direction', ability: 'Place Landmine', abilityDesc: 'Set an explosive trap on an empty square (60 dmg)' }
        };

        function createPiece(type) {
            if (!type) return null;
            const healthMap = {
                'k': 250, 'q': 120, 'r': 75, 'b': 75, 'n': 75, 'p': 30,
                'w': 90, 'g': 60, 'l': 200, 't': 200, 's': 60, 'd': 150, 'h': 10, 'x': 80
            };
            const pieceType = type[1];
            const maxHealth = healthMap[pieceType] || 50;
            const piece = {
                type: type,
                abilityUsed: false,
                id: pieceIdCounter++,
                health: maxHealth,
                maxHealth: maxHealth
            };
            if (pieceType === 'k' || pieceType === 'r') {
                piece.hasMoved = false;
            }
            return piece;
        }

        function initStandardBoard() {
            pieceIdCounter = 0;
            landmines = [];
            board = [
                [createPiece('br'), createPiece('bn'), createPiece('bb'), createPiece('bq'), createPiece('bk'), createPiece('bb'), createPiece('bn'), createPiece('br')],
                [createPiece('bp'), createPiece('bp'), createPiece('bp'), createPiece('bp'), createPiece('bp'), createPiece('bp'), createPiece('bp'), createPiece('bp')],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [createPiece('wp'), createPiece('wp'), createPiece('wp'), createPiece('wp'), createPiece('wp'), createPiece('wp'), createPiece('wp'), createPiece('wp')],
                [createPiece('wr'), createPiece('wn'), createPiece('wb'), createPiece('wq'), createPiece('wk'), createPiece('wb'), createPiece('wn'), createPiece('wr')]
            ];
        }

        // ====== MODE SELECTOR FUNCTIONS ======
        function selectOpponent(mode) {
            gameMode = mode;
            document.getElementById('pvp-btn').classList.remove('selected');
            document.getElementById('pvc-btn').classList.remove('selected');
            document.getElementById('online-btn').classList.remove('selected');
            
            if (mode === 'pvp') {
                document.getElementById('pvp-btn').classList.add('selected');
                document.getElementById('ai-difficulty-section').style.display = 'none';
                document.getElementById('online-info-section').style.display = 'none';
            } else if (mode === 'online') {
                document.getElementById('online-btn').classList.add('selected');
                document.getElementById('ai-difficulty-section').style.display = 'none';
                document.getElementById('online-info-section').style.display = 'block';
            } else if (mode === 'pvc') {
                document.getElementById('pvc-btn').classList.add('selected');
                document.getElementById('ai-difficulty-section').style.display = 'block';
                document.getElementById('online-info-section').style.display = 'none';
            }
            document.getElementById('start-game-btn').style.display = 'block';
        }

        function updateDifficultyDisplay() {
            const slider = document.getElementById('difficulty-slider');
            const display = document.getElementById('difficulty-value');
            aiDifficulty = parseInt(slider.value);
            display.textContent = aiDifficulty;
        }

        function startSelectedGame() {
            if (gameMode === 'online') {
                // Show the lobby and connect
                document.getElementById('mode-selector').classList.add('hidden');
                document.getElementById('online-lobby-overlay').classList.remove('hidden');
                document.getElementById('lobby-menu').style.display = 'block';
                document.getElementById('lobby-waiting').style.display = 'none';
                document.getElementById('lobby-code-input').value = '';
                onlineConnect();
                return;
            }

            document.getElementById('mode-selector').classList.add('hidden');
            document.getElementById('battle-title').textContent = 'CHESS WARFARE';
            
            initStandardBoard();
            initPieceReferenceGuide();
            gameActive = true;
            renderBoard();
        }

        // ====== PIECE REFERENCE GUIDE ======
        function initPieceReferenceGuide() {
            const grid = document.getElementById('piece-reference-grid');
            grid.innerHTML = '';
            const standardTypes = ['k', 'q', 'r', 'b', 'n', 'p'];
            standardTypes.forEach(type => {
                const info = pieceInfo[type];
                const pieceSymbol = getPieceSVG(type, true);
                const item = document.createElement('div');
                item.className = 'piece-ref-item';
                item.setAttribute('data-type', type);
                item.innerHTML = `
                    <div class="piece-ref-icon">${pieceSymbol}</div>
                    <div class="piece-ref-name">${info.name}</div>
                    <div class="piece-ref-hp">❤️ ${info.hp} HP</div>
                    <div class="piece-ref-ability">
                        <div class="piece-ref-ability-name">⚡ ${info.ability}</div>
                        <div class="piece-ref-ability-desc">${info.abilityDesc}</div>
                    </div>
                `;
                grid.appendChild(item);
            });
        }

        function highlightPieceInGuide(piece) {
            document.querySelectorAll('.piece-ref-item').forEach(el => el.classList.remove('highlighted'));
            if (!piece) return;
            const type = piece.type[1];
            const el = document.querySelector(`.piece-ref-item[data-type="${type}"]`);
            if (el) el.classList.add('highlighted');
        }

        // ====== BOARD RENDERING ======
        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;

                    const piece = board[row][col];

                    if (piece && piece.type[1] === 'k') {
                        const kingColor = piece.type[0];
                        if (isKingInCheck(kingColor)) {
                            square.classList.add('in-check');
                        }
                    }
                    if (piece) {
                        const color = piece.type[0] === 'w' ? 'white' : 'black';
                        const isWhite = piece.type[0] === 'w';
                        const type = piece.type[1];
                        const pieceSymbol = getPieceSVG(type, isWhite);
                        let pieceName = type;

                        if (pieceEmojis[type]) {
                            const nameMap = {
                                w: 'Wizard', g: 'Grandpa', l: 'Lizard', t: 'Tank',
                                s: 'Assassin', d: 'Dragon', h: 'Ghost', x: 'Saboteur'
                            };
                            pieceName = nameMap[type] || type;
                        } else {
                            const pieceMap = {
                                k: 'King', q: 'Queen', r: 'Rook',
                                b: 'Bishop', n: 'Knight', p: 'Pawn'
                            };
                            pieceName = pieceMap[type] || type;
                        }

                        const healthPercent = (piece.health / piece.maxHealth) * 100;
                        const abilityIndicator = !piece.abilityUsed ? `<div class="ability-indicator">⚡</div>` : '';
                        const lizardIndicator = piece.lizardAttached ? `<div class="lizard-indicator">🦎</div>` : '';
                        const shieldVal = piece.shield || 0;
                        const shieldIndicator = shieldVal > 0 ? `<div class="shield-indicator">🛡️${shieldVal}</div>` : '';
                        const shieldTooltip = shieldVal > 0 ? ` +${shieldVal} Shield` : '';

                        let customClass = '';
                        if (pieceEmojis[type]) {
                            const classMap = {
                                w: 'custom-wizard', g: 'custom-grandpa', l: 'custom-lizard',
                                t: 'custom-tank', s: 'custom-assassin', d: 'custom-dragon',
                                h: 'custom-ghost', x: 'custom-saboteur'
                            };
                            customClass = classMap[type] || '';
                        }

                        const shieldBarPercent = shieldVal > 0 ? Math.min((shieldVal / piece.maxHealth) * 100, 100) : 0;

                        square.innerHTML = `
                            <span class="piece ${customClass}" data-tooltip="${pieceName}: ${piece.health}/${piece.maxHealth} HP${shieldTooltip}">
                                ${pieceSymbol}
                            </span>
                            ${abilityIndicator}
                            ${lizardIndicator}
                            ${shieldIndicator}
                            <div class="health-bar-container">
                                <div class="health-bar" style="width: ${healthPercent}%"></div>
                                ${shieldVal > 0 ? `<div class="shield-bar" style="width: ${shieldBarPercent}%"></div>` : ''}
                            </div>
                        `;
                    } else {
                        const hasMine = landmines.some(m => m.row === row && m.col === col);
                        if (hasMine) {
                            square.innerHTML = `<div class="landmine-indicator">💣</div>`;
                        }
                    }

                    square.addEventListener('click', () => handleSquareClick(row, col));
                    square.addEventListener('dblclick', () => handleSquareDoubleClick(row, col));
                    boardEl.appendChild(square);
                }
            }

            updateTurnIndicator();
            calculateMaterialScore();

            if (gameActive && gameMode === 'pvc' && currentTurn === 'black' && !isAIThinking) {
                setTimeout(makeAIMove, 1000);
            }
        }

        // ====== INPUT HANDLING ======
        function handleSquareClick(row, col) {
            if (!gameActive) return;
            if (gameMode === 'pvc' && currentTurn === 'black') return;

            // Apply any pending board sync from opponent before processing our click
            if (pendingSync && gameMode === 'online' && isMyTurnOnline()) {
                applyPendingSync();
            }

            if (gameMode === 'online' && !isMyTurnOnline() && !isRemoteAction) return;

            const clickedPiece = board[row][col];

            if (selectedSquare !== null) {
                const [selectedRow, selectedCol] = selectedSquare;
                const selectedPiece = board[selectedRow][selectedCol];

                if (activeAbility && selectedPiece && selectedPiece.type[1] === activeAbility) {
                    if (canUseAbility(selectedRow, selectedCol, row, col, activeAbility)) {
                        useAbility(selectedRow, selectedCol, row, col, activeAbility);
                        return;
                    }
                }

                if (isLegalMove(selectedRow, selectedCol, row, col)) {
                    makeMove(selectedRow, selectedCol, row, col);
                    clearSelection();
                    return;
                } else {
                    const playerColor = currentTurn === 'white' ? 'w' : 'b';
                    if (isKingInCheck(playerColor)) {
                        showMessage('⚠️ YOU ARE IN CHECK!', 'You must get your King out of check!');
                        setTimeout(hideMessage, 2000);
                    }
                }

                clearSelection();

                if (clickedPiece && clickedPiece.type[0] === currentTurn[0]) {
                    selectSquare(row, col);
                }
            } else {
                if (clickedPiece && clickedPiece.type[0] === currentTurn[0]) {
                    selectSquare(row, col);
                }
            }
        }

        function handleSquareDoubleClick(row, col) {
            if (!gameActive) return;
            if (gameMode === 'pvc' && currentTurn === 'black') return;

            // Apply any pending board sync before processing
            if (pendingSync && gameMode === 'online' && isMyTurnOnline()) {
                applyPendingSync();
            }

            if (gameMode === 'online' && !isMyTurnOnline()) return;

            const clickedPiece = board[row][col];
            if (!clickedPiece || clickedPiece.type[0] !== currentTurn[0]) return;

            const pieceType = clickedPiece.type[1];
            if (clickedPiece.abilityUsed) {
                showMessage('⚠️ ABILITY USED', 'This piece already used its ability!');
                setTimeout(hideMessage, 1500);
                return;
            }

            if (activeAbility === pieceType) {
                activeAbility = null;
                clearSelection();
            } else {
                activeAbility = pieceType;
                selectSquare(row, col);
            }
        }

        // ====== AI ======
        // Fast engine: no isLegalMove in eval, quiescence search, transposition table

        // Piece values (centipawns, Stockfish-tuned ratios)
        const PIECE_VALUES = { 
            k: 10000, q: 950, d: 900, r: 500, b: 340, n: 330, 
            w: 550, t: 650, s: 380, g: 300, l: 350, h: 280, x: 320, p: 100 
        };

        // Piece-Square Tables (from piece's own perspective, row 0 = own back rank)
        // Adapted from Stockfish's tuned middlegame tables
        const PST = {
            p: [
                [ 0,  0,  0,  0,  0,  0,  0,  0],
                [ 5, 10, 10,-20,-20, 10, 10,  5],
                [ 5, -5,-10,  0,  0,-10, -5,  5],
                [ 0,  0,  0, 25, 25,  0,  0,  0],
                [ 5,  5, 10, 30, 30, 10,  5,  5],
                [10, 10, 20, 35, 35, 20, 10, 10],
                [50, 50, 50, 50, 50, 50, 50, 50],
                [ 0,  0,  0,  0,  0,  0,  0,  0]
            ],
            n: [
                [-50,-40,-30,-30,-30,-30,-40,-50],
                [-40,-20,  0,  0,  0,  0,-20,-40],
                [-30,  0, 10, 15, 15, 10,  0,-30],
                [-30,  5, 15, 20, 20, 15,  5,-30],
                [-30,  0, 15, 20, 20, 15,  0,-30],
                [-30,  5, 10, 15, 15, 10,  5,-30],
                [-40,-20,  0,  5,  5,  0,-20,-40],
                [-50,-40,-30,-30,-30,-30,-40,-50]
            ],
            b: [
                [-20,-10,-10,-10,-10,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0, 10, 10, 10, 10,  0,-10],
                [-10,  5,  5, 10, 10,  5,  5,-10],
                [-10,  0, 10, 10, 10, 10,  0,-10],
                [-10, 10, 10, 10, 10, 10, 10,-10],
                [-10,  5,  0,  0,  0,  0,  5,-10],
                [-20,-10,-10,-10,-10,-10,-10,-20]
            ],
            r: [
                [  0,  0,  0,  5,  5,  0,  0,  0],
                [ -5,  0,  0,  0,  0,  0,  0, -5],
                [ -5,  0,  0,  0,  0,  0,  0, -5],
                [ -5,  0,  0,  0,  0,  0,  0, -5],
                [ -5,  0,  0,  0,  0,  0,  0, -5],
                [ -5,  0,  0,  0,  0,  0,  0, -5],
                [  5, 10, 10, 10, 10, 10, 10,  5],
                [  0,  0,  0,  0,  0,  0,  0,  0]
            ],
            q: [
                [-20,-10,-10, -5, -5,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0,  5,  5,  5,  5,  0,-10],
                [ -5,  0,  5,  5,  5,  5,  0, -5],
                [  0,  0,  5,  5,  5,  5,  0, -5],
                [-10,  5,  5,  5,  5,  5,  0,-10],
                [-10,  0,  5,  0,  0,  0,  0,-10],
                [-20,-10,-10, -5, -5,-10,-10,-20]
            ],
            k_mg: [ // King middlegame: stay castled
                [ 20, 30, 10,  0,  0, 10, 30, 20],
                [ 20, 20,  0,  0,  0,  0, 20, 20],
                [-10,-20,-20,-20,-20,-20,-20,-10],
                [-20,-30,-30,-40,-40,-30,-30,-20],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30]
            ],
            k_eg: [ // King endgame: centralize
                [-50,-30,-30,-30,-30,-30,-30,-50],
                [-30,-10,  0,  0,  0,  0,-10,-30],
                [-30,  0, 10, 15, 15, 10,  0,-30],
                [-30,  0, 15, 20, 20, 15,  0,-30],
                [-30,  0, 15, 20, 20, 15,  0,-30],
                [-30,  0, 10, 15, 15, 10,  0,-30],
                [-30,-10,  0,  0,  0,  0,-10,-30],
                [-50,-30,-30,-30,-30,-30,-30,-50]
            ],
            default: [
                [  0,  2,  4,  6,  6,  4,  2,  0],
                [  2,  6,  8, 10, 10,  8,  6,  2],
                [  4,  8, 12, 14, 14, 12,  8,  4],
                [  6, 10, 14, 18, 18, 14, 10,  6],
                [  6, 10, 14, 18, 18, 14, 10,  6],
                [  4,  8, 12, 14, 14, 12,  8,  4],
                [  2,  6,  8, 10, 10,  8,  6,  2],
                [  0,  2,  4,  6,  6,  4,  2,  0]
            ]
        };

        // Keep old references for compatibility
        const POSITION_TABLES = PST;
        function getPositionBonus(pieceType, row, col) {
            const table = PST[pieceType] || PST.default;
            return table[row] ? (table[row][col] || 0) : 0;
        }

        // ====== TRANSPOSITION TABLE ======
        const TT = new Map();
        const TT_MAX = 50000;
        const TT_EXACT = 0, TT_LOWER = 1, TT_UPPER = 2;
        let ttHits = 0;

        function boardHash() {
            let h = '';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = board[r][c];
                    if (p) h += p.type + p.health + (p.hasMoved?'1':'0');
                    else h += '.';
                }
            }
            return h;
        }

        // ====== CHESS WARFARE EVALUATION (health, abilities, special pieces) ======
        function evaluateBoard() {
            let score = 0; // positive = good for black (AI)
            let bKing = false, wKing = false;
            let bKingPos = null, wKingPos = null;
            let totalMat = 0;
            let bPawns = [], wPawns = [];
            let bPieces = [], wPieces = [];
            let bAbilitiesLeft = 0, wAbilitiesLeft = 0;
            let bTotalHP = 0, wTotalHP = 0;

            // First pass: gather all info
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = board[r][c];
                    if (!p) continue;
                    const type = p.type[1];
                    const isB = p.type[0] === 'b';
                    const val = PIECE_VALUES[type] || 100;

                    if (type === 'k') {
                        if (isB) { bKing = true; bKingPos = {r,c}; }
                        else { wKing = true; wKingPos = {r,c}; }
                    }
                    if (type !== 'k') totalMat += val;

                    if (isB) {
                        bPieces.push({r, c, type, piece: p, val});
                        bTotalHP += p.health;
                        if (!p.abilityUsed) bAbilitiesLeft++;
                    } else {
                        wPieces.push({r, c, type, piece: p, val});
                        wTotalHP += p.health;
                        if (!p.abilityUsed) wAbilitiesLeft++;
                    }

                    if (type === 'p') {
                        if (isB) bPawns.push({r, c}); else wPawns.push({r, c});
                    }
                }
            }

            if (!wKing) return 999999;
            if (!bKing) return -999999;

            // ====== MATERIAL × HEALTH (the core of Chess Warfare) ======
            // A piece at 50% HP is worth significantly less
            for (const pi of bPieces) {
                const p = pi.piece;
                const hp = p.health / p.maxHealth;
                let ps = pi.val * hp;

                // Piece-square positioning
                const evalRow = pi.r;
                const table = (pi.type === 'k')
                    ? (totalMat > 2500 ? PST.k_mg : PST.k_eg)
                    : (PST[pi.type] || PST.default);
                if (table[evalRow]) ps += table[evalRow][pi.c];

                // ====== ABILITY RESOURCE VALUE ======
                // Unused abilities are a strategic asset — value varies by piece type
                if (!p.abilityUsed) {
                    const abilityValues = {
                        d: 120, k: 80, q: 90, n: 70, r: 60, t: 80, s: 65,
                        h: 55, l: 50, g: 80, x: 40, b: 40, w: 100, p: 20
                    };
                    ps += abilityValues[pi.type] || 15;
                }

                // Shield bonus
                if (p.shield) ps += p.shield * 0.5;

                // ====== SPECIAL PIECE BONUSES ======
                // Dragon in center = terrifying
                if (pi.type === 'd') {
                    if (pi.r >= 2 && pi.r <= 5 && pi.c >= 2 && pi.c <= 5) ps += 40;
                    if (!p.abilityUsed) ps += 50; // Dragon with fire breath is a huge threat
                }
                // Assassin near enemy pieces = dangerous
                if (pi.type === 's') {
                    let nearEnemies = 0;
                    for (const ep of wPieces) {
                        if (Math.abs(ep.r - pi.r) <= 2 && Math.abs(ep.c - pi.c) <= 2) nearEnemies++;
                    }
                    ps += nearEnemies * 15;
                }
                // Tank near friendly cluster = strong
                if (pi.type === 't') {
                    let nearFriends = 0;
                    for (const fp of bPieces) {
                        if (Math.abs(fp.r - pi.r) <= 2 && Math.abs(fp.c - pi.c) <= 2 && fp !== pi) nearFriends++;
                    }
                    ps += nearFriends * 12;
                    if (!p.abilityUsed) ps += nearFriends * 8; // Tank can shield them all
                }
                // Wizard with refresh = force multiplier
                if (pi.type === 'w' && !p.abilityUsed) {
                    // Count friendly pieces with used abilities that are still alive
                    let refreshTargets = bPieces.filter(fp => fp.piece.abilityUsed && fp.type !== 'w').length;
                    ps += refreshTargets * 18;
                }
                // Grandpa who hasn't spawned = potential material
                if (pi.type === 'g' && !p.abilityUsed) ps += 60;

                // Low HP pieces under attack = in danger (penalty for being vulnerable)
                if (hp < 0.4 && pi.type !== 'k') {
                    if (isSquareUnderAttack(pi.r, pi.c, 'w')) ps -= pi.val * 0.3;
                }

                score += ps;
            }

            for (const pi of wPieces) {
                const p = pi.piece;
                const hp = p.health / p.maxHealth;
                let ps = pi.val * hp;

                const evalRow = 7 - pi.r;
                const table = (pi.type === 'k')
                    ? (totalMat > 2500 ? PST.k_mg : PST.k_eg)
                    : (PST[pi.type] || PST.default);
                if (table[evalRow]) ps += table[evalRow][pi.c];

                if (!p.abilityUsed) {
                    const abilityValues = {
                        d: 120, k: 80, q: 90, n: 70, r: 60, t: 80, s: 65,
                        h: 55, l: 50, g: 80, x: 40, b: 40, w: 100, p: 20
                    };
                    ps += abilityValues[pi.type] || 15;
                }
                if (p.shield) ps += p.shield * 0.5;

                if (pi.type === 'd') {
                    if (pi.r >= 2 && pi.r <= 5 && pi.c >= 2 && pi.c <= 5) ps += 40;
                    if (!p.abilityUsed) ps += 50;
                }
                if (pi.type === 's') {
                    let nearEnemies = 0;
                    for (const ep of bPieces) {
                        if (Math.abs(ep.r - pi.r) <= 2 && Math.abs(ep.c - pi.c) <= 2) nearEnemies++;
                    }
                    ps += nearEnemies * 15;
                }
                if (pi.type === 't') {
                    let nearFriends = 0;
                    for (const fp of wPieces) {
                        if (Math.abs(fp.r - pi.r) <= 2 && Math.abs(fp.c - pi.c) <= 2 && fp !== pi) nearFriends++;
                    }
                    ps += nearFriends * 12;
                    if (!p.abilityUsed) ps += nearFriends * 8;
                }
                if (pi.type === 'w' && !p.abilityUsed) {
                    let refreshTargets = wPieces.filter(fp => fp.piece.abilityUsed && fp.type !== 'w').length;
                    ps += refreshTargets * 18;
                }
                if (pi.type === 'g' && !p.abilityUsed) ps += 60;

                if (hp < 0.4 && pi.type !== 'k') {
                    if (isSquareUnderAttack(pi.r, pi.c, 'b')) ps -= pi.val * 0.3;
                }

                score -= ps;
            }

            // ====== KING HEALTH IS CRITICAL (can win by HP drain) ======
            if (bKingPos) {
                const bk = board[bKingPos.r][bKingPos.c];
                if (bk) {
                    const bkHP = bk.health / bk.maxHealth;
                    if (bkHP < 0.3) score -= 200; // Our king is dangerously low
                    if (bkHP < 0.15) score -= 400; // Almost dead
                }
            }
            if (wKingPos) {
                const wk = board[wKingPos.r][wKingPos.c];
                if (wk) {
                    const wkHP = wk.health / wk.maxHealth;
                    if (wkHP < 0.3) score += 200; // Enemy king is dangerously low
                    if (wkHP < 0.15) score += 400; // Almost dead — go for kill
                }
            }

            // ====== ABILITY ADVANTAGE ======
            // Having more abilities left = more options = strategic advantage
            score += (bAbilitiesLeft - wAbilitiesLeft) * 18;

            // ====== PAWN STRUCTURE ======
            for (const p of bPawns) {
                if (bPawns.some(o => o.c === p.c && o.r !== p.r)) score -= 12;
                if (!bPawns.some(o => Math.abs(o.c - p.c) === 1)) score -= 10;
                if (!wPawns.some(o => Math.abs(o.c - p.c) <= 1 && o.r > p.r)) {
                    score += 20 + p.r * 12;
                }
            }
            for (const p of wPawns) {
                if (wPawns.some(o => o.c === p.c && o.r !== p.r)) score += 12;
                if (!wPawns.some(o => Math.abs(o.c - p.c) === 1)) score += 10;
                if (!bPawns.some(o => Math.abs(o.c - p.c) <= 1 && o.r < p.r)) {
                    score -= 20 + (7 - p.r) * 12;
                }
            }

            // ====== KING SAFETY (pawn shield + piece proximity) ======
            if (totalMat > 2500) {
                // Black king safety
                if (bKingPos) {
                    let shield = 0;
                    for (let dc = -1; dc <= 1; dc++) {
                        const sc = bKingPos.c + dc;
                        const sr = bKingPos.r + 1;
                        if (sc >= 0 && sc < 8 && sr >= 0 && sr < 8) {
                            const sp = board[sr][sc];
                            if (sp && sp.type[1] === 'p' && sp.type[0] === 'b') shield += 18;
                        }
                    }
                    // Nearby friendly pieces provide protection
                    let defenders = 0;
                    for (const fp of bPieces) {
                        if (Math.abs(fp.r - bKingPos.r) <= 2 && Math.abs(fp.c - bKingPos.c) <= 2) defenders++;
                    }
                    score += shield + defenders * 5;
                }
                // White king safety
                if (wKingPos) {
                    let shield = 0;
                    for (let dc = -1; dc <= 1; dc++) {
                        const sc = wKingPos.c + dc;
                        const sr = wKingPos.r - 1;
                        if (sc >= 0 && sc < 8 && sr >= 0 && sr < 8) {
                            const sp = board[sr][sc];
                            if (sp && sp.type[1] === 'p' && sp.type[0] === 'w') shield += 18;
                        }
                    }
                    let defenders = 0;
                    for (const fp of wPieces) {
                        if (Math.abs(fp.r - wKingPos.r) <= 2 && Math.abs(fp.c - wKingPos.c) <= 2) defenders++;
                    }
                    score -= shield + defenders * 5;
                }
            }

            // ====== LANDMINE AWARENESS ======
            // Landmines near enemy king = threatening
            for (const mine of landmines) {
                if (mine.color === 'b' && wKingPos) {
                    const dist = Math.abs(mine.row - wKingPos.r) + Math.abs(mine.col - wKingPos.c);
                    if (dist <= 3) score += 40;
                }
                if (mine.color === 'w' && bKingPos) {
                    const dist = Math.abs(mine.row - bKingPos.r) + Math.abs(mine.col - bKingPos.c);
                    if (dist <= 3) score -= 40;
                }
            }

            // Check bonuses
            if (isKingInCheck('w')) score += 50;
            if (isKingInCheck('b')) score -= 50;

            return score;
        }

        // ====== QUIESCENCE SEARCH (captures only — avoids horizon effect) ======
        function quiescence(alpha, beta, isMaximizing, qDepth) {
            const standPat = evaluateBoard();
            if (qDepth <= 0) return standPat;

            if (isMaximizing) {
                if (standPat >= beta) return beta;
                if (standPat > alpha) alpha = standPat;
            } else {
                if (standPat <= alpha) return alpha;
                if (standPat < beta) beta = standPat;
            }

            const color = isMaximizing ? 'b' : 'w';
            const enemy = isMaximizing ? 'w' : 'b';

            // Generate capture moves only (much faster than all moves)
            for (let fr = 0; fr < 8; fr++) {
                for (let fc = 0; fc < 8; fc++) {
                    const p = board[fr][fc];
                    if (!p || p.type[0] !== color) continue;
                    for (let tr = 0; tr < 8; tr++) {
                        for (let tc = 0; tc < 8; tc++) {
                            const target = board[tr][tc];
                            if (!target || target.type[0] !== enemy) continue;
                            if (!isLegalMove(fr, fc, tr, tc)) continue;

                            // Delta pruning: skip if capture can't raise alpha
                            const captureVal = PIECE_VALUES[target.type[1]] || 100;
                            if (isMaximizing && standPat + captureVal + 200 < alpha) continue;
                            if (!isMaximizing && standPat - captureVal - 200 > beta) continue;

                            const mp = board[fr][fc];
                            const cp = board[tr][tc];
                            const oh = mp.hasMoved;
                            board[tr][tc] = mp;
                            board[fr][fc] = null;
                            if (mp.hasMoved !== undefined) mp.hasMoved = true;

                            const val = quiescence(alpha, beta, !isMaximizing, qDepth - 1);

                            board[fr][fc] = mp;
                            board[tr][tc] = cp;
                            if (oh !== undefined) mp.hasMoved = oh;

                            if (isMaximizing) {
                                if (val > alpha) alpha = val;
                                if (alpha >= beta) return beta;
                            } else {
                                if (val < beta) beta = val;
                                if (alpha >= beta) return alpha;
                            }
                        }
                    }
                }
            }

            return isMaximizing ? alpha : beta;
        }

        // ====== MINIMAX WITH ALPHA-BETA + TT ======
        function minimax(depth, alpha, beta, isMaximizing) {
            // TT lookup
            const hash = boardHash();
            const ttE = TT.get(hash);
            if (ttE && ttE.depth >= depth) {
                if (ttE.flag === TT_EXACT) return ttE.score;
                if (ttE.flag === TT_LOWER && ttE.score > alpha) alpha = ttE.score;
                if (ttE.flag === TT_UPPER && ttE.score < beta) beta = ttE.score;
                if (alpha >= beta) { ttHits++; return ttE.score; }
            }

            if (depth <= 0) return quiescence(alpha, beta, isMaximizing, 3);

            const color = isMaximizing ? 'b' : 'w';
            const moves = getAllValidMoves(color);

            if (moves.length === 0) {
                if (isKingInCheck(color)) {
                    return isMaximizing ? -999999 + (30 - depth) : 999999 - (30 - depth);
                }
                return 0; // Stalemate
            }

            // Move ordering: captures by MVV-LVA first, then positional
            moves.sort((a, b) => {
                let sa = 0, sb = 0;
                const at = board[a.to.row][a.to.col];
                const bt = board[b.to.row][b.to.col];
                if (at && at.type[0] !== color) sa += (PIECE_VALUES[at.type[1]]||100)*10 - (PIECE_VALUES[board[a.from.row][a.from.col].type[1]]||100);
                if (bt && bt.type[0] !== color) sb += (PIECE_VALUES[bt.type[1]]||100)*10 - (PIECE_VALUES[board[b.from.row][b.from.col].type[1]]||100);
                return sb - sa;
            });

            let bestScore = isMaximizing ? -Infinity : Infinity;
            let ttFlag = isMaximizing ? TT_UPPER : TT_LOWER;

            for (let i = 0; i < moves.length; i++) {
                const move = moves[i];
                const mp = board[move.from.row][move.from.col];
                const cp = board[move.to.row][move.to.col];
                const oh = mp.hasMoved;

                board[move.to.row][move.to.col] = mp;
                board[move.from.row][move.from.col] = null;
                if (mp.hasMoved !== undefined) mp.hasMoved = true;

                // Late move reduction: reduce depth for late quiet moves
                let reduction = 0;
                if (depth >= 3 && i >= 4 && !cp) reduction = 1;

                let val = minimax(depth - 1 - reduction, alpha, beta, !isMaximizing);

                // Re-search at full depth if reduced search found something good
                if (reduction > 0) {
                    if (isMaximizing && val > alpha) {
                        val = minimax(depth - 1, alpha, beta, !isMaximizing);
                    } else if (!isMaximizing && val < beta) {
                        val = minimax(depth - 1, alpha, beta, !isMaximizing);
                    }
                }

                board[move.from.row][move.from.col] = mp;
                board[move.to.row][move.to.col] = cp;
                if (oh !== undefined) mp.hasMoved = oh;

                if (isMaximizing) {
                    if (val > bestScore) bestScore = val;
                    if (val > alpha) { alpha = val; ttFlag = TT_EXACT; }
                    if (alpha >= beta) { ttFlag = TT_LOWER; break; }
                } else {
                    if (val < bestScore) bestScore = val;
                    if (val < beta) { beta = val; ttFlag = TT_EXACT; }
                    if (alpha >= beta) { ttFlag = TT_UPPER; break; }
                }
            }

            // Store in TT
            if (TT.size > TT_MAX) TT.clear();
            TT.set(hash, { depth, score: bestScore, flag: ttFlag });

            return bestScore;
        }

        // ====== CHESS WARFARE MOVE SCORER (for pre-ordering) ======
        function scoreMoveFast(move) {
            const { from, to } = move;
            const piece = board[from.row][from.col];
            const target = board[to.row][to.col];
            const type = piece.type[1];
            let s = 0;

            // Captures: MVV-LVA, factoring in health
            if (target && target.type[0] !== piece.type[0]) {
                const victimVal = PIECE_VALUES[target.type[1]] || 100;
                const attackerVal = PIECE_VALUES[type] || 100;
                s += victimVal * 10 - attackerVal;
                // Low HP kill bonus — almost-dead pieces are easy kills
                if (target.health <= 30) s += 300;
                else if (target.health <= 50) s += 150;
                // Capturing a piece with unused ability = denying them a resource
                if (!target.abilityUsed) s += 80;
                // Capturing the king directly (HP kill) is game-ending
                if (target.type[1] === 'k') s += 5000;
            }

            // Positional improvement
            const evalRow = 7 - to.row;
            const oldEvalRow = 7 - from.row;
            const table = PST[type] || PST.default;
            s += (table[evalRow]?.[to.col] || 0) - (table[oldEvalRow]?.[from.col] || 0);

            // Development: pieces off back rank early
            if (from.row === 0 && type !== 'k' && type !== 'r') s += 25;

            // Center control (crucial in Chess Warfare for ability range)
            if (to.row >= 2 && to.row <= 5 && to.col >= 2 && to.col <= 5) {
                if (type === 'p') s += 20;
                else if (type === 'd' || type === 'n') s += 15; // Dragon and Knight benefit from center
            }

            // Move toward enemy king (aggression bonus for attack pieces)
            const enemyKingPos = findKingPos('w');
            if (enemyKingPos && (type === 'q' || type === 'd' || type === 's' || type === 'r')) {
                const oldDist = Math.abs(from.row - enemyKingPos.r) + Math.abs(from.col - enemyKingPos.c);
                const newDist = Math.abs(to.row - enemyKingPos.r) + Math.abs(to.col - enemyKingPos.c);
                if (newDist < oldDist) s += 10;
            }

            // Avoid hanging pieces
            if (!target && isSquareUnderAttack(to.row, to.col, 'w')) {
                const myVal = PIECE_VALUES[type] || 100;
                if (myVal > 200) s -= myVal;
                // Even worse if we have an unused ability — losing that piece loses the ability
                if (!piece.abilityUsed) s -= 50;
            }

            // Avoid landmines!
            if (landmines.some(m => m.row === to.row && m.col === to.col && m.color !== piece.type[0])) {
                s -= 200;
            }

            return s;
        }

        // Helper to find king position quickly
        function findKingPos(color) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = board[r][c];
                    if (p && p.type[0] === color && p.type[1] === 'k') return {r, c};
                }
            }
            return null;
        }

        function isSquareDefended(row, col, byColor) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = board[r][c];
                    if (!p || p.type[0] !== byColor) continue;
                    if (r === row && c === col) continue;
                    const type = p.type[1];
                    switch (type) {
                        case 'p': { const dir = byColor === 'w' ? -1 : 1; if (Math.abs(col-c)===1 && row===r+dir) return true; break; }
                        case 'r': if (isValidRookMove(r,c,row,col)) return true; break;
                        case 'n': if (isValidKnightMove(r,c,row,col)) return true; break;
                        case 'b': if (isValidBishopMove(r,c,row,col)) return true; break;
                        case 'q': if (isValidQueenMove(r,c,row,col)) return true; break;
                        case 'k': if (isValidKingMove(r,c,row,col)) return true; break;
                        case 's': if (isValidKnightMove(r,c,row,col)) return true; break;
                        case 'd': if (isValidQueenMove(r,c,row,col) && Math.max(Math.abs(row-r),Math.abs(col-c))<=4) return true; break;
                        case 'w': if (isValidBishopMove(r,c,row,col) && Math.max(Math.abs(row-r),Math.abs(col-c))<=3) return true; break;
                        default: if (Math.abs(row-r)<=1 && Math.abs(col-c)<=1) return true; break;
                    }
                }
            }
            return false;
        }

        // ====== MAIN AI MOVE FUNCTION ======
        function makeAIMove() {
            if (!gameActive || currentTurn !== 'black' || isAIThinking) return;
            isAIThinking = true;

            setTimeout(() => {
                try {
                    TT.clear();
                    ttHits = 0;

                    const diff = aiDifficulty;
                    const kingInCheck = isKingInCheck('b');

                    // ====== DIFFICULTY SCALING ======
                    //  1-20:  Pure random moves, no abilities
                    // 21-40:  Avoid blunders, basic ability use
                    // 41-60:  Depth 2 search + smart abilities
                    // 61-80:  Depth 3 search + always consider best ability
                    // 81-100: Depth 4-5 search + optimal ability timing

                    // === GATHER ABILITIES ===
                    let bestAbility = null;
                    let bestAbilityScore = -Infinity;

                    if (diff > 20) {
                        const abilityMoves = getAllValidAbilityMoves('b');
                        const filteredAbilities = kingInCheck
                            ? abilityMoves.filter(m => m.abilityType === 'k')
                            : abilityMoves;

                        if (filteredAbilities.length > 0) {
                            for (const m of filteredAbilities) {
                                const s = scoreAbilityMove(m);
                                if (s > bestAbilityScore) {
                                    bestAbilityScore = s;
                                    bestAbility = m;
                                }
                            }
                        }
                    }

                    // === GATHER MOVES ===
                    const allMoves = getAllValidMoves('b');
                    if (allMoves.length === 0) {
                        // No moves — try ability as last resort, or stalemate/checkmate
                        if (bestAbility) {
                            useAbility(bestAbility.from.row, bestAbility.from.col, bestAbility.to.row, bestAbility.to.col, bestAbility.abilityType);
                        } else {
                            checkGameEnd();
                        }
                        isAIThinking = false;
                        return;
                    }

                    // === DECIDE: ABILITY OR MOVE? ===
                    let chosenMove = null;
                    let chosenMoveScore = -Infinity;

                    if (diff <= 20) {
                        // Pure random
                        chosenMove = allMoves[Math.floor(Math.random() * allMoves.length)];
                        makeMove(chosenMove.from.row, chosenMove.from.col, chosenMove.to.row, chosenMove.to.col);
                        isAIThinking = false;
                        return;

                    } else if (diff <= 40) {
                        // Avoid blunders, prefer captures
                        const safe = allMoves.filter(m => {
                            const val = PIECE_VALUES[board[m.from.row][m.from.col].type[1]] || 100;
                            const cap = board[m.to.row][m.to.col];
                            const capVal = cap ? (PIECE_VALUES[cap.type[1]] || 0) : 0;
                            if (isSquareUnderAttack(m.to.row, m.to.col, 'w') && capVal < val && val > 200) return false;
                            return true;
                        });
                        const pool = safe.length > 0 ? safe : allMoves;
                        const captures = pool.filter(m => board[m.to.row][m.to.col]);
                        if (captures.length > 0 && Math.random() < 0.6) {
                            chosenMove = captures[Math.floor(Math.random() * captures.length)];
                        } else {
                            chosenMove = pool[Math.floor(Math.random() * pool.length)];
                        }
                        chosenMoveScore = scoreMoveFast(chosenMove);

                    } else {
                        // Search-based play
                        const depth = diff <= 60 ? 2 : diff <= 80 ? 3 : diff <= 95 ? 4 : 5;
                        chosenMove = searchBestMove(allMoves, depth);
                        chosenMoveScore = searchLastBestScore;
                    }

                    // === UNIFIED COMPARISON: ability vs move ===
                    // Convert ability score to same scale as minimax score
                    // Ability scores are in "centipawn-like" units already
                    // Minimax scores are the full board evaluation
                    // We compare: is the ability clearly better than just making a move?
                    if (bestAbility && bestAbilityScore > 0 && diff > 20) {
                        // At higher difficulties, use abilities more aggressively
                        let abilityThreshold;
                        if (diff <= 40) {
                            abilityThreshold = 150; // Only use really obvious abilities
                        } else if (diff <= 60) {
                            abilityThreshold = 80;  // Use good abilities
                        } else if (diff <= 80) {
                            abilityThreshold = 40;  // Use most beneficial abilities
                        } else {
                            abilityThreshold = 15;  // Use almost any positive ability
                        }

                        // Kill abilities (score > 500) should ALWAYS be used
                        // Heal king abilities should be heavily favored
                        if (bestAbilityScore > 500 || bestAbilityScore > abilityThreshold) {
                            useAbility(bestAbility.from.row, bestAbility.from.col, bestAbility.to.row, bestAbility.to.col, bestAbility.abilityType);
                            isAIThinking = false;
                            return;
                        }
                    }

                    makeMove(chosenMove.from.row, chosenMove.from.col, chosenMove.to.row, chosenMove.to.col);
                } catch(e) {
                    console.error('AI error:', e);
                    const allMoves = getAllValidMoves('b');
                    if (allMoves.length > 0) {
                        allMoves.sort((a,b) => scoreMoveFast(b) - scoreMoveFast(a));
                        makeMove(allMoves[0].from.row, allMoves[0].from.col, allMoves[0].to.row, allMoves[0].to.col);
                    }
                }
                isAIThinking = false;
            }, 300);
        }

        let searchLastBestScore = 0;

        function searchBestMove(moves, depth) {
            // Pre-sort moves for better alpha-beta pruning
            moves.sort((a, b) => scoreMoveFast(b) - scoreMoveFast(a));

            let bestMove = moves[0];
            let bestScore = -Infinity;
            let alpha = -Infinity;
            const beta = Infinity;

            for (let i = 0; i < moves.length; i++) {
                const move = moves[i];
                const mp = board[move.from.row][move.from.col];
                const cp = board[move.to.row][move.to.col];
                const oh = mp.hasMoved;

                board[move.to.row][move.to.col] = mp;
                board[move.from.row][move.from.col] = null;
                if (mp.hasMoved !== undefined) mp.hasMoved = true;

                // Use aspiration window for faster search after first move
                let score;
                if (i === 0) {
                    score = minimax(depth - 1, -Infinity, Infinity, false);
                } else {
                    // Null window search
                    score = minimax(depth - 1, alpha, alpha + 1, false);
                    if (score > alpha) {
                        // Re-search with full window
                        score = minimax(depth - 1, alpha, Infinity, false);
                    }
                }

                board[move.from.row][move.from.col] = mp;
                board[move.to.row][move.to.col] = cp;
                if (oh !== undefined) mp.hasMoved = oh;

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                    if (score > alpha) alpha = score;
                }
            }

            searchLastBestScore = bestScore;
            return bestMove;
        }

        // Compatibility wrappers
        function scoreMove(moveData, difficulty) { return scoreMoveFast(moveData); }
        function canOpponentCheckmateIn1() { return false; } // handled by minimax depth now
        function getDefendedPieces(row, col, color) {
            let count = 0;
            for (let r = row-1; r <= row+1; r++) {
                for (let c = col-1; c <= col+1; c++) {
                    if (r>=0 && r<8 && c>=0 && c<8 && board[r][c] && board[r][c].type[0]===color && (r!==row||c!==col)) count++;
                }
            }
            return count;
        }

        function scoreAbilityMove(moveData) {
            const { from, to, abilityType } = moveData;
            const piece = board[from.row][from.col];
            const target = board[to.row][to.col];
            if (!piece) return -9999;
            const myColor = piece.type[0];
            const enemyColor = myColor === 'b' ? 'w' : 'b';
            let score = 0;

            // Damage maps for kill detection
            const dmgMap = { p: 20, r: 35, s: 40, d: 50, n: 30, b: 15, l: 0, h: 0 };

            switch (abilityType) {
                case 'p': { // Pawn shoot — 20 damage, first enemy ahead
                    if (!target || target.type[0] === myColor) break;
                    const tv = PIECE_VALUES[target.type[1]] || 100;
                    if (target.health <= 20) {
                        score += tv * 3 + 200; // Kill bonus
                        if (target.type[1] === 'k') score += 50000;
                    } else {
                        score += 40 + tv * 0.15; // Chip damage — proportional to target value
                    }
                    break;
                }
                case 'q': { // Queen heal — 50 HP to friendly
                    if (!target || target.type[0] !== myColor) break;
                    const heal = Math.min(50, target.maxHealth - target.health);
                    if (heal <= 0) break;
                    const tv = PIECE_VALUES[target.type[1]] || 100;
                    // Heal value = how much "piece value" we're saving
                    const hpPct = target.health / target.maxHealth;
                    score += heal * (tv / target.maxHealth) * 3; // proportional to piece value
                    if (target.type[1] === 'k') score += heal * 8; // King HP is critical
                    if (hpPct < 0.3) score += tv * 0.5; // Urgent save
                    // Heal a piece that's under attack = more valuable
                    if (isSquareUnderAttack(to.row, to.col, enemyColor)) score += tv * 0.3;
                    break;
                }
                case 'r': { // Rook cannon — 35 damage on a line
                    if (!target || target.type[0] === myColor) break;
                    const tv = PIECE_VALUES[target.type[1]] || 100;
                    if (target.health <= 35) {
                        score += tv * 3 + 200;
                        if (target.type[1] === 'k') score += 50000;
                    } else {
                        score += 60 + tv * 0.2;
                    }
                    break;
                }
                case 'b': { // Bishop swap — teleport + 15 damage each
                    if (!target || target.type[0] === myColor) break;
                    const tv = PIECE_VALUES[target.type[1]] || 100;
                    const mv = PIECE_VALUES[piece.type[1]] || 330;
                    // Swap a bishop into enemy territory, pull enemy piece away
                    if (target.health <= 15) score += tv * 3 + 100; // Kill via swap damage
                    // Good if swapping a high-value enemy piece away from an attack position
                    score += 30 + tv * 0.15;
                    // Bad if we'd die from 15 damage ourselves
                    if (piece.health <= 15) score -= mv * 2;
                    break;
                }
                case 'n': { // Knight slam — jump + 30 AOE damage in 3x3
                    let aoeDamageValue = 0;
                    let killCount = 0;
                    for (let r = to.row-1; r <= to.row+1; r++) {
                        for (let c = to.col-1; c <= to.col+1; c++) {
                            if (r<0||r>7||c<0||c>7) continue;
                            const t = board[r][c];
                            if (t && t.type[0] === enemyColor) {
                                const tv = PIECE_VALUES[t.type[1]] || 100;
                                if (t.health <= 30) { aoeDamageValue += tv * 3; killCount++; }
                                else aoeDamageValue += tv * 0.2;
                            }
                        }
                    }
                    score += aoeDamageValue + killCount * 100;
                    // Also repositions the knight — check if target square is good
                    const evalRow = myColor === 'b' ? to.row : (7-to.row);
                    score += (PST.n[evalRow]?.[to.col] || 0) * 0.5;
                    break;
                }
                case 'k': { // King counter-strike — shield + 100 damage to attackers
                    // Only usable when in check - score based on how many attackers we'd hit
                    let attackerDamage = 0;
                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 8; c++) {
                            const ep = board[r][c];
                            if (!ep || ep.type[0] === myColor) continue;
                            // Check if this enemy piece attacks the king
                            let attacks = false;
                            const et = ep.type[1];
                            switch(et) {
                                case 'p': { const dir = enemyColor==='w'?-1:1; attacks = Math.abs(from.col-c)===1 && from.row===r+dir; break; }
                                case 'r': attacks = isValidRookMove(r,c,from.row,from.col); break;
                                case 'n': attacks = isValidKnightMove(r,c,from.row,from.col); break;
                                case 'b': attacks = isValidBishopMove(r,c,from.row,from.col); break;
                                case 'q': attacks = isValidQueenMove(r,c,from.row,from.col); break;
                                case 's': attacks = isValidKnightMove(r,c,from.row,from.col); break;
                                case 'd': attacks = isValidQueenMove(r,c,from.row,from.col) && Math.max(Math.abs(from.row-r),Math.abs(from.col-c))<=4; break;
                                case 'w': attacks = isValidBishopMove(r,c,from.row,from.col) && Math.max(Math.abs(from.row-r),Math.abs(from.col-c))<=3; break;
                                default: attacks = Math.abs(from.row-r)<=1 && Math.abs(from.col-c)<=1;
                            }
                            if (attacks) {
                                const tv = PIECE_VALUES[et] || 100;
                                if (ep.health <= 100) attackerDamage += tv * 3;
                                else attackerDamage += tv * 0.5;
                            }
                        }
                    }
                    score += attackerDamage + 150; // Shield value + damage dealt
                    break;
                }
                case 'w': { // Wizard — refresh a friendly piece's ability
                    if (!target || target.type[0] !== myColor || !target.abilityUsed) break;
                    const tt = target.type[1];
                    // Value = how good the refreshed ability is
                    const refreshValues = { d: 400, k: 300, q: 200, n: 180, r: 150, t: 200, s: 160, h: 120, l: 100, g: 80, x: 80, b: 100, p: 40 };
                    score += refreshValues[tt] || 80;
                    // Extra value if the refreshed piece has a high-impact unused ability
                    break;
                }
                case 'g': { // Grandpa — spawn lizard on adjacent empty square
                    score += 350; // Lizard is worth ~400 material, costs one ability
                    // Better score if spawning in a safe square
                    if (isSquareUnderAttack(to.row, to.col, enemyColor)) score -= 100;
                    break;
                }
                case 'l': { // Lizard — attach to enemy (poison/debuff)
                    if (!target || target.type[0] === myColor) break;
                    const tv = PIECE_VALUES[target.type[1]] || 100;
                    score += tv * 0.6 + 80; // Proportional to target value
                    if (target.type[1] === 'k') score += 200; // Poisoning the king is great
                    break;
                }
                case 't': { // Tank — fortify, shield all allies in 5x5 area
                    let shieldedValue = 0;
                    for (let r = from.row-2; r <= from.row+2; r++) {
                        for (let c = from.col-2; c <= from.col+2; c++) {
                            if (r<0||r>7||c<0||c>7) continue;
                            const t = board[r][c];
                            if (t && t.type[0] === myColor) {
                                shieldedValue += 30 * (PIECE_VALUES[t.type[1]] || 100) / t.maxHealth;
                            }
                        }
                    }
                    score += shieldedValue + 60;
                    break;
                }
                case 's': { // Assassin backstab — 40 damage, 2-range
                    if (!target || target.type[0] === myColor) break;
                    const tv = PIECE_VALUES[target.type[1]] || 100;
                    if (target.health <= 40) {
                        score += tv * 3 + 200;
                        if (target.type[1] === 'k') score += 50000;
                    } else {
                        score += 80 + tv * 0.25;
                    }
                    break;
                }
                case 'd': { // Dragon fire breath — 50 damage in 3x3 area
                    let totalDmgValue = 0;
                    let killCount = 0;
                    let friendlyDmg = 0;
                    for (let r = to.row-1; r <= to.row+1; r++) {
                        for (let c = to.col-1; c <= to.col+1; c++) {
                            if (r<0||r>7||c<0||c>7) continue;
                            const t = board[r][c];
                            if (!t) continue;
                            if (t.type[0] === enemyColor) {
                                const tv = PIECE_VALUES[t.type[1]] || 100;
                                if (t.health <= 50) { totalDmgValue += tv * 3; killCount++; }
                                else totalDmgValue += tv * 0.3;
                                if (t.type[1] === 'k' && t.health <= 50) totalDmgValue += 50000;
                            } else if (t.type[0] === myColor) {
                                // Friendly fire! Dragon breath hurts everyone
                                const fv = PIECE_VALUES[t.type[1]] || 100;
                                if (t.health <= 50) friendlyDmg += fv * 2;
                                else friendlyDmg += fv * 0.2;
                            }
                        }
                    }
                    score += totalDmgValue - friendlyDmg + killCount * 100;
                    break;
                }
                case 'h': { // Ghost possess — steal soul, remove enemy piece
                    if (!target || target.type[0] === myColor) break;
                    const tv = PIECE_VALUES[target.type[1]] || 100;
                    // Removing a piece entirely is very strong
                    score += tv * 2.5 + 100;
                    break;
                }
                case 'x': { // Saboteur — plant landmine
                    // Score based on how trafficked the square is
                    score += 60;
                    // Center squares are more likely to be stepped on
                    if (to.row >= 2 && to.row <= 5 && to.col >= 2 && to.col <= 5) score += 50;
                    // Near enemy pieces is good
                    for (let r = to.row-1; r <= to.row+1; r++) {
                        for (let c = to.col-1; c <= to.col+1; c++) {
                            if (r<0||r>7||c<0||c>7) continue;
                            if (board[r][c] && board[r][c].type[0] === enemyColor) score += 40;
                        }
                    }
                    break;
                }
            }

            return score;
        }


        function getAllValidAbilityMoves(color) {
            const moves = [];
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && piece.type[0] === color && !piece.abilityUsed) {
                        const abilityType = piece.type[1];
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (canUseAbility(fromRow, fromCol, toRow, toCol, abilityType)) {
                                    moves.push({
                                        from: { row: fromRow, col: fromCol },
                                        to: { row: toRow, col: toCol },
                                        abilityType: abilityType
                                    });
                                }
                            }
                        }
                    }
                }
            }
            return moves;
        }

        function getAllValidMoves(color) {
            const moves = [];
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && piece.type[0] === color) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isLegalMove(fromRow, fromCol, toRow, toCol)) {
                                    moves.push({
                                        from: { row: fromRow, col: fromCol },
                                        to: { row: toRow, col: toCol }
                                    });
                                }
                            }
                        }
                    }
                }
            }
            return moves;
        }

        // ====== SELECTION & HIGHLIGHTS ======
        function selectSquare(row, col) {
            selectedSquare = [row, col];

            document.querySelectorAll('.square').forEach(sq => {
                sq.classList.remove('selected', 'legal-move', 'ability-target');
            });

            const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (square) {
                square.classList.add('selected');
            }

            const piece = board[row][col];
            highlightPieceInGuide(piece);

            if (activeAbility && piece && piece.type[1] === activeAbility) {
                showAbilityTargets(row, col, activeAbility);
            } else {
                showLegalMoves(row, col);
            }
        }

        function showLegalMoves(row, col) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isLegalMove(row, col, r, c)) {
                        const square = document.querySelector(`#board [data-row="${r}"][data-col="${c}"]`);
                        if (square) {
                            square.classList.add('legal-move');
                        }
                    }
                }
            }
        }

        function showAbilityTargets(row, col, abilityType) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (canUseAbility(row, col, r, c, abilityType)) {
                        const square = document.querySelector(`#board [data-row="${r}"][data-col="${c}"]`);
                        if (square) {
                            square.classList.add('ability-target');
                        }
                    }
                }
            }
        }

        function clearSelection() {
            selectedSquare = null;
            activeAbility = null;
            document.querySelectorAll('.square').forEach(sq => {
                sq.classList.remove('selected', 'legal-move', 'ability-target');
            });
            highlightPieceInGuide(null);
        }

        // ====== MOVEMENT RULES ======
        function canCastle(row, kingCol, targetCol, color) {
            const king = board[row][kingCol];
            if (!king || king.hasMoved) return false;
            if (isKingInCheck(color)) return false;

            const isKingside = targetCol > kingCol;
            const rookCol = isKingside ? 7 : 0;
            const rook = board[row][rookCol];

            if (!rook || rook.type[1] !== 'r' || rook.hasMoved) return false;

            const start = Math.min(kingCol, rookCol) + 1;
            const end = Math.max(kingCol, rookCol);
            for (let col = start; col < end; col++) {
                if (board[row][col]) return false;
            }

            const direction = isKingside ? 1 : -1;
            for (let i = 1; i <= 2; i++) {
                const checkCol = kingCol + (i * direction);
                if (isSquareUnderAttack(row, checkCol, color === 'w' ? 'b' : 'w')) {
                    return false;
                }
            }

            return true;
        }

        function isLegalMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            if (!piece) return false;

            const targetPiece = board[toRow][toCol];
            if (targetPiece && targetPiece.type[0] === piece.type[0]) return false;
            if (targetPiece && targetPiece.type[1] === 'k') return false;
            if (fromRow === toRow && fromCol === toCol) return false;

            const type = piece.type[1];
            const color = piece.type[0];

            let isValid = false;

            switch (type) {
                case 'p':
                    isValid = isValidPawnMove(fromRow, fromCol, toRow, toCol, color);
                    break;
                case 'r':
                    isValid = isValidRookMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'n':
                    isValid = isValidKnightMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'b':
                    isValid = isValidBishopMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'q':
                    isValid = isValidQueenMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'k':
                    if (fromRow === toRow && Math.abs(toCol - fromCol) === 2) {
                        isValid = canCastle(fromRow, fromCol, toCol, color);
                    } else {
                        isValid = isValidKingMove(fromRow, fromCol, toRow, toCol);
                    }
                    break;
                case 'w':
                    isValid = isValidBishopMove(fromRow, fromCol, toRow, toCol) &&
                              Math.max(Math.abs(toRow - fromRow), Math.abs(toCol - fromCol)) <= 3;
                    break;
                case 'g':
                    isValid = isValidKingMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'l':
                    isValid = isValidKingMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 't':
                    isValid = isValidKingMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 's':
                    const sRowDiff = Math.abs(toRow - fromRow);
                    const sColDiff = Math.abs(toCol - fromCol);
                    isValid = (sRowDiff === 2 && sColDiff === 1) || (sRowDiff === 1 && sColDiff === 2);
                    break;
                case 'd':
                    isValid = isValidQueenMove(fromRow, fromCol, toRow, toCol) &&
                              Math.max(Math.abs(toRow - fromRow), Math.abs(toCol - fromCol)) <= 4;
                    break;
                case 'x':
                    isValid = isValidKingMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'h':
                    if (piece.stolenSoul) {
                        const stolenType = piece.stolenSoul;
                        switch(stolenType) {
                            case 'p': isValid = isValidPawnMove(fromRow, fromCol, toRow, toCol, color); break;
                            case 'r': isValid = isValidRookMove(fromRow, fromCol, toRow, toCol, color); break;
                            case 'n': isValid = isValidKnightMove(fromRow, fromCol, toRow, toCol); break;
                            case 'b': isValid = isValidBishopMove(fromRow, fromCol, toRow, toCol, color); break;
                            case 'q': isValid = isValidQueenMove(fromRow, fromCol, toRow, toCol, color); break;
                            case 'k': isValid = isValidKingMove(fromRow, fromCol, toRow, toCol); break;
                            case 'w':
                                isValid = isValidBishopMove(fromRow, fromCol, toRow, toCol, color) &&
                                         Math.max(Math.abs(toRow - fromRow), Math.abs(toCol - fromCol)) <= 3;
                                break;
                            case 'd':
                                isValid = isValidQueenMove(fromRow, fromCol, toRow, toCol, color) &&
                                         Math.max(Math.abs(toRow - fromRow), Math.abs(toCol - fromCol)) <= 4;
                                break;
                            case 'g': case 'l': case 't': case 's': case 'x':
                                if (stolenType === 's') {
                                    const sRowDiff2 = Math.abs(toRow - fromRow);
                                    const sColDiff2 = Math.abs(toCol - fromCol);
                                    isValid = (sRowDiff2 === 2 && sColDiff2 === 1) || (sRowDiff2 === 1 && sColDiff2 === 2);
                                } else {
                                    isValid = isValidKingMove(fromRow, fromCol, toRow, toCol);
                                }
                                break;
                            default: isValid = isValidKingMove(fromRow, fromCol, toRow, toCol);
                        }
                    } else {
                        isValid = Math.abs(toRow - fromRow) <= 1 && Math.abs(toCol - fromCol) <= 1;
                    }
                    break;
            }

            if (!isValid) return false;

            return !wouldBeInCheckAfterMove(fromRow, fromCol, toRow, toCol, color);
        }

        function isValidPawnMove(fromRow, fromCol, toRow, toCol, color) {
            const direction = color === 'w' ? -1 : 1;
            const startRow = color === 'w' ? 6 : 1;

            if (toCol === fromCol && toRow === fromRow + direction && !board[toRow][toCol]) {
                return true;
            }

            if (toCol === fromCol && fromRow === startRow && toRow === fromRow + 2 * direction &&
                !board[toRow][toCol] && !board[fromRow + direction][fromCol]) {
                return true;
            }

            if (Math.abs(toCol - fromCol) === 1 && toRow === fromRow + direction && board[toRow][toCol]) {
                return true;
            }

            return false;
        }

        function isValidRookMove(fromRow, fromCol, toRow, toCol, ignoreFriendlyColor) {
            if (fromRow !== toRow && fromCol !== toCol) return false;
            return !isPathBlocked(fromRow, fromCol, toRow, toCol, ignoreFriendlyColor);
        }

        function isValidKnightMove(fromRow, fromCol, toRow, toCol) {
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
        }

        function isValidBishopMove(fromRow, fromCol, toRow, toCol, ignoreFriendlyColor) {
            if (Math.abs(toRow - fromRow) !== Math.abs(toCol - fromCol)) return false;
            return !isPathBlocked(fromRow, fromCol, toRow, toCol, ignoreFriendlyColor);
        }

        function isValidQueenMove(fromRow, fromCol, toRow, toCol, ignoreFriendlyColor) {
            return isValidRookMove(fromRow, fromCol, toRow, toCol, ignoreFriendlyColor) ||
                   isValidBishopMove(fromRow, fromCol, toRow, toCol, ignoreFriendlyColor);
        }

        function isValidKingMove(fromRow, fromCol, toRow, toCol) {
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            return rowDiff <= 1 && colDiff <= 1;
        }

        function isPathBlocked(fromRow, fromCol, toRow, toCol, ignoreFriendlyColor) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;

            while (currentRow !== toRow || currentCol !== toCol) {
                const blockingPiece = board[currentRow][currentCol];
                if (blockingPiece) {
                    if (ignoreFriendlyColor && blockingPiece.type[0] === ignoreFriendlyColor) {
                        // Skip friendly pieces for Ghost
                    } else {
                        return true;
                    }
                }
                currentRow += rowStep;
                currentCol += colStep;
            }

            return false;
        }

        // ====== CHECK DETECTION ======
        function findKing(color) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.type[0] === color && piece.type[1] === 'k') {
                        return { row, col };
                    }
                }
            }
            return null;
        }

        function isSquareUnderAttack(row, col, byColor) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.type[0] !== byColor) continue;

                    const type = piece.type[1];
                    let canAttack = false;

                    switch (type) {
                        case 'p':
                            const direction = byColor === 'w' ? -1 : 1;
                            canAttack = Math.abs(col - c) === 1 && row === r + direction;
                            break;
                        case 'r':
                            canAttack = isValidRookMove(r, c, row, col);
                            break;
                        case 'n':
                            canAttack = isValidKnightMove(r, c, row, col);
                            break;
                        case 'b':
                            canAttack = isValidBishopMove(r, c, row, col);
                            break;
                        case 'q':
                            canAttack = isValidQueenMove(r, c, row, col);
                            break;
                        case 'k':
                            canAttack = isValidKingMove(r, c, row, col);
                            break;
                        case 'w':
                            canAttack = isValidBishopMove(r, c, row, col) &&
                                      Math.max(Math.abs(row - r), Math.abs(col - c)) <= 3;
                            break;
                        case 't':
                            canAttack = isValidKingMove(r, c, row, col);
                            break;
                        case 's':
                            canAttack = isValidKnightMove(r, c, row, col);
                            break;
                        case 'd':
                            canAttack = isValidQueenMove(r, c, row, col) &&
                                      Math.max(Math.abs(row - r), Math.abs(col - c)) <= 4;
                            break;
                        case 'g':
                            canAttack = isValidKingMove(r, c, row, col);
                            break;
                        case 'l':
                            canAttack = isValidKingMove(r, c, row, col);
                            break;
                        case 'h':
                            canAttack = Math.abs(row - r) <= 1 && Math.abs(col - c) <= 1;
                            break;
                        case 'x':
                            canAttack = isValidKingMove(r, c, row, col);
                            break;
                    }

                    if (canAttack) return true;
                }
            }
            return false;
        }

        function isKingInCheck(color) {
            const kingPos = findKing(color);
            if (!kingPos) return false;
            const opponentColor = color === 'w' ? 'b' : 'w';
            return isSquareUnderAttack(kingPos.row, kingPos.col, opponentColor);
        }

        function wouldBeInCheckAfterMove(fromRow, fromCol, toRow, toCol, color) {
            const movingPiece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];

            board[toRow][toCol] = movingPiece;
            board[fromRow][fromCol] = null;

            const inCheck = isKingInCheck(color);

            board[fromRow][fromCol] = movingPiece;
            board[toRow][toCol] = capturedPiece;

            return inCheck;
        }

        // ====== MAKING MOVES ======
        function makeMove(fromRow, fromCol, toRow, toCol) {
            // Guard against null piece (can happen if boards desync in online)
            if (!board[fromRow][fromCol]) return;

            // Notify the other player in online mode
            sendOnlineAction({action:'move', fromRow, fromCol, toRow, toCol});

            const movingPiece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];

            if (movingPiece.type[1] === 'k' && Math.abs(toCol - fromCol) === 2) {
                const isKingside = toCol > fromCol;
                const rookCol = isKingside ? 7 : 0;
                const newRookCol = isKingside ? toCol - 1 : toCol + 1;
                const rook = board[fromRow][rookCol];

                board[toRow][toCol] = movingPiece;
                board[fromRow][fromCol] = null;
                movingPiece.hasMoved = true;

                if (rook) {
                    board[fromRow][newRookCol] = rook;
                    board[fromRow][rookCol] = null;
                    rook.hasMoved = true;
                }

                switchTurn();
                applyPoisonDamage();
                renderBoard();
                checkGameEnd();
                return;
            }

            if (targetPiece) {
                if (targetPiece.type[1] === 'k') {
                    const winner = movingPiece.type[0] === 'w' ? 'WHITE' : 'BLACK';
                    board[toRow][toCol] = movingPiece;
                    board[fromRow][fromCol] = null;
                    renderBoard();
                    setTimeout(() => endGame(winner, currentTurn === 'white'), 300);
                    return;
                }
            }

            board[toRow][toCol] = movingPiece;
            board[fromRow][fromCol] = null;

            if (movingPiece.hasMoved !== undefined) {
                movingPiece.hasMoved = true;
            }

            const mineIndex = landmines.findIndex(m => m.row === toRow && m.col === toCol);
            if (mineIndex !== -1) {
                const mine = landmines[mineIndex];
                createExplosion(toRow, toCol);
                setTimeout(() => {
                    dealDamage(toRow, toCol, 60);
                    landmines.splice(mineIndex, 1);
                    renderBoard();
                }, 300);
            }

            if (movingPiece.type[1] === 'p') {
                const color = movingPiece.type[0];
                const promotionRow = color === 'w' ? 0 : 7;
                if (toRow === promotionRow) {
                    if (gameMode === 'pvc' && color === 'b') {
                        promotePawn(toRow, toCol, 'q');
                    } else if (gameMode === 'online' && isRemoteAction) {
                        // Wait for separate 'promote' action from remote
                        renderBoard();
                        return;
                    } else {
                        renderBoard();
                        showPromotionDialog(toRow, toCol, color);
                        return;
                    }
                }
            }

            switchTurn();
            applyPoisonDamage();
            renderBoard();
            checkGameEnd();
        }

        // ====== ABILITIES ======
        function canUseAbility(fromRow, fromCol, toRow, toCol, abilityType) {
            const piece = board[fromRow][fromCol];
            if (!piece || piece.type[1] !== abilityType) return false;
            if (piece.abilityUsed) return false;

            const color = piece.type[0];
            const targetPiece = board[toRow][toCol];

            switch (abilityType) {
                case 'p':
                    const direction = color === 'w' ? -1 : 1;
                    if (toCol !== fromCol) return false;
                    if (color === 'w' && toRow >= fromRow) return false;
                    if (color === 'b' && toRow <= fromRow) return false;
                    let checkRow = fromRow + direction;
                    while (checkRow >= 0 && checkRow < 8) {
                        if (board[checkRow][fromCol]) {
                            if (checkRow === toRow) {
                                return targetPiece && targetPiece.type[0] !== color;
                            }
                            return false;
                        }
                        checkRow += direction;
                    }
                    return false;

                case 'q':
                    return targetPiece && targetPiece.type[0] === color;

                case 'r':
                    if (fromRow !== toRow && fromCol !== toCol) return false;
                    return targetPiece && targetPiece.type[0] !== color;

                case 'b':
                    if (Math.abs(toRow - fromRow) !== Math.abs(toCol - fromCol)) return false;
                    if (!targetPiece || targetPiece.type[0] === color) return false;
                    return !isPathBlocked(fromRow, fromCol, toRow, toCol);

                case 'n':
                    const rowDiff = Math.abs(toRow - fromRow);
                    const colDiff = Math.abs(toCol - fromCol);
                    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);

                case 'k':
                    if (!isKingInCheck(color)) return false;
                    return Math.abs(toRow - fromRow) <= 1 && Math.abs(toCol - fromCol) <= 1;

                case 'w':
                    if (!targetPiece || targetPiece.type[0] !== color) return false;
                    return targetPiece.abilityUsed === true;

                case 'g':
                    if (Math.abs(toRow - fromRow) > 1 || Math.abs(toCol - fromCol) > 1) return false;
                    return !targetPiece;

                case 'l':
                    if (Math.abs(toRow - fromRow) > 3 || Math.abs(toCol - fromCol) > 3) return false;
                    return targetPiece && targetPiece.type[0] !== color;

                case 't':
                    return Math.abs(toRow - fromRow) <= 2 && Math.abs(toCol - fromCol) <= 2;

                case 's':
                    if (Math.abs(toRow - fromRow) > 2 || Math.abs(toCol - fromCol) > 2) return false;
                    return targetPiece && targetPiece.type[0] !== color;

                case 'd':
                    return Math.abs(toRow - fromRow) <= 3 && Math.abs(toCol - fromCol) <= 3;

                case 'h':
                    if (Math.abs(toRow - fromRow) > 2 || Math.abs(toCol - fromCol) > 2) return false;
                    if (!targetPiece || targetPiece.type[0] === color) return false;
                    return targetPiece.type[1] !== 'k';

                case 'x':
                    if (Math.abs(toRow - fromRow) > 3 || Math.abs(toCol - fromCol) > 3) return false;
                    const hasMine = landmines.some(m => m.row === toRow && m.col === toCol);
                    return !targetPiece && !hasMine;
            }
            return false;
        }

        function useAbility(fromRow, fromCol, toRow, toCol, abilityType) {
            // Notify the other player in online mode
            sendOnlineAction({action:'ability', fromRow, fromCol, toRow, toCol, abilityType});

            const piece = board[fromRow][fromCol];
            if (piece) {
                piece.abilityUsed = true;
            }

            switch (abilityType) {
                case 'p':
                    animateProjectile(fromRow, fromCol, toRow, toCol, 'bullet', () => {
                        dealDamage(toRow, toCol, 20);
                        switchTurn();
                        clearSelection();
                        renderBoard();
                        checkGameEnd();
                    });
                    return;

                case 'q':
                    createHealEffect(toRow, toCol);
                    setTimeout(() => {
                        if (board[toRow][toCol]) {
                            board[toRow][toCol].health = Math.min(
                                board[toRow][toCol].health + 50,
                                board[toRow][toCol].maxHealth
                            );
                        }
                        switchTurn();
                        clearSelection();
                        renderBoard();
                        checkGameEnd();
                    }, 500);
                    return;

                case 'r':
                    animateProjectile(fromRow, fromCol, toRow, toCol, 'cannonball', () => {
                        dealDamage(toRow, toCol, 35);
                        switchTurn();
                        clearSelection();
                        renderBoard();
                        checkGameEnd();
                    });
                    return;

                case 'b':
                    createTeleportEffect(fromRow, fromCol);
                    createTeleportEffect(toRow, toCol);
                    setTimeout(() => {
                        const temp = board[fromRow][fromCol];
                        board[fromRow][fromCol] = board[toRow][toCol];
                        board[toRow][toCol] = temp;
                        dealDamage(fromRow, fromCol, 15);
                        dealDamage(toRow, toCol, 15);
                        switchTurn();
                        clearSelection();
                        renderBoard();
                        checkGameEnd();
                    }, 500);
                    return;

                case 'n':
                    board[toRow][toCol] = piece;
                    board[fromRow][fromCol] = null;
                    renderBoard();
                    setTimeout(() => {
                        createShockwave(toRow, toCol);
                        const slamColor = piece.type[0];
                        for (let r = toRow - 1; r <= toRow + 1; r++) {
                            for (let c = toCol - 1; c <= toCol + 1; c++) {
                                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                                    const slamTarget = board[r][c];
                                    if (slamTarget && slamTarget.type[0] === slamColor) continue;
                                    dealDamage(r, c, 30);
                                }
                            }
                        }
                        setTimeout(() => {
                            switchTurn();
                            clearSelection();
                            renderBoard();
                            checkGameEnd();
                        }, 300);
                    }, 200);
                    return;

                case 'k':
                    createShieldEffect(fromRow, fromCol);
                    setTimeout(() => {
                        if (piece) piece.shield = 50;
                        const kingColor = piece.type[0];
                        const opponentColor = kingColor === 'w' ? 'b' : 'w';

                        for (let r = 0; r < 8; r++) {
                            for (let c = 0; c < 8; c++) {
                                const enemyPiece = board[r][c];
                                if (enemyPiece && enemyPiece.type[0] === opponentColor) {
                                    const type = enemyPiece.type[1];
                                    let canAttack = false;

                                    switch (type) {
                                        case 'p':
                                            const dir = opponentColor === 'w' ? -1 : 1;
                                            canAttack = Math.abs(fromCol - c) === 1 && fromRow === r + dir;
                                            break;
                                        case 'r':
                                            canAttack = isValidRookMove(r, c, fromRow, fromCol);
                                            break;
                                        case 'n':
                                            canAttack = isValidKnightMove(r, c, fromRow, fromCol);
                                            break;
                                        case 'b':
                                            canAttack = isValidBishopMove(r, c, fromRow, fromCol);
                                            break;
                                        case 'q':
                                            canAttack = isValidQueenMove(r, c, fromRow, fromCol);
                                            break;
                                        case 'k':
                                            canAttack = isValidKingMove(r, c, fromRow, fromCol);
                                            break;
                                        case 'w':
                                            canAttack = isValidBishopMove(r, c, fromRow, fromCol) &&
                                                      Math.max(Math.abs(fromRow - r), Math.abs(fromCol - c)) <= 3;
                                            break;
                                        case 'd':
                                            canAttack = isValidQueenMove(r, c, fromRow, fromCol) &&
                                                      Math.max(Math.abs(fromRow - r), Math.abs(fromCol - c)) <= 4;
                                            break;
                                        case 's':
                                            canAttack = isValidKnightMove(r, c, fromRow, fromCol);
                                            break;
                                        default:
                                            canAttack = Math.abs(fromRow - r) <= 1 && Math.abs(fromCol - c) <= 1;
                                    }

                                    if (canAttack) {
                                        dealDamage(r, c, 100);
                                    }
                                }
                            }
                        }

                        clearSelection();
                        renderBoard();

                        const csColor = kingColor;
                        const csHasLegalMoves = getAllValidMoves(csColor).length > 0;
                        const csStillInCheck = isKingInCheck(csColor);

                        if (csStillInCheck && !csHasLegalMoves) {
                            const csWinner = csColor === 'w' ? 'BLACK' : 'WHITE';
                            endGame(csWinner, false);
                        } else {
                            switchTurn();
                            renderBoard();
                            checkGameEnd();
                        }
                    }, 500);
                    return;

                case 'w':
                    const targetPieceW = board[toRow][toCol];
                    if (targetPieceW) {
                        targetPieceW.abilityUsed = false;
                        createHealEffect(toRow, toCol);
                    }
                    switchTurn();
                    clearSelection();
                    renderBoard();
                    checkGameEnd();
                    return;

                case 'g':
                    const gColor = piece.type[0];
                    const lizard = createPiece(gColor + 'l');
                    board[toRow][toCol] = lizard;
                    piece.abilityUsed = true;
                    switchTurn();
                    clearSelection();
                    renderBoard();
                    checkGameEnd();
                    return;

                case 'l':
                    const targetPieceL = board[toRow][toCol];
                    if (targetPieceL) {
                        targetPieceL.lizardAttached = true;
                        board[fromRow][fromCol] = null;
                    }
                    switchTurn();
                    clearSelection();
                    renderBoard();
                    checkGameEnd();
                    return;

                case 't':
                    createShieldEffect(fromRow, fromCol);
                    setTimeout(() => {
                        for (let r = fromRow - 2; r <= fromRow + 2; r++) {
                            for (let c = fromCol - 2; c <= fromCol + 2; c++) {
                                if (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c]) {
                                    const p = board[r][c];
                                    if (p.type[0] === piece.type[0]) {
                                        p.shield = (p.shield || 0) + 30;
                                        createShieldEffect(r, c);
                                    }
                                }
                            }
                        }
                        switchTurn();
                        clearSelection();
                        renderBoard();
                        checkGameEnd();
                    }, 500);
                    return;

                case 's':
                    createSlashEffect(toRow, toCol);
                    setTimeout(() => {
                        dealDamage(toRow, toCol, 40);
                        switchTurn();
                        clearSelection();
                        renderBoard();
                        checkGameEnd();
                    }, 300);
                    return;

                case 'd':
                    createFireBreath(toRow, toCol);
                    setTimeout(() => {
                        const breathColor = piece.type[0];
                        for (let r = toRow - 1; r <= toRow + 1; r++) {
                            for (let c = toCol - 1; c <= toCol + 1; c++) {
                                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                                    const breathTarget = board[r][c];
                                    if (breathTarget && breathTarget.type[0] === breathColor) continue;
                                    dealDamage(r, c, 50);
                                    createExplosion(r, c);
                                }
                            }
                        }
                        switchTurn();
                        clearSelection();
                        renderBoard();
                        checkGameEnd();
                    }, 600);
                    return;

                case 'x':
                    if (piece) {
                        const mineOwner = piece.type[0];
                        landmines.push({ row: toRow, col: toCol, owner: mineOwner });
                        createExplosion(toRow, toCol);
                    }
                    switchTurn();
                    clearSelection();
                    renderBoard();
                    checkGameEnd();
                    return;

                case 'h':
                    const targetPieceH = board[toRow][toCol];
                    if (targetPieceH && piece) {
                        piece.stolenSoul = targetPieceH.type[1];
                        createTeleportEffect(fromRow, fromCol);
                        createTeleportEffect(toRow, toCol);
                        setTimeout(() => {
                            board[toRow][toCol] = null;
                            switchTurn();
                            clearSelection();
                            renderBoard();
                            checkGameEnd();
                        }, 500);
                    } else {
                        switchTurn();
                        clearSelection();
                        renderBoard();
                        checkGameEnd();
                    }
                    return;
            }

            switchTurn();
            clearSelection();
            renderBoard();
            checkGameEnd();
        }

        // ====== PAWN PROMOTION ======
        function showPromotionDialog(row, col, color) {
            const overlay = document.getElementById('promotion-overlay');
            const choices = document.getElementById('promotion-choices');
            choices.innerHTML = '';

            const options = [
                { type: 'q', name: 'Queen' },
                { type: 'r', name: 'Rook' },
                { type: 'n', name: 'Knight' },
                { type: 'b', name: 'Bishop' }
            ];

            options.forEach(opt => {
                const wrapper = document.createElement('div');
                wrapper.className = 'promotion-choice-wrapper';

                const btn = document.createElement('div');
                btn.className = 'promotion-choice';
                btn.innerHTML = getPieceSVG(opt.type, color === 'w');
                btn.addEventListener('click', () => {
                    overlay.classList.add('hidden');
                    sendOnlineAction({action:'promote', row, col, newType: opt.type});
                    promotePawn(row, col, opt.type);
                    switchTurn();
                    applyPoisonDamage();
                    renderBoard();
                    checkGameEnd();
                });

                const label = document.createElement('div');
                label.className = 'promotion-choice-label';
                label.textContent = opt.name;

                wrapper.appendChild(btn);
                wrapper.appendChild(label);
                choices.appendChild(wrapper);
            });

            overlay.classList.remove('hidden');
        }

        function promotePawn(row, col, newType) {
            const pawn = board[row][col];
            if (!pawn) return;
            const color = pawn.type[0];
            const promoted = createPiece(color + newType);
            promoted.abilityUsed = false;
            board[row][col] = promoted;
        }

        // ====== DAMAGE & EFFECTS ======
        function dealDamage(row, col, damage) {
            const piece = board[row][col];
            if (!piece) return false;

            if (piece.shield && piece.shield > 0) {
                if (piece.shield >= damage) {
                    piece.shield -= damage;
                    return false;
                } else {
                    damage -= piece.shield;
                    piece.shield = 0;
                }
            }

            piece.health -= damage;
            createExplosion(row, col);

            if (piece.health <= 0) {
                if (piece.type[1] === 'k') {
                    const winner = piece.type[0] === 'w' ? 'BLACK' : 'WHITE';
                    setTimeout(() => {
                        board[row][col] = null;
                        renderBoard();
                        endGame(winner, piece.type[0] === 'b');
                    }, 300);
                    return true;
                }
                board[row][col] = null;
                return true;
            }
            return false;
        }

        function createExplosion(row, col) {
            const square = document.querySelector(`#board [data-row="${row}"][data-col="${col}"]`);
            if (!square) return;
            const explosion = document.createElement('div');
            explosion.className = 'explosion';
            explosion.textContent = '💥';
            square.appendChild(explosion);
            setTimeout(() => explosion.remove(), 600);
        }

        function createShockwave(row, col) {
            const square = document.querySelector(`#board [data-row="${row}"][data-col="${col}"]`);
            if (!square) return;
            const shockwave = document.createElement('div');
            shockwave.className = 'shockwave';
            shockwave.style.left = '50%';
            shockwave.style.top = '50%';
            shockwave.style.transform = 'translate(-50%, -50%)';
            square.appendChild(shockwave);
            setTimeout(() => shockwave.remove(), 600);
        }

        function animateProjectile(fromRow, fromCol, toRow, toCol, type, callback) {
            const boardEl = document.getElementById('board');
            const boardRect = boardEl.getBoundingClientRect();
            const squareSize = boardRect.width / 8;

            const startX = fromCol * squareSize + squareSize / 2;
            const startY = fromRow * squareSize + squareSize / 2;
            const endX = toCol * squareSize + squareSize / 2;
            const endY = toRow * squareSize + squareSize / 2;

            const projectile = document.createElement('div');

            if (type === 'bullet') {
                projectile.className = 'bullet';
            } else if (type === 'arrow') {
                projectile.className = 'arrow';
                const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;
                projectile.style.transform = `rotate(${angle}deg)`;
            } else if (type === 'fireball') {
                projectile.className = 'fireball';
            } else if (type === 'cannonball') {
                projectile.style.width = '15px';
                projectile.style.height = '15px';
                projectile.style.background = 'radial-gradient(circle, #ff6600, #cc3300)';
                projectile.style.borderRadius = '50%';
                projectile.style.boxShadow = '0 0 15px #ff6600';
                projectile.style.position = 'absolute';
                projectile.style.zIndex = '100';
            }

            projectile.style.position = 'absolute';
            projectile.style.left = startX + 'px';
            projectile.style.top = startY + 'px';
            projectile.style.zIndex = '100';
            boardEl.appendChild(projectile);

            const distance = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
            const duration = distance * 1.5;

            const animation = projectile.animate([
                { left: startX + 'px', top: startY + 'px' },
                { left: endX + 'px', top: endY + 'px' }
            ], {
                duration: duration,
                easing: 'linear'
            });

            animation.onfinish = () => {
                projectile.remove();
                callback();
            };
        }

        function createHealEffect(row, col) {
            const square = document.querySelector(`#board [data-row="${row}"][data-col="${col}"]`);
            if (!square) return;
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const heal = document.createElement('div');
                    heal.className = 'heal-effect';
                    heal.textContent = '✨';
                    heal.style.left = Math.random() * 80 + 10 + '%';
                    heal.style.top = Math.random() * 80 + 10 + '%';
                    square.appendChild(heal);
                    setTimeout(() => heal.remove(), 1000);
                }, i * 100);
            }
        }

        function createTeleportEffect(row, col) {
            const square = document.querySelector(`#board [data-row="${row}"][data-col="${col}"]`);
            if (!square) return;
            const teleport = document.createElement('div');
            teleport.className = 'teleport-effect';
            teleport.textContent = '🔮';
            teleport.style.left = '50%';
            teleport.style.top = '50%';
            teleport.style.transform = 'translate(-50%, -50%)';
            square.appendChild(teleport);
            setTimeout(() => teleport.remove(), 800);
        }

        function createSlashEffect(row, col) {
            const square = document.querySelector(`#board [data-row="${row}"][data-col="${col}"]`);
            if (!square) return;
            const slash = document.createElement('div');
            slash.className = 'slash-effect';
            slash.textContent = '⚔️';
            slash.style.left = '50%';
            slash.style.top = '50%';
            slash.style.transform = 'translate(-50%, -50%)';
            square.appendChild(slash);
            setTimeout(() => slash.remove(), 400);
        }

        function createShieldEffect(row, col) {
            const square = document.querySelector(`#board [data-row="${row}"][data-col="${col}"]`);
            if (!square) return;
            const shield = document.createElement('div');
            shield.className = 'shield-effect';
            shield.style.left = '50%';
            shield.style.top = '50%';
            shield.style.transform = 'translate(-50%, -50%)';
            square.appendChild(shield);
            setTimeout(() => shield.remove(), 800);
        }

        function createFireBreath(row, col) {
            const square = document.querySelector(`#board [data-row="${row}"][data-col="${col}"]`);
            if (!square) return;
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const fire = document.createElement('div');
                    fire.className = 'fire-breath';
                    fire.textContent = '🔥';
                    fire.style.left = Math.random() * 60 + 20 + '%';
                    fire.style.top = Math.random() * 60 + 20 + '%';
                    square.appendChild(fire);
                    setTimeout(() => fire.remove(), 800);
                }, i * 150);
            }
        }

        // ====== GAME STATE ======
        function applyPoisonDamage() {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.lizardAttached) {
                        dealDamage(row, col, 10);
                        const poisonedColor = piece.type[0];
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const r = row + dr;
                                const c = col + dc;
                                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                                    const target = board[r][c];
                                    if (target && target.type[0] === poisonedColor) {
                                        dealDamage(r, c, 10);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        function switchTurn() {
            currentTurn = currentTurn === 'white' ? 'black' : 'white';
            updateTurnIndicator();

            // After I finish my move/ability, sync full board state to opponent
            // !isMyTurnOnline() means I just played and it's now opponent's turn
            if (gameMode === 'online' && !isMyTurnOnline()) {
                sendStateSync();
            }
        }

        function calculateMaterialScore() {
            const materialValues = {
                'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9,
                'w': 5, 'g': 3, 'l': 8, 't': 7, 's': 3, 'd': 9, 'h': 1, 'x': 4
            };

            let whiteScore = 0;
            let blackScore = 0;

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.type[1] !== 'k') {
                        const value = materialValues[piece.type[1]] || 1;
                        if (piece.type[0] === 'w') {
                            whiteScore += value;
                        } else {
                            blackScore += value;
                        }
                    }
                }
            }

            document.getElementById('white-score').textContent = whiteScore;
            document.getElementById('black-score').textContent = blackScore;
        }

        function updateTurnIndicator() {
            const indicator = document.getElementById('turn-display');
            const color = currentTurn === 'white' ? 'w' : 'b';
            const inCheck = isKingInCheck(color);

            let turnText = currentTurn === 'white' ? '⬜ White\'s Turn' : '⬛ Black\'s Turn';
            if (gameMode === 'online') {
                turnText += isMyTurnOnline() ? ' (YOUR TURN)' : ' (Waiting...)';
            }

            if (inCheck) {
                indicator.textContent = turnText + ' ⚠️ CHECK!';
                indicator.style.color = '#ff0044';
                indicator.style.animation = 'checkPulse 0.5s ease-in-out infinite';
            } else {
                indicator.textContent = turnText;
                indicator.style.color = isMyTurnOnline() ? '#ffd700' : '#aaa';
                indicator.style.animation = 'turnGlow 2s ease-in-out infinite';
            }
        }

        function checkGameEnd() {
            let whiteKing = false;
            let blackKing = false;
            let totalPieces = 0;

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        totalPieces++;
                        if (piece.type[1] === 'k') {
                            if (piece.type[0] === 'w') whiteKing = true;
                            if (piece.type[0] === 'b') blackKing = true;
                        }
                    }
                }
            }

            if (!whiteKing) {
                endGame('BLACK', false);
                return;
            } else if (!blackKing) {
                endGame('WHITE', true);
                return;
            }

            if (totalPieces === 2 && whiteKing && blackKing) {
                endGame('DRAW', null);
                return;
            }

            const currentColor = currentTurn === 'white' ? 'w' : 'b';
            const hasLegalMoves = getAllValidMoves(currentColor).length > 0;

            if (!hasLegalMoves) {
                if (isKingInCheck(currentColor)) {
                    const kingPos = findKing(currentColor);
                    const king = kingPos ? board[kingPos.row][kingPos.col] : null;
                    if (king && !king.abilityUsed) {
                        showMessage('⚠️ CHECKMATE INCOMING!', 'Use your King\'s Counter-Strike ability! (double-click your King)');
                        setTimeout(hideMessage, 3000);
                        return;
                    }
                    const winner = currentTurn === 'white' ? 'BLACK' : 'WHITE';
                    endGame(winner, currentTurn === 'white' ? false : true);
                } else {
                    endGame('DRAW', null);
                }
            }
        }

        function endGame(winner, playerWon) {
            gameActive = false;
            if (winner === 'DRAW') {
                showMessage('DRAW!', 'The game has ended in a draw.');
            } else {
                showMessage(`${winner} WINS! 🏆`, `Game Over!`, true);
            }
        }

        function showMessage(title, text, showButton) {
            document.getElementById('message-title').textContent = title;
            document.getElementById('message-text').textContent = text;
            document.getElementById('play-again-btn').style.display = showButton ? 'block' : 'none';
            document.getElementById('game-message').classList.add('show');
        }

        function hideMessage() {
            document.getElementById('game-message').classList.remove('show');
        }

        function resetGame() {
            currentTurn = 'white';
            gameActive = true;
            activeAbility = null;
            selectedSquare = null;
            isAIThinking = false;
            landmines = [];
            initStandardBoard();
            renderBoard();
            hideMessage();
        }

        function newGame() {
            gameActive = false;
            gameMode = 'pvp';
            currentTurn = 'white';
            activeAbility = null;
            selectedSquare = null;
            isAIThinking = false;
            landmines = [];
            myColor = null;
            myPlayerNumber = null;

            // Close online connection if open
            if (ws) { ws.close(); ws = null; onlineConnected = false; }
            document.getElementById('online-lobby-overlay').classList.add('hidden');

            board = Array(8).fill(null).map(() => Array(8).fill(null));
            hideMessage();
            renderBoard();

            document.getElementById('pvp-btn').classList.remove('selected');
            document.getElementById('pvc-btn').classList.remove('selected');
            document.getElementById('online-btn').classList.remove('selected');
            document.getElementById('ai-difficulty-section').style.display = 'none';
            document.getElementById('online-info-section').style.display = 'none';
            document.getElementById('start-game-btn').style.display = 'none';

            document.getElementById('mode-selector').classList.remove('hidden');
        }

        // ====== TUTORIAL SYSTEM ======
        let tutorialStep = 0;

        const TUTORIAL_STEPS = [
            {
                title: "Welcome to Chess Warfare!",
                content: `
                    <p>This isn't regular chess — it's chess with <span class="highlight">health bars, special abilities, and custom pieces</span>!</p>
                    <p>Every piece has HP and a unique ability. Your goal is still to destroy the enemy King, but now you can do it through <span class="highlight">checkmate OR by draining their HP to zero</span>.</p>
                    <div class="tutorial-tip">💡 Don't worry if you've never played chess before — this tutorial will teach you everything step by step!</div>
                `
            },
            {
                title: "The Board & Moving Pieces",
                content: `
                    <p>The board is an 8×8 grid. You play as <span class="highlight">White</span> (bottom) and move first.</p>
                    <p>To move a piece:</p>
                    <p>1. <span class="highlight">Click</span> one of your pieces — it highlights yellow</p>
                    <p>2. <span class="highlight">Green squares</span> appear showing where you can move</p>
                    <p>3. <span class="highlight">Click a green square</span> to move there</p>
                    <div class="tutorial-visual">
                        <div class="demo-board">
                            <div class="demo-sq lt"></div><div class="demo-sq dk"></div><div class="demo-sq lt"></div><div class="demo-sq dk"></div>
                            <div class="demo-sq dk"></div><div class="demo-sq lt"></div><div class="demo-sq dk mv"></div><div class="demo-sq lt"></div>
                            <div class="demo-sq lt mv"></div><div class="demo-sq dk"></div><div class="demo-sq sel">♘</div><div class="demo-sq dk"></div>
                            <div class="demo-sq dk"></div><div class="demo-sq lt mv"></div><div class="demo-sq dk"></div><div class="demo-sq lt mv"></div>
                        </div>
                        <div class="demo-caption">A Knight is selected (yellow) — green squares show where it can jump</div>
                    </div>
                    <div class="tutorial-tip">💡 If you click the wrong piece, just click a different one to switch.</div>
                `
            },
            {
                title: "Standard Chess Pieces",
                content: `
                    <p>Each piece moves differently:</p>
                    <div class="tutorial-pieces-grid">
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♔</div>
                            <div class="tp-name">King</div>
                            <div class="tp-desc">1 square any direction. 250 HP. Protect him at all costs!</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♕</div>
                            <div class="tp-name">Queen</div>
                            <div class="tp-desc">Any direction, any distance. 120 HP. Your strongest piece.</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♖</div>
                            <div class="tp-name">Rook</div>
                            <div class="tp-desc">Straight lines (up/down/left/right). 75 HP.</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♗</div>
                            <div class="tp-name">Bishop</div>
                            <div class="tp-desc">Diagonal lines only. 75 HP.</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♘</div>
                            <div class="tp-name">Knight</div>
                            <div class="tp-desc">L-shape jumps (can hop over pieces). 75 HP.</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♙</div>
                            <div class="tp-name">Pawn</div>
                            <div class="tp-desc">Forward 1 (or 2 from start). Captures diagonally. 30 HP.</div>
                        </div>
                    </div>
                    <div class="tutorial-tip">💡 Move onto an enemy piece to capture it — they take damage or get removed!</div>
                `
            },
            {
                title: "Health Bars & Damage",
                content: `
                    <p>Every piece has a <span class="highlight">health bar</span> shown under it. Unlike normal chess, pieces don't always die in one hit!</p>
                    <p>When you move onto an enemy piece, you <span class="highlight">capture</span> it (removes it). But abilities deal <span class="highlight">damage</span> instead — the piece loses HP and only dies when it hits 0.</p>
                    <div class="tutorial-visual">
                        <div style="display: flex; justify-content: center; gap: 30px; align-items: center; font-size: 1.3em;">
                            <div style="text-align: center;">
                                <div style="font-size: 2em;">♖</div>
                                <div style="width: 60px; height: 6px; background: #333; border-radius: 3px; margin: 5px auto;">
                                    <div style="width: 100%; height: 100%; background: linear-gradient(90deg, #ff0, #0f0); border-radius: 3px;"></div>
                                </div>
                                <div style="color: #4CAF50; font-size: 0.7em;">75/75 HP</div>
                            </div>
                            <div style="color: #ffd700; font-size: 1.5em;">→ 💥 →</div>
                            <div style="text-align: center;">
                                <div style="font-size: 2em;">♖</div>
                                <div style="width: 60px; height: 6px; background: #333; border-radius: 3px; margin: 5px auto;">
                                    <div style="width: 53%; height: 100%; background: linear-gradient(90deg, #f00, #ff0); border-radius: 3px;"></div>
                                </div>
                                <div style="color: #ff6b6b; font-size: 0.7em;">40/75 HP</div>
                            </div>
                        </div>
                        <div class="demo-caption">A Rook takes 35 damage from a Cannon ability — it survives with 40 HP!</div>
                    </div>
                    <p>The <span class="highlight">King has 250 HP</span> — the most of any piece. You win by either checkmating the King OR reducing it to 0 HP.</p>
                `
            },
            {
                title: "Special Abilities ⚡",
                content: `
                    <p>This is what makes Chess Warfare unique! Every piece has a <span class="highlight">one-time special ability</span>.</p>
                    <p>To use an ability:</p>
                    <p>1. <span class="highlight">Double-click</span> your piece (the ⚡ icon means it's available)</p>
                    <p>2. <span class="highlight">Red squares</span> appear showing valid targets</p>
                    <p>3. <span class="highlight">Click a red square</span> to use the ability</p>
                    <div class="tutorial-pieces-grid">
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♙</div>
                            <div class="tp-name">Pawn: Shoot</div>
                            <div class="tp-desc">Fire a bullet forward for 20 damage</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♖</div>
                            <div class="tp-name">Rook: Cannon</div>
                            <div class="tp-desc">Fire a cannonball for 35 damage</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♘</div>
                            <div class="tp-name">Knight: Slam</div>
                            <div class="tp-desc">Jump and deal 30 dmg in a 3×3 area</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♗</div>
                            <div class="tp-name">Bishop: Swap</div>
                            <div class="tp-desc">Teleport-swap with an enemy piece</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♕</div>
                            <div class="tp-name">Queen: Heal</div>
                            <div class="tp-desc">Restore 50 HP to a friendly piece</div>
                        </div>
                        <div class="tutorial-piece-card">
                            <div class="tp-icon">♔</div>
                            <div class="tp-name">King: Counter</div>
                            <div class="tp-desc">Shield + 100 dmg to all attackers (only when in check!)</div>
                        </div>
                    </div>
                    <div class="tutorial-tip">⚠️ Each ability can only be used ONCE per game — use them wisely!</div>
                `
            },
            {
                title: "Check, Checkmate & Winning",
                content: `
                    <p><span class="highlight">Check:</span> When the enemy King is being attacked. The turn display will flash red with "CHECK!" — you must escape it.</p>
                    <p><span class="highlight">Checkmate:</span> The King is in check and has no legal moves to escape. Game over!</p>
                    <p><span class="highlight">Two ways to win:</span></p>
                    <p>1. ♟ <span class="highlight">Checkmate</span> — trap the King with no escape</p>
                    <p>2. 💥 <span class="highlight">Destroy the King</span> — reduce its HP to 0 with abilities</p>
                    <div class="tutorial-tip">💡 The King's Counter-Strike ability is a last resort — if you're checkmated but haven't used it yet, double-click your King for a chance to survive!</div>
                    <p><span class="highlight">Pawn Promotion:</span> If your Pawn reaches the opposite end of the board, you can upgrade it to a Queen, Rook, Knight, or Bishop!</p>
                `
            },
            {
                title: "Game Modes",
                content: `
                    <p>There are three ways to play:</p>
                    <p><span class="highlight">👥 Player vs Player</span> — Two players take turns on the same screen. Great for playing with a friend!</p>
                    <p><span class="highlight">🤖 Player vs Computer</span> — Play against the AI. Use the difficulty slider to set how hard it plays (1 = random moves, 100 = very smart).</p>
                    <p><span class="highlight">⚔️ Ranked Mode</span> — Competitive mode against the AI! You earn <span class="highlight">Ranked Points (RP)</span> for winning and climb through 8 tiers:</p>
                    <p style="text-align:center; font-size:0.9em; color:#ccc; line-height: 2;">
                        Bronze → Silver → Gold → Platinum → Emerald → Champion → Ultimate Champion → <span style="color:#dc143c; font-weight:bold;">Crimson</span>
                    </p>
                    <div class="tutorial-tip">💡 In Ranked, the AI gets harder every round. You earn 30-35 RP per win based on speed and how many pieces you keep alive. Losses cost 15 RP.</div>
                `
            },
            {
                title: "You're Ready!",
                content: `
                    <p>Here's a quick cheat sheet:</p>
                    <p>🖱️ <span class="highlight">Click</span> a piece to select it, then click a green square to move</p>
                    <p>🖱️🖱️ <span class="highlight">Double-click</span> a piece to activate its ability, then click a red target</p>
                    <p>⚡ Every piece has <span class="highlight">one ability</span> — use them at the right moment</p>
                    <p>❤️ Pieces have <span class="highlight">health bars</span> — abilities deal damage, captures remove pieces</p>
                    <p>👑 Win by <span class="highlight">checkmate or destroying the King's HP</span></p>
                    <div class="tutorial-tip">💡 Check the piece guide on the left side of the board during the game — it shows all abilities and stats!</div>
                    <p style="text-align: center; margin-top: 15px; color: #ffd700; font-size: 1.1em; font-weight: bold;">Good luck, Commander! ♟️</p>
                `
            }
        ];

        function openTutorial() {
            tutorialStep = 0;
            document.getElementById('tutorial-overlay').classList.remove('hidden');
            renderTutorialStep();
        }

        function closeTutorial() {
            document.getElementById('tutorial-overlay').classList.add('hidden');
        }

        function tutorialNext() {
            if (tutorialStep < TUTORIAL_STEPS.length - 1) {
                tutorialStep++;
                renderTutorialStep();
            } else {
                closeTutorial();
            }
        }

        function tutorialPrev() {
            if (tutorialStep > 0) {
                tutorialStep--;
                renderTutorialStep();
            }
        }

        function renderTutorialStep() {
            const step = TUTORIAL_STEPS[tutorialStep];
            const total = TUTORIAL_STEPS.length;

            document.getElementById('tutorial-step-counter').textContent = `STEP ${tutorialStep + 1} OF ${total}`;
            document.getElementById('tutorial-title').textContent = step.title;
            document.getElementById('tutorial-content').innerHTML = step.content;

            // Progress dots
            const dotsContainer = document.getElementById('tutorial-progress');
            dotsContainer.innerHTML = '';
            for (let i = 0; i < total; i++) {
                const dot = document.createElement('div');
                dot.className = 'tutorial-dot';
                if (i === tutorialStep) dot.classList.add('active');
                else if (i < tutorialStep) dot.classList.add('done');
                dotsContainer.appendChild(dot);
            }

            // Button states
            document.getElementById('tutorial-back').disabled = (tutorialStep === 0);
            document.getElementById('tutorial-next').textContent =
                tutorialStep === total - 1 ? "Let's Play!" : 'Next';
        }

        window.onload = function() {
            initRankedInfoDisplay();
            document.getElementById('mode-selector').classList.remove('hidden');
            document.getElementById('lobby-code-input').addEventListener('keyup', (e) => {
                if (e.key === 'Enter') onlineJoinRoom();
            });
        };
    </script>

</body></html>